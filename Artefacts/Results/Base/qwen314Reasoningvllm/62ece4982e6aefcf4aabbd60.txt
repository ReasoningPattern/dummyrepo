
Okay, I need to write a Python function called size_to_bytes that converts a human-readable file size string into bytes. The example given is '500K' which should return 500 * 1024 bytes. Let me think about how to approach this.

First, the input is a string like '500K', '2M', '1.5G', etc. So the function needs to parse the string into a numerical value and a unit suffix. The suffix can be K, M, G, T, P, E, Z, Y, which represent different powers of 1024. Also, maybe lowercase letters? The example uses uppercase, but maybe the function should handle both cases. Or perhaps the problem expects only uppercase? The docstring doesn't specify, but it's safer to assume case-insensitivity.

So the steps are: split the string into the number part and the suffix. Then convert the number to bytes based on the suffix. For example, '500K' is 500 * 1024, '2M' is 2 * 1024^2, and so on.

How to split the string? The number can be a decimal, like '1.5G', so the suffix is the last character. Wait, but what if the number has multiple digits before the suffix? Like '1024MB'? Wait, the example given is '500K', so maybe the suffix is one character. But sometimes, like in 'MB', it's two letters. Hmm, but the problem says "human readable file size", which typically uses single-letter suffixes. For example, '500K' is kilobytes, '2M' is megabytes, etc. So maybe the suffix is one character, and the rest is the number.

But wait, what about cases like '500KB'? That's a bit ambiguous. However, the problem's example uses '500K', so perhaps the function is designed to take the last character as the suffix. So I'll assume that the input string is in the format of [number][suffix], where the suffix is a single character.

So, first, I need to extract the suffix. Let's take the last character of the string. Then, the number part is the rest of the string. But what if the number is something like '1.23' or '1024'? Need to parse that as a float or integer.

Wait, the return type is int. So even if the number is a float, like '1.5G', we need to convert it to bytes. But 1.5G would be 1.5 * 1024^3, which could be a float, but the function returns an int. So perhaps the function should convert it to an integer by truncating or rounding? The problem says "human readable", which might imply that the input is a whole number, but maybe it's better to handle decimal points by converting to float first and then multiplying by the appropriate factor, then converting to int. But how to handle that? For example, '1.5K' would be 1.5 * 1024 = 1536 bytes. So converting that to int would be okay.

So the plan is:

1. Check if the input string is valid. But the problem doesn't mention error handling, so maybe assume that the input is correctly formatted.

2. Extract the suffix from the last character of the string. But what if the string is something like '1024'? Then there's no suffix. In that case, the default is bytes. So if the suffix is not present, return the number as is.

3. Convert the number part to a float, then multiply by the corresponding factor based on the suffix.

The suffix mapping would be:

- 'K' -> 1024^1
- 'M' -> 1024^2
- 'G' -> 1024^3
- 'T' -> 1024^4
- 'P' -> 1024^5
- 'E' -> 1024^6
- 'Z' -> 1024^7
- 'Y' -> 1024^8

But also, maybe lowercase letters? Like 'k' or 'm'? The example uses uppercase, but perhaps the function should handle both. Let me check the problem statement again. The docstring says "eg: '500K'", but doesn't specify if other cases are allowed. Since it's a common scenario, maybe the function should be case-insensitive. So I'll convert the suffix to uppercase and check against that.

So, first, get the last character of the size string. Then, check if it's one of the suffixes. If it is, then take the rest of the string as the number. If not, assume it's bytes.

But how to handle cases where the suffix is more than one character? Like 'KB' or 'MB'? The example uses '500K', so maybe the function expects the suffix to be a single character. However, in real scenarios, sometimes it's two letters. But given the example, perhaps the problem expects single-letter suffixes. So I'll proceed under that assumption.

So, code steps:

- Check if the size string is empty? Probably not, but the function may need to handle that. However, the problem says the input is a human-readable size, so maybe assume it's properly formatted.

- Take the last character as the suffix. If the suffix is in the list, then process accordingly. Else, treat the entire string as bytes.

But wait, what if the string is '500' with no suffix? Then return 500 as an integer.

So, code:

def size_to_bytes(size: str) -> int:
    suffix = size[-1].upper()
    number_part = size[:-1]
    if suffix in ['K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']:
        # determine the factor
        factors = {
            'K': 1024,
            'M': 1024**2,
            'G': 1024**3,
            'T': 1024**4,
            'P': 1024**5,
            'E': 1024**6,
            'Z': 1024**7,
            'Y': 1024**8
        }
        factor = factors[suffix]
        # convert number_part to float, then multiply by factor
        # then convert to int
        return int(float(number_part) * factor)
    else:
        # no suffix, return as integer
        return int(size)

Wait, but what if the number_part is something like '1.5'? Converting to float and then multiplying by the factor, then converting to int. But for example, '1.5K' would be 1.5 * 1024 = 1536, which is correct. However, if the input is '1024', then it returns 1024 as bytes.

But what about if the suffix is not in the list? Like '500B'? Then the code would return 500 as bytes. But maybe 'B' is not considered here. However, the problem's example doesn't include 'B', so perhaps the function is intended to handle only the suffixes K, M, G, etc. So if the suffix is not one of those, then it's treated as bytes.

But what if the input is '500KB'? Then the code would take the last character as 'B', which is not in the list, so return 500 as bytes. But that's incorrect. However, given the example, perhaps the function is designed for single-letter suffixes. So maybe the problem expects that the input is in the format where the suffix is one character. So the code can proceed as such.

Another edge case: size is '0K' which would return 0. Also, numbers with decimal points, like '1.23G' would be handled as float.

But what if the string is something like '100'? Then the code returns 100 as bytes.

Testing with the example '500K' would return 500 * 1024 = 512000.

But wait, the code uses int(float(number_part) * factor). For example, if the number_part is '500', then float is 500.0, multiplied by 1024 gives 512000.0, which is converted to 512000 as int. That's correct.

But what if the number_part is something like '1.5'? Then float is 1.5, multiplied by factor, then converted to int. So for '1.5K', it would be 1536.0, which becomes 1536. That's acceptable.

Now, code-wise, the function would first check if the last character is a suffix. But what if the string is like '500' (no suffix)? Then size[-1] is '0', which is not in the suffix list. So it returns int('500') which is 500. That's correct.

Another case: '1.5M' would be 1.5 * 1024^2 = 1966080.0, converted to int 1966080.

But what about if the suffix is lowercase? Like '500k'? The code converts it to uppercase, so it would work.

So the code seems to handle that.

But what about if the size is '500KB'? The code would take the last character as 'B', which is not in the suffix list, so returns 500 as bytes. But that's not correct. However, given the example provided, perhaps the function is intended to only handle single-letter suffixes. So maybe the problem expects that the input is in the format of [number][suffix], where the suffix is one of K, M, G, etc., and the function doesn't need to handle cases where the suffix is longer.

So the code should work for the given example and similar cases.

Now, implement this in Python.

But need to make sure that the number_part can be converted to a float. For example, if the input is '5K', then number_part is '5', which is fine. If it's '5.5M', then number_part is '5.5'.

But what if the input is invalid, like 'K500'? Well, the problem says the input is a human-readable size, so perhaps it's assumed that the input is valid. So no error checking is needed.

So the code would be:

def size_to_bytes(size: str) -> int:
    """
    Convert human readable file size to bytes

    Args:
        size: str, a string representing a human readable file size (eg: '500K')
    Returns:
        int: file size in bytes
    """
    suffix = size[-1].upper()
    number_part = size[:-1]
    if suffix in ['K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']:
        factors = {
            'K': 1024,
            'M': 1024**2,
            'G': 1024**3,
            'T': 1024**4,
            'P': 1024**5,
            'E': 1024**6,
            'Z': 1024**7,
            'Y': 1024**8
        }
        return int(float(number_part) * factors[suffix])
    else:
        return int(size)

Wait, but what if the number_part is empty? Like if the input is 'K'? Then size[:-1] is empty string, which would cause a ValueError when converting to float. But according to the problem statement, the input is a valid human-readable size. So perhaps the function is supposed to handle such cases. However, the problem's example shows '500K', so maybe the input is always valid. But in practice, maybe the function should handle cases where the suffix is present but the number is missing? But since the problem doesn't mention it, perhaps we can assume that the input is properly formatted.

So the code as written would handle the example cases. Let me test with '500K' -> 500 * 1024 = 512000. Correct.

Another test case: '2M' would be 2 * 1024^2 = 2097152. Correct.

What about '1.5G'? 1.5 * 1024^3 = 1990659072.0, which becomes 1990659072 as int. Correct.

If the input is '1024', then the else clause returns 1024. Which is correct as bytes.

But what if the input is '1024B'? Then the suffix is 'B', which is not in the list, so returns 1024 as bytes. Which is correct.

But what if the input is '100MB'? The code would take the last character as 'B', and the number_part is '100M', which would be converted to 100M as a float? No, because '100M' is not a number. So this would raise a ValueError. But again, the problem says the input is valid. So maybe the function is only intended for single-letter suffixes.

Therefore, the code should work as per the given problem statement.
