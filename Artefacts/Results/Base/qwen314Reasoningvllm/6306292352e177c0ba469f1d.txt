
Okay, I need to generate Python code for the function find_tags based on the given signature and docstring. Let's see, the function is supposed to find tags in a text while ignoring those inside code blocks. Also, if a replacer function is provided, it should replace the tag words with the result of that function. The return value is a tuple of a set of tags and the modified text.

First, I should figure out how to identify code blocks. Typically, code blocks in Markdown are enclosed within triple backticks. So maybe the approach is to split the text into parts that are inside code blocks and parts that are not. Then, process only the non-code parts for finding tags.

But how to split the text? I can use a state machine approach. Iterate through the text, and whenever I encounter a code block start (like ```), toggle a flag indicating whether I'm inside a code block. Then, when not inside a code block, look for tags.

What's a tag here? The docstring says "tags", but it's not clear what defines a tag. Maybe it's words enclosed in angle brackets, like <tag>? Or perhaps it's something else. Since the example isn't given, I'll assume that tags are words that are surrounded by angle brackets, such as <example> or </example>. So the pattern would be something like <\w+>?

Wait, but the function's parameters mention a replacer that's called with the tag word. So maybe the tag is the content between the angle brackets. For example, if the text has <hello>, the tag is 'hello', and if replacer is provided, it replaces that with replacer('hello').

So the steps would be:

1. Split the text into code and non-code sections.
2. In non-code sections, find all tags (like <...>).
3. For each tag found, add the inner text (without the brackets) to the set of tags.
4. If a replacer is provided, replace each tag with the result of replacer(tag_content).
5. Return the set of tags and the modified text.

But how to split the text into code blocks? Let's think about using regular expressions. Maybe find all occurrences of code blocks and mask them, then process the rest.

Alternatively, process the text while keeping track of whether we're inside a code block. Let's try that approach.

I can loop through the text, keeping track of whether we're inside a code block. When not inside, scan for tags. For each tag found, extract the content, add to the set, and if replacer is present, replace it.

But how to handle the replacement? Maybe using a regex substitution, but only in the non-code parts. However, that might be complicated. Another way is to split the text into parts, process each part, and then reassemble them.

So, the plan is:

- Use a regex to split the text into code blocks and non-code text. But since code blocks can have varying delimiters (like ```python or ```), maybe the regex should capture everything between triple backticks, including the delimiter.

Wait, perhaps using a regex that finds all code blocks and then processes the text outside of them. For example, using re.split with a regex that captures code blocks and the rest. But splitting might not be straightforward because code blocks can have multiple lines.

Alternatively, iterate through the text, and when a code block starts, skip until it ends. For each non-code segment, find the tags.

But how to handle the replacement? Let's think about building the modified text. For each non-code segment, replace the tags with the replacer's output, and then combine everything back.

So here's a possible approach:

Initialize a variable to track if we're inside a code block. Then, iterate through the text, splitting it into tokens. When not inside a code block, look for tags. For each tag found, add the content to the set and replace it with the replacer's result if provided.

But how to split the text into code and non-code parts. Maybe using re.findall to get all the code blocks and the other text. For example, using a regex pattern that matches either code blocks or non-code text.

The regex pattern could be something like (```.*?```)|([^<]+). Wait, but that might not work well. Maybe a better way is to split the text into regions that are inside code blocks and those that are not.

Alternatively, using a regex that finds all the code blocks and then processes the remaining text. Let me think about using re.sub with a callback function. But the problem is that the code blocks need to be left untouched.

Another idea: split the text into parts that are inside code blocks and parts that are not. For example, using a regex to split on code blocks, then process each non-code part.

But how to do that. Let's consider using re.split with a capturing group. The pattern could be (```.*?```), which captures code blocks. Then, the split would give us a list of non-code parts and code blocks. Then, for each non-code part, process it for tags.

Wait, but the split would separate the code blocks from the rest. So for example, if the text is "Hello <tag> ```code``` <another>", splitting on (```.*?```) would give ["Hello <tag> ", "code", " <another>"].

But then, the code blocks are in the even indices (assuming split returns the non-matching parts first, then the matching ones). Wait, re.split with capturing groups returns the split parts along with the captured groups. So maybe the list would alternate between non-code text and code blocks.

So, for each element in the split list, if it's a code block (starts with ```), leave it as is. Otherwise, process it for tags.

But how to split the text into these parts. Let's use re.split with a pattern that matches code blocks, using a capturing group. The pattern would be (```.*?```), but that's a bit simplistic. Because code blocks can have multiple lines and may contain other ``` if not properly escaped. However, assuming that the code blocks are properly formatted, maybe this approach is acceptable.

Alternatively, using a regex that matches code blocks with triple backticks, and then using re.sub to replace the tags in the non-code parts.

But perhaps the best way is to process the text in a way that ignores code blocks. Let's think about using a state variable. Iterate through the text, and when we encounter a code block start, set a flag to True. When we encounter the end of a code block (another triple backtick), set the flag to False. Then, during the iteration, when the flag is False, we look for tags.

But how to handle the code block start and end. For example, the text could have multiple code blocks. So perhaps using a regex to find all the code blocks and then process the text in between.

Alternatively, using a regex that finds all the text outside of code blocks. That might be more complex. Maybe using a regex with negative lookbehind and lookahead, but that's tricky.

Another approach is to use a regex to find all the code blocks and replace them with a placeholder, then process the entire text, and then replace the placeholders back. But that might not be feasible if the code blocks are nested or have varying delimiters.

Hmm. Let's think of the code blocks as starting with ``` and ending with ```. So, the idea is to split the text into code and non-code regions. For each non-code region, extract the tags.

So, perhaps using re.split with a pattern that captures code blocks. Let me try writing a regex that can split the text into code blocks and non-code parts. For example, the pattern could be (```.*?```), but using re.DOTALL to capture newlines. However, this would split on the first occurrence of ```...```, but if there are multiple code blocks, maybe using re.findall with a pattern that matches either code blocks or non-code text.

Wait, maybe using re.findall with a pattern that matches either code blocks or non-code text. The pattern could be something like (```.*?```)|([^<]+). But that's not perfect. For example, if there's a tag in the non-code text, but the regex would split it into parts. Alternatively, perhaps using a regex that captures all text not inside code blocks.

Alternatively, using a regex to find all the code blocks, then replace them with a placeholder, process the rest of the text, then replace the placeholders back. But this approach would require knowing the code blocks and their positions.

Alternatively, using a regex to find all the tags that are not inside code blocks. But how to do that. Maybe using a negative lookbehind and lookahead, but that's complicated.

Alternatively, using a state machine. Let's think of the text as a sequence of characters. When we encounter a code block start, we switch to code mode, and when we encounter the end, we switch back. Then, during non-code mode, we can look for tags.

But how to detect code blocks. The code blocks start with ``` and end with ```. However, the content between them can be anything, including other ``` if they are properly escaped. But for simplicity, perhaps assuming that code blocks are properly formed, and that each ``` starts a code block and the next ``` ends it.

So, the code can be written as follows:

Initialize variables: inside_code = False, result_text = [], tags = set()

Then, iterate through the text, splitting it into tokens. When inside_code is False, look for the start of a code block. When found, set inside_code to True and add the code block to result_text as is. When inside_code is True, look for the end of the code block. Once found, set inside_code to False and add the code block to result_text. For the non-code parts, process them for tags.

But how to split the text into these parts. Maybe using a regex that finds all the code blocks and the rest of the text. For example, using re.findall with a pattern that matches either code blocks or non-code text.

The pattern could be (```.*?```)|([^```]+). But that might not work if there are multiple code blocks. Let me think. The regex would match either a code block or any text that's not part of a code block. However, the problem is that the code blocks can contain other characters, including backticks. But perhaps using a non-greedy match for the code blocks.

Alternatively, using a regex that matches code blocks and captures them, then the rest of the text can be processed.

But perhaps the easiest way is to split the text into parts that are inside code blocks and parts that are not. For example, using re.split to separate code blocks from the rest. Let me try that.

Wait, here's an idea: use re.split to split the text into code blocks and other text. For example, the pattern would be (```.*?```), using re.DOTALL. Then, the split would give us a list where even indices are the non-code parts and odd indices are the code blocks. Then, for each non-code part, process it for tags.

But in that case, the split would separate the code blocks. Then, for each non-code part, we can find all tags and replace them if needed.

So, code steps:

- Split the text into code and non-code parts.
- For each non-code part, find all tags (like <...>), extract their content, add to the set.
- If a replacer is provided, replace each tag in the non-code part with the replacer's output.
- Reconstruct the text by combining the processed non-code parts and the original code blocks.

But how to split the text into code and non-code parts. Let's use re.split with a capturing group. The pattern would be (```.*?```), but with re.DOTALL to capture newlines. However, this might not capture all code blocks if there are multiple, but perhaps it's sufficient for the problem's scope.

Wait, the split would split the text into parts that are not code blocks and the code blocks themselves. For example, if the text is "Hello ```code``` world", then split would give ["Hello ", "```code```", " world"].

But then, the code blocks are in the odd indices (1, 3, etc.), and the non-code parts are in the even indices (0, 2, etc.). So, for each non-code part, process for tags.

Now, processing each non-code part for tags. The tags are words in angle brackets. So, using a regex like <(\w+)>, but maybe more general, like <([^<]+)> to capture anything except < inside the tags.

But the problem is that the tags could be in various forms. For example, <tag>, <tagname>, etc. Assuming that the tags are any text between < and >, and that the replacer function is called with the content inside the tags.

So, for each non-code part, find all occurrences of <...> and collect the inner text as tags. Then, replace each occurrence with the result of replacer if provided.

So, for each non-code part, we can use re.sub with a function. The function would capture the tag content, add it to the set, and then replace it with the replacer's output if present.

Wait, but the replacer is called with the tag word. So, for example, if the tag is <hello>, the replacer is called with 'hello'.

So, here's the plan for processing a non-code part:

Use re.sub with a pattern that matches <...>, and for each match, extract the content (using a group), add it to the tags set, and if replacer is not None, replace the entire tag with replacer(content). Otherwise, leave the tag as is.

But how to do that in Python. Using a lambda function as the replacement.

But in the code, I need to process each non-code segment. Let's think of code:

import re
from typing import Tuple, Set, Callable

def find_tags(text: str, replacer: Callable = None) -> Tuple[Set, str]:
    code_blocks = re.findall(r'```.*?```', text, re.DOTALL)
    non_code_parts = re.split(r'```.*?```', text, flags=re.DOTALL)
    tags = set()
    processed_parts = []
    for i, part in enumerate(non_code_parts):
        if i % 2 == 0:  # even indices are non-code parts
            # process this part for tags
            # find all tags in part
            # for each tag, add to tags set and replace if needed
            # using re.sub with a function
            def replace_tag(match):
                tag_content = match.group(1)
                tags.add(tag_content)
                if replacer is not None:
                    return replacer(tag_content)
                else:
                    return match.group(0)
            processed_part = re.sub(r'<([^>]*)>', replace_tag, part)
            processed_parts.append(processed_part)
        else:
            # code block, append as is
            processed_parts.append(part)
    # Now, reconstruct the text by alternating non-code and code parts
    # Wait, the split would have non_code_parts as the first element, then code_block, then non_code_part, etc.
    # So, the original text is split into non_code_part, code_block, non_code_part, code_block, etc.
    # So, the processed_parts list would have the processed non_code parts and the original code blocks.
    # But how to recombine them. The original split would have non_code_parts as the first element, then code_block, then non_code_part, etc. So the code_blocks list is the same as the split code parts. But maybe the code_blocks list is not in the same order as the split. Wait, re.findall returns all the code blocks, and re.split returns the non-code parts and code blocks in order.

Wait, re.split with a pattern that matches code blocks would split the text into the parts that are not code blocks, and the code blocks are in the split result as well. For example, if text is "a ```code``` b ```more code``` c", then split would give ["a ", "code", " b ", "more code", " c"].

But the code_blocks list from re.findall would be ["```code```", "```more code```"].

So, the split parts are non-code parts and code parts alternately. The first element is non-code, then code, then non-code, etc. So, for the non_code_parts list, the even indices (0, 2, 4, etc.) are the non-code parts, and the odd indices are the code blocks. However, in the split, the code blocks are in the odd positions, but the split result may have more elements than code_blocks. For example, if the text starts with a code block, then the first element of non_code_parts would be an empty string.

But in the code above, the code_blocks list is separate. However, the split parts may not be the same as the code_blocks. Because the split pattern is (```.*?```), then the split would separate the text into non-code parts and code parts. So, for example, the split result would be [non_code_part_0, code_block_0, non_code_part_1, code_block_1, ...].

But the code_blocks list from findall would be [code_block_0, code_block_1, ...].

So, perhaps the code_blocks list isn't needed. Instead, during the split, we can process the non-code parts and leave the code parts as is.

But in the code above, the split is done using re.split(r'```.*?```', text, flags=re.DOTALL). However, that would split the text into parts that are not code blocks. But the code blocks themselves are not included in the split result. Wait, no. The split function with a pattern that has a capturing group will return the split parts along with the captured groups. Wait, no. The re.split function with a pattern that has a capturing group will include the captured groups in the result. For example, if you split on (a), then the split parts would include the 'a's.

Wait, no. re.split with a pattern that has a capturing group returns the split parts and the captured groups. For example, re.split('a', 'b a c', 1) would split into ['b ', ' a ', ' c'] if the pattern is 'a', but if the pattern is (a), then the split would be ['b ', 'a', ' c'].

So, in the code above, using re.split(r'```.*?```', text, flags=re.DOTALL) would split the text into the non-code parts and the code blocks. But the split would include the code blocks as elements in the list. So, the non_code_parts variable would be the list of split parts, which includes both non-code and code parts. Wait, no. The split function with a pattern that matches the code blocks would split the text into the parts that are not code blocks, and the code blocks are the split elements. For example, the split would be:

original text: "non-code ```code``` non-code"

split on (```.*?```), then the result is ["non-code ", "code", " non-code"].

So, the code_blocks are the elements at odd indices (1, 3, etc.), and the non-code parts are at even indices (0, 2, etc.). Therefore, in the loop, for each part in non_code_parts, if the index is even, process it for tags, else leave it as is.

But then, the code_blocks are in the split parts. Wait, no. The split would return the text split by the code blocks. So, for example, if the text starts with a code block, the first element would be an empty string, then the code block, then the rest.

So, the code above would have non_code_parts as the split result, which includes both the non-code parts and the code blocks. But how to distinguish between them. Oh, because the split is done using the code block pattern, the code blocks are the elements that match the pattern. However, the split function returns the parts that are not matched by the pattern, and the matched parts as separate elements. Wait, no. The split function splits the text into the parts that are not matching the pattern, and the matched parts are not included. Wait, no. If you use re.split with a pattern that has a capturing group, then the split parts will include the captured groups. Let me check.

Actually, the re.split function returns a list where the elements are the non-matching text, and the captured groups are included. For example, using re.split(r'(a)', 'b a c') would split into ['b ', 'a', ' c'].

So, in our case, if we split on the pattern (```.*?```), then the split parts would alternate between non-code parts and code blocks. So, the first element is the text before the first code block, then the first code block, then the text after the first code block but before the next, etc.

So, during processing, for each element in the split list, if the index is even, it's a non-code part. If it's odd, it's a code block. Therefore, in the loop, for each part, if it's even, process it for tags and replacement. If it's odd, just append it as is.

But the problem is that the split would include the code blocks as elements. So, the code_blocks variable isn't needed. Instead, during the split, we can process each part based on its index.

So, the code would be:

processed_parts = []
for i, part in enumerate(non_code_parts):
    if i % 2 == 0:
        # process for tags
        processed_part = re.sub(...)
        processed_parts.append(processed_part)
    else:
        processed_parts.append(part)

Then, the final text is ''.join(processed_parts).

But how to handle the split correctly. Let me test with an example.

Original text: "Hello <tag> ```code``` <another>"

Split using re.split(r'```.*?```', text, flags=re.DOTALL) would split into ["Hello <tag> ", "code", " <another>"].

So, the first part is non-code (index 0), then code (index 1), then non-code (index 2). So, the loop would process index 0 and 2 as non-code parts, and index 1 as code.

So, the code would process the non-code parts, and leave the code parts as is.

Now, for each non-code part, find all tags. The regex pattern for tags is <([^>]*)>, which captures the content inside the tags.

But in the replacement, we need to replace the entire tag with the replacer's output. So, the substitution function would take the match, get the content, add to the set, and replace the tag with the replacer's result if present.

So, the replace_tag function would be:

def replace_tag(match):
    content = match.group(1)
    tags.add(content)
    if replacer:
        return replacer(content)
    else:
        return match.group(0)

But since this is inside a loop, and the tags set is being built, we need to make sure that the replace_tag function can access the tags variable. However, in Python, if the function is defined inside the loop, it can capture variables from the outer scope.

Wait, but in the code above, the replace_tag is defined inside the for loop. But in Python, functions can be defined inside loops. However, using a lambda might be tricky here. Alternatively, using a nested function.

But perhaps using a regex substitution with a function that can modify the tags set. However, in Python, the re.sub function can take a function as the replacement, which is called for each match. So, the replace_tag function would need to be inside the loop, but that's possible.

Wait, but the tags set is being built in the outer loop. So, if the replace_tag function is inside the loop, it can modify the tags set. However, in Python, if the function is defined inside the loop, each iteration would have its own function. But that's okay.

But perhaps it's better to define the replace_tag function outside, but with access to the tags set. However, since the tags set is being built during processing, maybe the function needs to be inside the loop. Alternatively, using a closure.

Alternatively, using a regex substitution that uses a lambda to capture the tags set. But in Python, mutable variables like sets can be accessed in closures.

So, here's the code structure:

import re
from typing import Tuple, Set, Callable

def find_tags(text: str, replacer: Callable = None) -> Tuple[Set, str]:
    tags = set()
    # Split the text into parts, alternating between non-code and code blocks
    parts = re.split(r'```.*?```', text, flags=re.DOTALL)
    processed_parts = []
    for i, part in enumerate(parts):
        if i % 2 == 0:  # non-code part
            # Find all tags in this part
            # Use re.sub with a function to collect tags and replace them
            def replace_tag(match):
                content = match.group(1)
                tags.add(content)
                if replacer is not None:
                    return replacer(content)
                else:
                    return match.group(0)
            processed_part = re.sub(r'<([^>]*)>', replace_tag, part)
            processed_parts.append(processed_part)
        else:  # code block part
            processed_parts.append(part)
    # Now, recombine the processed parts
    modified_text = ''.join(processed_parts)
    return (tags, modified_text)

Wait, but this approach may have issues. For example, the split on the code blocks may not capture all code blocks correctly. The regex ```.*?``` uses non-greedy matching, which may not work if there are multiple code blocks. Let me think: the split pattern is (```.*?```), which matches each code block as a separate element. However, the re.split function splits the text into parts wherever the pattern is found. So, for example, if the text has two code blocks, the split would separate them into parts.

But what if the code block has triple backticks inside? For example, if the code block is ```code ``` with another triple backtick. The regex would split on the first ``` and then the next ``` would be part of the code block. But in reality, code blocks are closed by the next triple backtick. However, this approach may not handle that correctly. But perhaps for the scope of this problem, we can assume that code blocks are properly formed and that the split works as intended.

Another possible issue is that the split may not capture the code blocks correctly if they have multiple lines. The re.DOTALL flag makes the . match newlines, so that should be okay.

Testing with an example: text = "Hello <tag> ```code``` <another>"

Split into ["Hello <tag> ", "code", " <another>"]

Processing index 0: part is "Hello <tag> ", which has a tag <tag>. The replace_tag function adds 'tag' to the set, and replaces it with replacer('tag') if provided.

Processing index 1: code block, append as is.

Processing index 2: part is " <another>", which has <another>, add to set and replace.

So the modified text would be "Hello [replaced tag] ```code``` [replaced another]".

But what about the code blocks that are not properly closed? Well, the problem may not require handling that, as per the docstring's instruction to "try to ignore tags inside code blocks".

Another possible problem: the split may include parts that are between code blocks. For example, if the text is "```code``` <tag> ```more code```", the split would be ["", "code", " <tag> ", "more code", ""].

So, the code parts are at index 1 and 3, and the non-code parts are 0, 2, 4.

So, the code would process the non-code parts (0, 2, 4) for tags, and leave the code parts as is.

This seems okay.

But what about if the text starts or ends with a code block? The split would include empty strings as parts, which would be handled correctly.

Now, the replacer function is called with the tag content. For example, if the tag is <hello>, replacer is called with 'hello'.

But in the code above, the regex is r'<([^>]*)>', which captures everything between < and >, excluding the >. So, match.group(1) is the content inside the tags.

Now, the function returns a tuple of (tags, modified_text). The tags are a set of all the tag contents found in non-code parts. The modified_text is the original text with tags replaced if a replacer is provided.

But wait, the code blocks are not modified. So, the code parts are added as is to the processed_parts. The non-code parts are processed for tags and replaced.

But in the example, the code parts are the elements at odd indices. So, the code:

processed_parts = []
for i, part in enumerate(parts):
    if i % 2 == 0:
        processed_part = re.sub(...)
        processed_parts.append(processed_part)
    else:
        processed_parts.append(part)
modified_text = ''.join(processed_parts)

Yes, that would reassemble the text with the code blocks left untouched and the non-code parts with tags replaced.

But what about overlapping code blocks? For example, if the text is "```code``` <tag> ```code```", the split would be ["", "code", " <tag> ", "code", ""].

So, the code parts are "code" and "code", and the non-code parts are the empty string, " <tag> ", and empty string again.

Processing the non-code parts:

For the first empty string, no tags. Then, the second non-code part is " <tag> ", which would find <tag> and replace it. The third empty string is processed as well.

This seems okay.

Now, the function returns a set of tags. But in the example, the tags would be {'tag'}, and the modified text would have the replaced tag.

But what if there are multiple tags in a non-code part? The regex would find all of them, and each would be added to the set.

Now, possible edge cases: tags inside code blocks are not processed. Tags that are not properly closed? For example, <tag. The regex would capture up to the first >, but if there's no >, it would not match. However, the problem says to find tags, so perhaps it's assumed that the tags are properly formed.

Another edge case: tags that are inside code blocks. For example, if the text is "```<tag>```", the code block is considered as part of the code, and the tag is not processed.

So, this approach should work.

Now, the code needs to import re and from typing import Tuple, Set, Callable.

But the code may have issues with the regex. For example, the split pattern is (```.*?```), which uses a capturing group. However, re.split with a capturing group returns the split parts and the captured groups. Wait, no. The split function with a capturing group returns the split parts along with the captured groups. For example, re.split(r'(a)', 'b a c') would give ['b ', 'a', ' c'].

But in our case, the split pattern is (```.*?```), so the split would return the parts that are not code blocks, and the code blocks as elements in between. So, the code parts are in the odd indices.

So, the code is correct in that.

Another thing to consider: the replacer function may return a string that includes < or >, but that's up to the user. The function's responsibility is to replace the tag content, not to validate the replacement.

Now, the code for the function:

But in the code above, the replace_tag function is defined inside the loop. However, in Python, defining a function inside a loop can lead to issues if the loop is over multiple iterations, but in this case, since the replace_tag is defined inside the loop, each iteration would have its own function. However, in the code, the replace_tag is inside the for loop, which may not be allowed. Wait, no, the code is inside the for loop. Wait, no, the for loop is iterating over parts, and inside each iteration, the replace_tag function is defined. But in Python, that's allowed. However, using a lambda might be better, but the function needs to capture the tags set and the replacer function.

Alternatively, perhaps the replace_tag function should be defined outside the loop, but with access to the tags set and replacer. But since the replacer is a parameter, and the tags set is being built, perhaps using a nested function inside the loop is okay.

Wait, but in Python, functions are first-class citizens, so defining replace_tag inside the loop is possible. However, each time the loop runs, a new function is defined. That's okay, but perhaps it's more efficient to define it once outside.

Alternatively, using a lambda inside the loop. But the lambda would need to capture the current replacer and tags. However, in the code above, the replace_tag function is inside the loop, so each time it's called, it's using the current replacer and tags.

But in the code as written, the replace_tag function is inside the for loop. However, in Python, functions can be defined inside loops. So that should be okay.

But perhaps there's a better way. Let me think. Maybe using a regex substitution with a function that is defined outside the loop.

Wait, but the tags set is being built during the substitution. So, the replace_tag function needs to modify the tags set. So, perhaps the function can be defined inside the find_tags function, but with access to the tags variable.

So, modifying the code:

def find_tags(text: str, replacer: Callable = None) -> Tuple[Set, str]:
    tags = set()
    parts = re.split(r'```.*?```', text, flags=re.DOTALL)
    processed_parts = []
    for i, part in enumerate(parts):
        if i % 2 == 0:
            # process this part
            def replace_tag(match):
                content = match.group(1)
                tags.add(content)
                if replacer is not None:
                    return replacer(content)
                else:
                    return match.group(0)
            processed_part = re.sub(r'<([^>]*)>', replace_tag, part)
            processed_parts.append(processed_part)
        else:
            processed_parts.append(part)
    modified_text = ''.join(processed_parts)
    return (tags, modified_text)

Wait, but the replace_tag function is defined inside the loop. However, in Python, each time through the loop, the replace_tag function is redefined. But that's okay.

But what about the case where the same tag appears multiple times? The set will automatically handle duplicates, so that's fine.

Another thing: the regex for tags is <([^>]*)>. This would match any text between < and >, but not including the >. However, if the tag has other characters, like <tag> with attributes, this would capture 'tag' as the content. But the problem says "tag word", so maybe it's intended to capture the entire content between < and >, regardless of what it is.

But the docstring says "find tags in text", but it's not clear what a tag is. Assuming that any content between < and > is considered a tag, and the replacer is called with that content.

Another possible issue: the code_blocks may have triple backticks in them. For example, a code block that contains ``` inside. But the regex uses non-greedy matching, so it would stop at the first ``` encountered. However, this is a problem if the code block has triple backticks inside. But perhaps this is acceptable for the problem's scope.

So, the code seems to handle the main case. Let's test it.

Sample input:

text = "This is a <test> tag. ```code with <tag> inside``` Another <example>."

Split into parts: ["This is a <test> tag. ", "code with <tag> inside", " Another <example>."]

Processing even indices (0 and 2):

For part 0: "This is a <test> tag. " → find <test> → add 'test' to tags. If replacer is provided, replace with replacer('test').

For part 2: " Another <example>." → find <example> → add 'example' to tags. Replace if needed.

The code block part (index 1) is left as is. So the modified text would be "This is a [replaced test] tag. ```code with <tag> inside``` Another [replaced example]."

So, the code would correctly ignore the <tag> inside the code block.

Now, the function returns a tuple of (tags, modified_text). The tags would be {'test', 'example'}, and the modified text has the replacements.

Another test case: text with no code blocks. Then, all parts are non-code, and the code would process them.

But what if the text has no code blocks? The split would return a list with one element (the entire text), and the code would process it.

Yes.

Another possible issue: the split pattern may not capture code blocks correctly if they have triple backticks in the middle. But again, assuming that code blocks are properly formed.

So, the code seems to handle the main requirements.

Now, implement this in Python, making sure to import re and the necessary types.

Wait, the function returns a Tuple[Set, str], but in Python, the Set is from typing, so we need to import Set from typing.

So, the imports would be:

import re
from typing import Tuple, Set, Callable

Now, the code:

def find_tags(text: str, replacer: Callable = None) -> Tuple[Set, str]:
    tags = set()
    parts = re.split(r'```.*?```', text, flags=re.DOTALL)
    processed_parts = []
    for i, part in enumerate(parts):
        if i % 2 == 0:
            def replace_tag(match):
                content = match.group(1)
                tags.add(content)
                if replacer is not None:
                    return replacer(content)
                else:
                    return match.group(0)
            processed_part = re.sub(r'<([^>]*)>', replace_tag, part)
            processed_parts.append(processed_part)
        else:
            processed_parts.append(part)
    modified_text = ''.join(processed_parts)
    return (tags, modified_text)

Wait, but in the code above, the replace_tag function is defined inside the loop. However, in Python, each time the loop runs, the replace_tag is redefined. However, this is okay. But when using re.sub, the replace_tag function is called for each match. However, since the function is defined inside the loop, but the loop is over parts, and each part is processed separately, this should be okay.

But wait, the replace_tag function is inside the for loop. So, for each part, a new replace_tag function is defined. However, when re.sub is called, it uses that function. That should work.

But perhaps there's a problem with the regex pattern for splitting. The split pattern is (```.*?```), which may not capture all code blocks. For example, if a code block is written as ```python...``` but the regex is looking for ``` followed by any characters (non-greedy) and then ```. However, the .*? would match any characters except newlines unless the re.DOTALL flag is used. Wait, the split uses flags=re.DOTALL, which makes the . match newlines. So, the code blocks can span multiple lines.

Yes, that's correct.

Another thing: the split may include the triple backticks as part of the code block. For example, the code block is ```code``` and the split would include that as part of the code block. So, the code parts are left as is, which is correct.

Now, what about the case where the code block starts with ``` and ends with ``` but has other content? The split would capture that as a code block.

So, the code seems to handle that.

Now, the function returns the set of tags and the modified text.

But what about the original text? The code is joining the processed_parts, which includes the processed non-code parts and the original code parts. So, the modified_text is the original text with the tags replaced in non-code parts and code blocks left as is.

Yes.

But what if the code block contains text that is not part of a code block? For example, if there's a code block that's not properly closed. But again, the problem says to ignore tags inside code blocks, and the code is trying to do that by splitting on code blocks. If the code block is not properly closed, the split may not work as intended. However, the problem may not require handling such cases, as it's beyond the scope.

So, the code should be correct.

Now, check for possible errors. For example, if the replacer is not a callable. But the function signature says replacer is a callable, so the user is expected to pass a function. However, the code doesn't check for that, but the type hint says it's a callable, so perhaps that's acceptable.

Another thing: the regex for tags may not capture all possible tags. For example, if a tag has closing tags like </tag>, the regex would capture 'tag' as the content. But the problem says "tag word", so maybe that's intended.

So, the code is okay.

Now, the code is written. Let's make sure that it's in Python syntax. The function uses re.split and re.sub with the correct parameters.

Yes.

So, the final code would be:

import re
from typing import Tuple, Set, Callable

def find_tags(text: str, replacer: Callable = None) -> Tuple[Set, str]:
    tags = set()
    parts = re.split(r'```.*?```', text, flags=re.DOTALL)
    processed_parts = []
    for i, part in enumerate(parts):
        if i % 2 == 0:
            def replace_tag(match):
                content = match.group(1)
                tags.add(content)
                if replacer is not None:
                    return replacer(content)
                else:
                    return match.group(0)
            processed_part = re.sub(r'<([^>]*)>', replace_tag, part)
            processed_parts.append(processed_part)
        else:
            processed_parts.append(part)
    modified_text = ''.join(processed_parts)
    return (tags, modified_text)

Wait, but the split pattern is (```.*?```), which includes the triple backticks in the code block. So, when the code is split, the code parts are the entire code block including the triple backticks. Then, when rejoining, the code parts are added back as is. So, the original code blocks are preserved in the modified text.

Yes.

But the problem says "tries to ignore tags inside code blocks". The code is doing that by not processing the code parts. So, any tags inside code blocks are left untouched, which is correct.

Now, testing with a replacer function. Suppose replacer is a function that returns the uppercase version. For example, text = "Hello <world>", replacer = lambda x: x.upper(). Then, the tags set would be {'world'}, and the modified text would be "Hello WORLD".

Yes.

Another test case: text = "<tag> ```<tag>``` <tag>". The split would be ["<tag> ", "<tag>", " <tag>"]. The first part (index 0) is "<tag> ", which would find 'tag' and replace. The code part (index 1) is "<tag>", which is left as is. The third part (index 2) is " <tag>", which would find 'tag' again. So, the tags set would be {'tag'}, and the modified text would have the first and third parts replaced, and the code block left as is.

Yes.

But what about overlapping splits? For example, if the text has multiple code blocks. The code should handle that.

So, the code seems to be correct.

Another thing: the regex for tags is <([^>]*)>, which matches <...> where ... is any characters except >. But what if the tag has > inside? Like <tag> with >. Well, the regex would capture up to the first >, which is correct.

So, the code should work as intended.
