Okay, I need to write a Python function called parse_frequency that takes a frequency string and returns a timedelta instance. Let's see the requirements again. The function should return None if the input is None or "always". Otherwise, it has to parse the string into a number and a time unit, then create a timedelta with that unit. Oh right, and if it can't parse, it should raise a ValueError.

Hmm, the input is like "3 timeunit", so first I should split the string into two parts: the number and the unit. But I have to handle cases where the input might be invalid. Let's think about the steps.

First, check if frequency is None or equals "always". In those cases, return None immediately. So start with something like:

if frequency is None or frequency.lower() == 'always':
    return None

Then, split the string into parts. Let's split on whitespace. So using split() which by default splits on any whitespace. The first part should be the number, the second the unit. But what if there are more than two parts or less? Like "3 days" would split into ["3", "days"], but "345day" or "3 day" or "3 day left" would have issues. The function expects exactly two parts. So the split must result in exactly two elements. Otherwise, we should raise ValueError.

So after splitting, check the length. If not 2, raise error.

Then, the first part is a number. Need to convert it to an integer. So try converting the first element to int. If it fails, like if it's not a numeric string, then ValueError.

The second part is the time unit. The valid units for timedelta are days, seconds, microseconds, milliseconds, minutes, hours, weeks. So the unit in the string must match one of these. But the string might have "day" or "d", but according to the example given, like "3 timeunit" returns timedelta(timeunit=3). Wait the example says "timeunit" as the unit. Wait, maybe the unit has to be exactly one of the valid keywords for timedelta? Because in the example, the input is "3 timeunit", and the output is timedelta with timeunit=3. But in reality, the actual valid units are days, seconds, etc. So perhaps the function expects that the unit part of the string must be one of those, but in the problem statement, maybe the unit can be any of those names. Wait the example is just an example, but the actual function needs to handle the real units. Let me re-read the problem.

The problem says, "given a frequency string 'number timeunit', return a datetime.timedelta instance with that timeunit=number". So the unit in the string must correspond exactly to one of the parameters that timedelta accepts. So the valid units are days, seconds, microseconds, milliseconds, minutes, hours, weeks. But the input might have those as the unit part. So for example, "5 days" would become timedelta(days=5). "2 hours" would be timedelta(hours=2). So the unit has to be one of those keys. 

So the plan is:

- Split the frequency into two parts. The first is the number, the second is the unit.
- Check if the unit is a valid keyword for timedelta. If not, raise ValueError.
- Convert the number to an integer.
- Then create a timedelta object using that unit and number.

Wait, but how to pass the unit as a keyword argument dynamically? Like, if the unit is 'days', then we can do something like:

kwargs = {unit: number}

and then call timedelta(**kwargs). Oh right, that's the way. So for example, if the unit is 'days', then the kwargs would be {'days': 3}, so timedelta(**kwargs) becomes timedelta(days=3).

So steps again:

1. Check if frequency is None or "always" (case-insensitive?), return None.
2. Split the string into parts. So parts = frequency.split(). If len(parts) !=2, error.
3. number_str, unit = parts. Check if unit is valid. The valid units are the keys that timedelta accepts. So unit must be in ['days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks'].
4. Convert number_str to integer. So try int(number_str). If that fails, raise ValueError.
5. Create a dictionary with the unit as the key and the number as the value.
6. Return timedelta(**kwargs). 

Wait, but what if the unit is given in a different form? Like 'day' instead of 'days'? The example uses 'timeunit' which is singular, but in the problem's actual case, maybe the input can have units in singular form? The problem's example shows "timeunit" so the function must take the unit as given. So the input must exactly match one of the valid keys. Otherwise, it's invalid. So for instance, if the user inputs "5 day", since 'day' isn't a valid parameter name for timedelta, that would fail. So the unit must be exactly one of the allowed keywords. So the function must check that the unit is in the list of valid units.

So first, let's get the list of valid units. Let me list them again:

The parameters for timedelta are days, seconds, microseconds, milliseconds, minutes, hours, weeks. So the unit string must be exactly one of these. So in code, the valid_units list would be ['days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks'].

So the steps:

After splitting, the second part (unit) is parts[1]. Check if it's in valid_units. If not, raise ValueError.

Putting it all together:

def parse_frequency(frequency):
    if frequency is None or frequency.lower() == 'always':
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Invalid frequency format")
    number_str, unit = parts
    try:
        number = int(number_str)
    except ValueError:
        raise ValueError("Number must be an integer")
    valid_units = ['days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks']
    if unit not in valid_units:
        raise ValueError(f"Invalid unit: {unit}")
    return datetime.timedelta(**{unit: number})

Wait but I need to import datetime. Oh right, the function uses datetime.timedelta, so the code must import that. But the problem says to generate the code based on the function signature and docstring, so maybe the code should have an import statement. But the user didn't mention it. Wait the function's return is a timedelta instance, so the code must import datetime. Let me check the function's parameters. The function's docstring says "return a corresponding datetime.timedelta instance". So the code should have from datetime import timedelta, or import datetime and use datetime.timedelta. 

In the code, the function uses datetime.timedelta, so the code must have the import. But the problem's function signature doesn't include any imports. So I have to include the import in the code. Wait the user's instruction says to output the code generated, in Python markdown format. So probably the code should include the necessary import. Let me make sure.

Wait the function as written would need to import datetime. So I should add:

import datetime

Or maybe from datetime import timedelta. Let me see which is better. Using from datetime import timedelta would make the code use timedelta directly. Let's see which way the code will be better. Let's choose the latter for brevity.

So modifying the code:

from datetime import timedelta

def parse_frequency(frequency):
    ... 
    return timedelta(**{unit: number})

Yes, that's better. So the code will start with that import.

Wait but the problem's example shows that the unit is taken as given. So if the input is "3 day" then unit is 'day', which is not in the valid_units list (since the parameter is 'days'), so that would raise an error. So the user has to provide the correct unit names. So the function is case-sensitive? The problem says to check the unit exactly. But the problem's first condition uses .lower() for "always", so perhaps the unit should also be case-insensitive? Or maybe the input is case-sensitive. Let me check the problem again.

The problem says, in the example, "3 timeunit" returns the corresponding timedelta. So the unit in the string must exactly match the parameter name. So the function should check the unit in a case-sensitive way? Or maybe the user can input the unit in any case, and we need to handle that?

The problem's docstring says to raise ValueError if the given frequency cannot be parsed. So perhaps the unit must be exactly as the parameter name. So "days" is okay, but "day" is not. So the function must check case-sensitive. 

Wait the example uses "timeunit" as the unit. So the input's unit must exactly match the parameter name of timedelta. So the code must check that the unit is exactly one of those strings. So the code must be case-sensitive here. But maybe the input is given in different cases, like "3 DAYS" would split into "3" and "DAYS", which is not in the valid_units. So perhaps the unit should be lowercased first?

Hmm, looking at the problem's example, maybe the function is case-sensitive. But let me see the problem's instructions again. The docstring says, "if the frequency is None or 'always', return None". So the 'always' check is done with .lower(), since it uses "frequency.lower() == 'always'". Wait, in the code I first wrote, for the first condition, it checks if frequency is None, or frequency.lower() == 'always', so that part is case-insensitive. But for the unit, the problem's example doesn't specify, but perhaps the unit must be in lowercase as the parameters. So maybe the user's input for the unit is case-sensitive, but in the problem's example, the unit is "timeunit" (singular). So in the real code, the user has to input "days" not "day". 

Alternatively, maybe the unit can be in singular form, and we can have a mapping. Like 'day' becomes 'days', 'hour' becomes 'hours', etc. But the problem's example shows that the unit is exactly used as the parameter. For instance, "3 timeunit" would map to timeunit=3. So if the user inputs "5 day", then since 'day' is not a valid parameter name for timedelta, the function should raise an error. 

Therefore, the code must check the unit exactly. So the input's unit part must be exactly one of the valid_units. So the code as written would do that. 

Now, possible edge cases:

- The input is "0 days" → that's allowed, but the timedelta would be zero. But the function just needs to parse, so that's okay.
- What if the unit is "seconds" but the input is "3 seconds"? That's valid. 

Another edge case: parts[0] is not a number. Like "three days" → split into ["three", "days"], then converting to int would fail. The except block would catch that.

So the code steps:

First, the import. Then, handle the None and "always" cases. Then split into two parts. Check length. Then check if the unit is in the list. 

Wait, but let's think about the split. Suppose the input has leading or trailing spaces, like " 5 days  " → split would still give two parts. So that's okay. 

Another case: "5days" with no space → split would give ["5days"] which is length 1, so that's invalid. 

So the code should be okay.

Wait, what about "5 days left" → that would split into 3 parts, so len(parts) !=2 → error. 

Yes. So that's covered. 

Now, putting the code together. Also, the function's return type is stated as str, but that's probably a mistake. The docstring says "@return str, the corresponding datetime", but the actual return is a timedelta instance. So that's a typo in the docstring. But I have to follow the given function signature and docstring. Wait the function's return is supposed to be a timedelta, but the docstring says returns a str. That's conflicting. Wait the user must have made a mistake here. Let me check again.

The function's docstring says: "return a corresponding datetime.timedelta instance". The @return says str. That's a discrepancy. But the function's actual return is a timedelta, so the @return in the docstring is probably wrong. But since the user provided the docstring, I should follow it? Or perhaps it's a mistake. Well, the problem says to generate code based on the function signature and docstring. The function signature says def parse_frequency(frequency): and the return is the corresponding timedelta. The docstring's @return says str, but that's likely an error. Since the example shows returning a timedelta, I'll proceed to return a timedelta. 

So the code is as follows. Also, when raising ValueError, need to have appropriate error messages. 

Wait in the code, after splitting, if the length is not two, the error message should say "Invalid frequency format". The example says to raise ValueError if can't be parsed, so that's covered. 

Testing some cases:

parse_frequency(None) → None.

parse_frequency("always") → None (since it's case-insensitive).

parse_frequency("3 days") → timedelta(days=3).

parse_frequency("5 Hours") → unit is "Hours" which is not in lowercase, so not in the list. So raises ValueError.

So the code would need to have the unit in lowercase? Because the valid_units are all lowercase. So perhaps we should process the unit to lowercase? 

Wait the problem's example uses "timeunit" as the unit, so if the input was "3 TimeUnit", then the code as written would check for "TimeUnit" in valid_units (which has 'timeunit' lowercase?), so no. 

Ah, the valid_units are in lowercase. So the unit from the input should be converted to lowercase, but then check against the valid_units. Because otherwise, if the input is "5 DAYS", then the unit is 'DAYS', which isn't in the list. 

So to make the unit check case-insensitive, maybe we should process it. Let me check the problem's instructions again. The example says "3 timeunit" returns the correct one. So the unit in the string must exactly match the parameter name. So the function's code should require that the unit is exactly as the parameter. But perhaps the user can input units in any case. 

Hmm, the problem's docstring doesn't specify, so maybe the function is case-sensitive. For example, if the user writes "3 DAYS", the code would raise an error. But maybe it's better to make it case-insensitive. The problem's first condition uses .lower() for "always", so maybe the unit should also be converted to lowercase. Let me think. 

The example uses "timeunit" as a parameter, so perhaps the unit in the string must exactly match the parameter's name. So in the code, the valid_units are the exact parameter names, so the unit must be in lowercase. So the code would need to process the unit to lowercase? Let me see:

Suppose the input is "5 Days". Then parts[1] is "Days". Since valid_units has 'days', that's not a match. So the code would raise an error. 

But maybe the user expects the function to be case-insensitive. The problem's first condition uses .lower() for "always", so perhaps the unit should also be checked in lowercase. 

Wait the problem's docstring says: "Given a frequency string with a number and a unit of time". So maybe the unit is case-insensitive. Let me adjust the code to process the unit to lowercase. 

Wait, but the parameter names for timedelta are in lowercase. So if the user enters "DAYS", converting to lowercase would make 'days' which is in the list. 

So perhaps the code should do:

unit = unit.strip().lower()

Wait, also, maybe the unit has leading or trailing spaces, but the split would take care of that. Because split() removes any leading/trailing whitespace. So parts[1] would be the unit without leading/trailing. 

Wait, but in the code, after splitting, the unit is parts[1], which is already stripped. So perhaps converting to lowercase is better here. 

So, modifying the code:

unit = parts[1].lower()

Then check if unit in valid_units. 

Wait the example given in the problem uses "timeunit", which in the code's valid_units would be 'days', etc. So if the input is "3 timeunit", then unit is 'timeunit', which would not be in the valid_units list. Wait that's a problem. Wait the example says that if given "3 timeunit", return a timedelta with timeunit=3. But in reality, the valid units are only the ones that timedelta actually has. So the example is hypothetical. Wait the problem says "For instance, given '3 timeunit', return datetime.timedelta(timeunit=3)". But that's just an example. The actual code must use the real units. So the function's real valid units are the ones that are parameters of timedelta. 

Therefore, the example is just an example, but the actual code must check for those real units. So the function is only valid when the unit is one of the actual parameter names. So the user must input the correct unit names, but perhaps in any case. So the code should process the unit to lowercase, then check if it's in the list. 

Wait, but the valid_units list has the parameter names in lowercase. So if the user inputs "Days", converting to lowercase gives 'days', which is in the list. 

So yes, the code should convert the unit to lowercase. 

Wait the problem's example uses "timeunit" as a unit, but in reality, the valid units are days, etc. So perhaps the example is illustrative. The actual function is to parse the given unit (case-insensitively) into one of the valid parameters. 

Therefore, the code should process the unit to lowercase. So adjust the code:

After unit = parts[1], then do unit = unit.lower(). 

Wait, let me restructure:

So the steps would be:

parts = frequency.split() → gives two elements, parts[0] is the number string, parts[1] is the unit string. 

Then unit = parts[1].lower()

valid_units are the list as before. 

Check if unit is in the list. 

Then create the kwargs with the unit (lowercase) as the key. 

Wait but the parameter names are in lowercase. So yes, that's correct. 

So, code:

from datetime import timedelta

def parse_frequency(frequency):
    if frequency is None or frequency.lower() == 'always':
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Invalid frequency format")
    number_str, unit = parts
    unit = unit.lower()
    try:
        number = int(number_str)
    except ValueError:
        raise ValueError("Number must be an integer")
    valid_units = ['days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks']
    if unit not in valid_units:
        raise ValueError(f"Invalid unit: {unit}")
    return timedelta(**{unit: number})

Wait, but in the problem's example, the unit is "timeunit", but in the code's valid_units list, there is no 'timeunit'. So that example is just a hypothetical. The actual code should use the real units. 

Therefore, this code should work. Let me see. 

Another test case: "5 Hours" → parts[1] is "Hours", lower becomes 'hours', which is in the list. So that would be okay. 

What about "5D days" → split into ["5D", "days"], but the number_str is "5D" which can't be converted to int. 

So the code would catch that. 

What if the number is a float? Like "3.5 days". The code would try to convert to int and fail. Because the problem's example uses 3 (integer) and the docstring says "number" but not specifying. The function's docstring says "number" but the example uses integer. So perhaps the number must be an integer. 

Yes, the problem's example uses "3 timeunit" and returns 3, so the function should require the number to be an integer. So converting to int is correct. 

So the code seems okay. 

Wait, but the problem says "raise ValueError if the given frequency cannot be parsed". So any case where the input is invalid in any way (split into wrong parts, non-integer number, invalid unit) should raise. 

Yes, the code does that. 

Wait, but in the code, when the unit is converted to lowercase, but the valid_units are in lowercase, so that works. 

Now, the code's return is a timedelta instance, which is correct. 

So I think that's the code. Now, to make sure to include the import statement. 

Wait in the problem's function signature, there is no import. But the code must use from datetime import timedelta, or import datetime and then datetime.timedelta. 

Looking at the example in the docstring: "return datetime.timedelta(timeunit=3)". So the code uses the fully qualified name, but in the code, I have to use timedelta with the import. 

So the code above with the from ... import is correct. 

Wait the user's function's return is a timedelta instance, so the code must import that. 

Therefore, the code should start with from datetime import timedelta. 

Putting it all together, the code would be as written. 

Wait I think that's it. Let me check again.

Wait the function's parameters are given as "frequency", which is a string. 

Yes, the code splits into two parts. 

The only possible mistake is not handling the unit case. 

Yes, so the code converts the unit to lowercase. 

Another possible mistake is if the input is "3 days", then the code returns timedelta(days=3), which is correct. 

Yes. 

So this should work. 

Now, I need to output the code in Python markdown format. So the user wants the code enclosed in triple backticks, like:

```python
... code here ...
```

So the final code with the import and the function.
