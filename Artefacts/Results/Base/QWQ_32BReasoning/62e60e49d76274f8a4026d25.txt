Okay, so I need to generate Python code for the unit_of_work decorator function based on the given signature and docstring. Let me start by understanding what the user is asking for here. The function unit_of_work should return a decorator, which itself can have metadata and timeout attributes. 

Hmm, decorators in Python can sometimes be a bit tricky. Since the function is supposed to take parameters (metadata and timeout), it should be a decorator factory. That means the structure will be something like: the outer function takes the parameters, and returns the actual decorator. The actual decorator would then take the function to be decorated and wrap it with the necessary functionality.

Wait, right. The standard pattern for a parameterized decorator is:

def decorator_factory(param):
    def decorator(func):
        ... setup using param ...
        def wrapper(*args, **kwargs):
            ... do something before ...
            result = func(*args, **kwargs)
            ... do something after ...
            return result
        return wrapper
    return decorator

So applying that here, the unit_of_work function will take metadata and timeout, then return the decorator that wraps the function. But the user also wants the returned decorator to have those attributes. Oh right, so the decorator (the function returned by the factory) should have .metadata and .timeout properties.

So first, the outer function unit_of_work takes the parameters. Then, the returned decorator (the inner function) needs to have those attributes set. Let me think how to do that. Maybe when we return the decorator, we can add the attributes to the wrapper function. Or perhaps the decorator function itself can have those attributes, but I think the attributes need to be on the returned decorator, which is the wrapper. 

Wait, the docstring says the decorator has the metadata and timeout attributes. So when someone uses @unit_of_work(...), the resulting decorated function should have those attributes. So the wrapper function, which is the decorated function, should have them. 

So the steps would be:

1. Define the unit_of_work function that accepts metadata and timeout. These can have default values of None and whatever is appropriate. The parameters are optional, so the user might call it with or without them. But since they're part of the function signature, the decorator should handle if they are provided.

2. The function returned by unit_of_work is the actual decorator. The decorator takes the function to be decorated (the func parameter in the example).

3. The wrapper inside the decorator will handle the function's execution, possibly adding before/after logic. But since the problem doesn't specify what the decorator does, just that it has those attributes, maybe the actual functionality isn't needed here? Wait, the user didn't mention any specific behavior, just that the decorator has those attributes. So perhaps the code is just setting the attributes on the wrapped function without any actual work?

Wait, the function's docstring says it returns a decorator with those attributes. So the decorator (the wrapper function) must have those attributes. So when someone uses this, like @unit_of_work(metadata='something', timeout=10), the wrapper function (the decorated function) should have .metadata and .timeout attributes set to those values.

So the code structure would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        # set the attributes on the wrapper
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

Wait, but in this structure, the outer function returns the decorator function. So when you call unit_of_work with parameters, it returns the decorator, which then takes the function and returns the wrapper. So the wrapper will have the attributes set. That should work. 

Alternatively, maybe the attributes should be on the decorator itself, but the doc says the decorator has them, which is the returned object from unit_of_work. Wait, the wording is a bit ambiguous. Let me read again: "Returns a decorator with metadata and timeout attributes." So the returned object (the decorator) must have those attributes. 

Wait, but in the code above, the decorator is the function 'decorator', which returns the wrapper. So the decorator (the function 'decorator') isn't the one that gets the attributes. The wrapper is. So perhaps I should set the attributes on the decorator, but that's not possible because the decorator is a function. Alternatively, maybe the attributes are on the wrapper, which becomes the decorated function. But the user wants the decorator to have those attributes, so maybe I'm misunderstanding. 

Wait, perhaps the decorator is the returned object, which in this case is the 'decorator' function. Wait no, the unit_of_work is a decorator factory. So when you call unit_of_work with parameters, it returns the decorator (the 'decorator' function). Then when you apply that to a function, it returns the wrapper. So the user probably wants the returned decorator (the 'decorator' function) to have the attributes. But how?

Alternatively, maybe the attributes are supposed to be on the resulting decorated function (the wrapper). Because the way the decorator is used, the function being decorated is wrapped, and the attributes would be there. The docstring says "a decorator with metadata and timeout attributes." The decorator here is the function returned by unit_of_work. So perhaps the decorator (the outer function) should have those attributes. Wait, but the decorator is the 'decorator' function, which is inside unit_of_work. 

Hmm, maybe I need to make the returned decorator (the 'decorator' function) have those attributes. But how? Or perhaps the wrapper function is the actual decorated function, so the user would access the attributes via the function they decorated. Like, if they have @unit_of_work(...) on a function f, then f.metadata would be accessible. So that's the case. 

Therefore, the correct approach is to set the metadata and timeout on the wrapper function. So the code as I initially thought is correct. 

Wait, but in Python, when you return the wrapper, you might want to preserve the original function's name and docstring. So maybe using functools.wraps? The user didn't mention that, but maybe it's better to include it. Although, the problem states to generate code based on the function signature and docstring, and not to include any explanations. Since the docstring only requires the decorator to have the attributes, perhaps the rest isn't necessary. 

Wait, the problem says "Generate Python code based on the following function signature and docstring." So the code must return a decorator (so the outer function returns the decorator), and the decorator must have the metadata and timeout attributes. 

Wait, perhaps the decorator is the wrapper? Or maybe the decorator is the function that is returned by the factory, but the actual attributes are on the wrapper. Let me think again. 

Suppose someone writes:

@unit_of_work(metadata='test', timeout=5)
def myfunc():
    pass

Then, the unit_of_work is called with those parameters, which returns the decorator (the 'decorator' function inside unit_of_work). The 'decorator' is then called with myfunc as the argument, returning the wrapper function. So the decorated function (myfunc) is replaced by the wrapper. 

Therefore, the wrapper is the function that will have the attributes. So when the user refers to the decorator (the object returned by unit_of_work), that's the 'decorator' function, which when called returns the wrapper. But the decorator itself (the 'decorator' function) might not have the attributes. Wait, but the doc says the decorator has those attributes. 

Alternatively, maybe the user wants the decorator (the function returned by the factory) to have the attributes. So in the example above, the 'decorator' function would have metadata and timeout. But then when you call it with the function, the returned wrapper would lose those attributes unless they are copied. 

Hmm, perhaps the correct approach is to set the attributes on the wrapper function, since that's the one that replaces the original function. So the user can access them via the decorated function. 

Wait the problem says "Returns a decorator with metadata and timeout attributes." So the returned object from unit_of_work is the decorator, and that decorator must have the attributes. The decorator is the 'decorator' function in the code. So the 'decorator' function (the one that takes the function to be decorated) should have the metadata and timeout attributes. But how to do that?

Ah right, in the code structure, the 'decorator' function is the one returned by the factory. So when the factory is called, it returns the decorator function, which has the metadata and timeout stored as its attributes. 

Wait, in the code I had before, the wrapper's attributes are set. But the decorator function (the one that takes 'func') would not have them. So to set the attributes on the decorator (the function returned by unit_of_work), perhaps I should set them on the 'decorator' function instead of the wrapper. But then when the decorator is called, it returns the wrapper, which would not have those attributes unless we transfer them. 

Alternatively, perhaps the user expects the decorator to be a class-based one, where the instance has those attributes. Like using a class as the decorator. Because then the instance can have the attributes. Let me think: 

Another way to write a decorator with parameters is to use a class with __call__.

So:

def unit_of_work(metadata=None, timeout=None):
    class UnitOfWorkDecorator:
        def __init__(self, func):
            self.func = func
            self.metadata = metadata
            self.timeout = timeout
        def __call__(self, *args, **kwargs):
            return self.func(*args, **kwargs)
    return UnitOfWorkDecorator

Wait, but in this case, when you use @unit_of_work(...), the UnitOfWorkDecorator instance is created, and when you call the decorated function, it calls __call__. The decorator (the UnitOfWorkDecorator class instance) has the metadata and timeout attributes. So the returned decorator (the UnitOfWorkDecorator class) would have those attributes. Wait, actually, the returned object from unit_of_work is the class, but the instance is created when the decorator is applied to the function. 

Hmm, maybe the initial approach with the wrapper is better, but I have to make sure the attributes are on the decorator. Wait, perhaps the user wants the decorator (the returned object from unit_of_work) to have the attributes. Let me clarify. 

The function signature is def unit_of_work(metadata=None, timeout=None), which returns a decorator. That decorator is the object that is then applied to the function. So that decorator must have the metadata and timeout as attributes. 

Wait, the decorator is the function returned by unit_of_work. So in the first approach, the outer function unit_of_work returns the 'decorator' function. So the 'decorator' function (the inner function) must have the attributes. 

Wait, in the first approach, the 'decorator' function is the one that is returned by unit_of_work. So to set the attributes on that function, I can do:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    # set the attributes on the decorator function
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but that's not correct because the decorator function's metadata and timeout would be set when unit_of_work is called. But the problem is that when the decorator is called (with the function), the returned wrapper would have those attributes. However, the user wants the decorator (the returned object from unit_of_work) to have those attributes. 

Wait, the user's docstring says "Returns a decorator with metadata and timeout attributes." So the returned object (the decorator) must have those attributes. The decorator is the function 'decorator' in my first code. So when I return 'decorator', I need to have its attributes set to the parameters passed into unit_of_work. 

Wait, but in the first code example, the decorator function (the outer 'decorator') has no attributes. So in order to set the attributes on the decorator, I can do that by assigning them in the unit_of_work function. Like:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.__wrapped__ = func  # maybe for functools
        return wrapper
    # add attributes to the decorator function
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but in this case, when the decorator is called (like when applying to a function), it returns the wrapper. The decorator function (the 'decorator' function) has the attributes, but when the user uses it, the actual decorated function is the wrapper. So if the user tries to access the attributes on the decorated function (the wrapper), they won't be there. But according to the problem, the decorator should have those attributes. Wait, perhaps the user made a mistake in the wording, but maybe the attributes are supposed to be on the decorated function. 

Alternatively, maybe the attributes should be on both the decorator and the wrapper? 

Hmm, I'm a bit confused. Let me read the problem again. 

The function signature is unit_of_work, which returns a decorator with metadata and timeout attributes. So the returned object (the decorator) must have those attributes. 

So the decorator (the function returned by unit_of_work) must have .metadata and .timeout. 

In the first approach, the 'decorator' function (the inner function) would have those attributes. So yes, in that code, when you return the decorator function, you can set its attributes. 

Wait, in the first code, the 'decorator' function is defined inside unit_of_work. Then, after defining it, I can set its metadata and timeout attributes to the parameters passed. That way, the returned decorator (the function) has those attributes. 

But when the decorator is called (with the function), it returns the wrapper. The wrapper doesn't have those attributes unless we set them there as well. But the problem only requires the decorator to have them, not necessarily the wrapped function. 

Wait, the problem says "a decorator with metadata and timeout attributes". So the returned object from unit_of_work is the decorator, which is the function 'decorator' in my code. So that's the one that must have the attributes. 

Therefore, the code should set the attributes on the 'decorator' function. 

Wait, but in the code above, when I do decorator.metadata = metadata, that's correct because when unit_of_work is called, it returns the 'decorator' function which now has those attributes. 

Wait, but in that case, when someone uses the decorator, like:

@unit_of_work('m', 10)
def myfunc():
    pass

Then, the returned decorator is the 'decorator' function. So the user could do something like:

d = unit_of_work('m', 10)
print(d.metadata)  # 'm'

But when they decorate myfunc, the actual function returned is the wrapper, which doesn't have the attributes unless they are copied over. 

Wait, but the original question says the decorator (the returned object from unit_of_work) must have the attributes. So the code as I wrote earlier would work for that. Because the 'decorator' function has the attributes set. 

However, in typical usage, the decorated function (the wrapper) is the one that replaces the original function. So if the user expects the decorated function to have the attributes, then the code needs to set them on the wrapper. 

The problem's wording is a bit ambiguous. Let me check the exact wording again. 

The docstring says: "Returns a decorator with metadata and timeout attributes." So the returned object (the decorator) must have those attributes. The decorator is the function returned by unit_of_work. So in the code, the 'decorator' function (the inner function) must have those attributes. 

So the code would be as follows. 

Wait, but in the first approach, when I set the attributes on the wrapper, the decorator function (the 'decorator' function) doesn't have them. So to set them on the decorator function, I need to set them there. 

Wait, the 'decorator' function is the one that is returned by unit_of_work. So when you call unit_of_work, you get the 'decorator' function. That function has to have the metadata and timeout attributes. 

So in the code, after defining the 'decorator' function inside unit_of_work, we can assign the parameters to its attributes. 

Yes, that makes sense. 

Therefore, the correct code would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but in that case, both the 'decorator' function and the wrapper have the attributes. 

Wait, but when you return the 'decorator' function as the decorator, then the user could check the attributes on that decorator. But when they apply it to a function, the 'decorator' is called, which returns the wrapper. So the wrapper is the actual function that's being used, so maybe the user expects the attributes to be on that. 

Hmm, perhaps the problem's intention is that the decorator (the object returned by unit_of_work) has those attributes, so when you do:

d = unit_of_work(meta, timeout)
print(d.metadata)

It would work. But in the code above, that's true because the 'decorator' function has those attributes. However, when you use the decorator syntax, the 'decorator' is called with the function, and the returned object is the wrapper. So the wrapper may or may not have those attributes. 

Wait the problem says the decorator has those attributes. So the returned object from unit_of_work must have them, which is the 'decorator' function. 

Therefore, the code is correct as written. 

Alternatively, perhaps the user wants the decorated function (the wrapper) to have the attributes, which would require setting them on the wrapper. 

Wait the wording is ambiguous. Let me think again. 

The function's docstring says: "Returns a decorator with metadata and timeout attributes." 

The decorator is the object returned by unit_of_work. So that object must have the attributes. 

In the code I had earlier, when I set the attributes on the 'decorator' function, then yes. 

Wait, but in Python, functions are first-class objects, so we can add attributes to them. 

So when someone does:

@unit_of_work('mydata', 30)
def myfunc():
    pass

Then, the 'decorator' function (the one returned by unit_of_work) has the metadata and timeout. But when you call @decorator, you get the wrapper. So if the user wants the attributes on the wrapper, then the code should set them there. But according to the problem statement, the decorator (the returned object) must have them. 

Hmm, perhaps the problem is expecting the wrapper to be the decorator, but that's not standard. Because the usual structure is that the outer function is the decorator factory, and the inner function (decorator) is the actual decorator, which is called with the function. 

Alternatively, maybe the problem wants the decorator to be a class instance, so that the attributes are stored there. Let me try that approach again. 

Using a class-based decorator:

def unit_of_work(metadata=None, timeout=None):
    class Decorator:
        def __init__(self, func):
            self.func = func
            self.metadata = metadata
            self.timeout = timeout
        def __call__(self, *args, **kwargs):
            return self.func(*args, **kwargs)
    return Decorator

Wait, but in this case, when you call unit_of_work with parameters, it returns the Decorator class. Then, when you apply it to a function, the class is instantiated with the function as the __init__ argument. The instance of Decorator would have the metadata and timeout. 

So the returned decorator (the Decorator class) doesn't have the attributes, but its instances do. But the problem says the decorator (the returned object) should have the attributes. 

Hmm, so maybe the first approach is better. Let me think again. 

Wait, perhaps the correct way is to have the decorator function (the one returned by unit_of_work) have the attributes, and when it wraps the function, it returns the wrapper with those attributes. 

So in the code:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        # set attributes on the wrapper
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    # set the attributes on the decorator function itself
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but in this case, when you call the decorator (the function 'decorator') with a function, it returns the wrapper. The decorator function (the one returned by unit_of_work) has the metadata and timeout attributes, but the wrapper function also has them. 

So if the user wants the decorator (the returned object) to have the attributes, then this code works. 

Alternatively, perhaps the problem expects that the wrapper function is the one that's the decorated function, and the attributes are on that. 

But according to the problem's wording, the decorator (the returned object) should have the attributes. 

Therefore, the code should set the attributes on the 'decorator' function. 

Wait, but in the code above, when you return the 'decorator' function, it has the attributes. So for example, if I do:

d = unit_of_work('test', 10)
print(d.metadata)  # would output 'test'

Yes, that's correct. 

However, when the decorator is applied to a function, like:

@unit_of_work('test', 10)
def myfunc():
    pass

Then, the 'decorator' is called with myfunc, which returns the wrapper. The wrapper function does not have the attributes unless they are set there. 

But the problem says the decorator (the returned object from unit_of_work) has the attributes, not necessarily the wrapped function. 

Therefore, the code as written would satisfy the problem's requirements. 

Alternatively, maybe the user expects the wrapper to have those attributes, so that the decorated function can access them. 

The problem's exact wording is a bit unclear. Let me re-read the problem statement. 

The function signature is given as def unit_of_work(metadata=None, timeout=None): and the docstring says it returns a decorator with those attributes. 

Therefore, the returned decorator must have the attributes. The way to do that is by setting them on the 'decorator' function. 

So the code I wrote earlier is correct. 

Wait, but in the code:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Yes, that way, the 'decorator' function (the inner function) has the attributes. 

Wait, but the 'decorator' function is the function that takes the function to be decorated. When you call unit_of_work, you get that 'decorator' function, which has the attributes. 

So for example, if someone does:

dec = unit_of_work('data', 5)
print(dec.metadata)  # this would work and return 'data'

Which is exactly what the problem requires. 

Therefore, this code should be correct. 

Another thing to consider is that the wrapper function might need to preserve the original function's name and docstring. So perhaps using functools.wraps. 

The problem didn't mention anything about that, but maybe it's better to include. 

So modifying the code to include that:

import functools

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but the problem says not to include any explanations or formatting. So the code needs to be as per the requirements. 

Wait, but the user's problem says to generate code based on the function signature and docstring. The function's docstring only mentions returning a decorator with the attributes. So adding the functools.wraps is optional. 

However, in the initial code, the wrapper function's __name__ would be 'wrapper', which is not ideal. But since the problem doesn't require that, maybe it's okay. 

So the code as written first is correct. 

Wait, but in the first code example, the 'decorator' function's metadata and timeout are set. So the returned decorator (the function) has those attributes. 

Yes, that's the case. 

Therefore, the code should look like that. 

Wait, but I need to make sure that the parameters can be optional. The function signature allows them to be None. 

So the code should handle that. Since in the code, when unit_of_work is called with no parameters, metadata and timeout are None, which is okay. 

Another point: the parameters are named metadata and timeout. So in the code, the inner functions must have those exact names as attributes. 

Yes. 

Therefore, the code is correct. 

Wait, but I think in the first approach, the 'decorator' function (the one returned by unit_of_work) has the attributes. Let me test this in my mind. 

Suppose I have:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Then, when I call unit_of_work with some arguments, the returned decorator (the 'decorator' function) has those attributes. 

So:

d = unit_of_work('test', 10)
print(d.metadata)  # 'test', yes. 

Then, when you apply it to a function:

@unit_of_work('test', 10)
def myfunc():
    pass

Then, the decorator is called (d is the decorator), which returns the wrapper. The wrapper has its own metadata and timeout set. 

But the problem's requirement is that the decorator (the returned object from unit_of_work) has those attributes. So that's correct. 

Therefore, the code should be as written. 

Wait, but in the code above, the wrapper also has the attributes. That's okay, but the problem only requires the decorator to have them. 

Alternatively, maybe the user wants the attributes to be on the decorated function. But the problem's wording specifies the decorator. 

Therefore, the code should be correct. 

Wait, but perhaps the problem's intended use is that the decorator (the returned object) is a class instance, so that the attributes can be stored there. Let me try another approach. 

Alternatively, perhaps using a closure. 

Wait, the first approach is correct. Let me just write the code as I thought. 

Wait, but I need to make sure that when the decorator is returned, it has the attributes. 

Yes, in the code I have, the 'decorator' function inside unit_of_work has the attributes. 

Wait, but when you return the 'decorator' function, which is a nested function inside unit_of_work, and then set its attributes, that should work. 

Wait, in Python, you can add attributes to any function. 

Therefore, the code is okay. 

I think that's the correct approach. 

Now, I need to write the code exactly as per the problem's instruction. 

The user's function signature starts with def unit_of_work(metadata=None, timeout=None): and the docstring. 

So the code would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but perhaps the user expects the decorator to be a function that can have the attributes. 

Yes, that's exactly what this code does. 

Alternatively, maybe the user expects the decorator to have the attributes, and the wrapper function also? 

Well, the problem only mentions the decorator, so the code above meets the requirement. 

Wait, but when the decorator is called (the 'decorator' function), it returns the wrapper. The wrapper function also has the attributes, but that's an added benefit. 

But the problem's requirement is just that the decorator has the attributes. 

So this code should work. 

Another thing: the parameters in the function are metadata and timeout, which are optional. The code correctly assigns them. 

Therefore, the code is as above. 

Wait, but I can also think of using a different approach where the wrapper's attributes are set via the outer parameters. 

Wait, in the code above, the wrapper's metadata and timeout are set inside the decorator function, which has access to the outer parameters. 

Yes, so that's correct. 

Therefore, the final code is as written. 

Wait, but the user's problem says "output only the code generated in python markdown format". Wait, the markdown format? Or just the code in a code block? 

The user might mean to present the code within triple backticks or something. But the instruction says to output only the code generated in Python markdown format. Maybe that means putting the code inside a markdown code block, like:

```python
def unit_of_work(...):
    ...
```

But the user also said not to include any markdown formatting. Wait, the exact instruction says: "Output ONLY the code generated, in python markdown format." Hmm, maybe that's a typo? Or perhaps they want the code as is, without any markdown. 

Wait, the first part says "Generate Python code based on the following function signature and docstring. Do NOT include any explanation, reasoning, or markdown formatting. Output ONLY the code generated, in python markdown format." 

Wait, perhaps they mean to output the code in a code block with ```python, but as code. 

Wait, maybe the user wants the code to be enclosed in a markdown code block. 

But the problem says "Output ONLY the code generated, in python markdown format." So the code should be presented as if in a markdown code block, but without any extra text. 

Therefore, the code should be written with triple backticks and 'python' after that. 

Wait, but the code is inside the function's definition. So the code would start with:

```python
def unit_of_work(metadata=None, timeout=None):
    ...
```

But the user wants the code generated, so the code from the function onwards. 

Wait, perhaps the user wants the code as is, but enclosed in a code block. 

Alternatively, maybe they are referring to the code in Python syntax, not as markdown. But I'm not sure. 

The instruction says "Output ONLY the code generated, in python markdown format." Maybe they want the code in a code block, but just the code itself. 

Wait, perhaps the user just wants the code as Python code, not in markdown. Because markdown format for code would be with the backticks. 

But the problem says to generate the code based on the given signature and docstring. 

So perhaps the correct answer is the code I wrote earlier, without the markdown. 

Wait, maybe I misunderstood the "markdown format" part. Let me check again. 

The user's instruction says:

"Generate Python code based on the following function signature and docstring. 
Do NOT include any explanation, reasoning, or markdown formatting. 
Output ONLY the code generated, in python markdown format. /think"

Hmm, that's conflicting. The first part says not to include any markdown formatting, but the second says to output in Python markdown format. 

Maybe the user made a mistake and meant to say to output the code in a code block (with triple backticks), but without any explanations. 

In that case, the code should be enclosed in ```python ... ```.

Wait, but the problem's own example shows the function signature and docstring. So the code to be generated is the implementation of the unit_of_work function. 

Therefore, the code should start with def unit_of_work(...), and the rest. 

So the code would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Wait, but maybe I can write it more concisely. 

Alternatively, perhaps the code can be written using a closure for the decorator, and setting the attributes on the wrapper. 

Wait, the problem might expect that the attributes are on the wrapper, because the decorator is the returned object from unit_of_work, which is the function 'decorator', but when you apply it to a function, the returned object is the wrapper. 

Wait, but the problem says the decorator (the returned object from unit_of_work) must have the attributes. 

So the 'decorator' function (the inner function inside unit_of_work) must have those attributes. 

So the code is correct as written. 

Another thought: perhaps the user wants the attributes to be accessible on the decorator, but when the decorator is called, the wrapper is returned, and the wrapper also has those attributes. 

In the code above, both the 'decorator' and the 'wrapper' have the attributes. 

Wait, but in the code, the 'decorator' is a function that takes 'func' as an argument. So when you call unit_of_work, you get the 'decorator' function. 

The 'decorator' has its own metadata and timeout attributes. 

When you call it with a function (as in the decorator syntax), the 'decorator' function creates a wrapper and sets the attributes there. 

Therefore, the wrapper also has the attributes, but that's okay. 

The problem only requires the decorator to have them, so the code meets that. 

Alternatively, maybe the user expects the attributes to be on the wrapper. 

But given the problem's wording, I think the first approach is correct. 

Therefore, the code is as written. 

Wait, but in the code, the 'decorator' function's attributes are set to the parameters. 

Yes. 

I think that's the solution here. 

Now, I should write that code without any extra text. 

Wait, the user also mentioned the timeout parameter. Are there any other parameters? No, the function's parameters are metadata and timeout, both optional. 

So the code is correct. 

Wait, but maybe the user wants the decorator to have the parameters stored, so that when you call unit_of_work with some parameters, the returned decorator has those attributes. 

Yes, that's exactly what the code does. 

Therefore, the code is correct. 

I'll proceed to write that code in the required format.
