Okay, I need to write a Python function called subclasses that returns all the subclasses of a given class, recursively. Hmm, let's think. So the function takes a class 'cls' as an argument and should find all its subclasses, including those of its subclasses.

Wait, how do I get the subclasses of a class in Python? Oh right, every class has a __subclasses__() method which returns its direct subclasses. But to get all of them recursively, I guess I need to do a depth-first or breadth-first search here.

Let me see. The function should collect all subclasses, so for each direct subclass, I add it to a list and then also check its own subclasses. That sounds like a recursive approach. So I can start with an empty list, then iterate over each subclass in cls.__subclasses__(), add them to the list, and then call the same function on each of those subclasses to get their subclasses too. But I have to make sure I don't end up in an infinite loop or miss some classes.

Wait, but there might be a problem with caching or the order here. Also, maybe some classes don't have any subclasses, so their __subclasses__() returns an empty list. I should start by initializing a list to hold all the subclasses. Let me outline the steps:

1. Initialize a list to store the subclasses.
2. For each direct subclass in cls.__subclasses__(), add it to the list.
3. Then, recursively get the subclasses of each of those direct subclasses and add them to the list as well.
4. Return the accumulated list.

Wait, but how do I handle the recursion properly? Let's think of an example. Suppose the given class has two direct subclasses, A and B. A has a subclass C, which has a subclass D. B has a subclass E. The function should return [A, B, C, D, E].

So, the base case is when a class has no subclasses. The recursive step would be to process each direct subclass and then their subclasses. So the function could be written with a loop over the direct subclasses, adding each to the result, then extending the result with the recursive call on each of those.

Wait, but I have to avoid duplicates. Because if a subclass is a subclass of multiple classes, maybe it could be included more than once. But in this case, the function is supposed to return all subclasses, so as long as each is added once, that's okay. The __subclasses__() method probably returns unique instances, but the recursion might traverse different paths leading to the same class. So I need to track the classes I've already visited to prevent duplicates.

Oh right! Otherwise, if there's a hierarchy with multiple paths, like a diamond structure, the same subclass might be added multiple times. So I need to use a set to keep track of the classes that have been processed already. Wait, but how to implement that here. Because the function is supposed to return a list, maybe using a list and checking before adding?

Alternatively, maybe the recursion can be handled in a way that each subclass is only added once. Let me think again. Let's see, the function is supposed to return all subclasses recursively. So the approach is:

Start with the direct subclasses. For each of those, add them to the list, then get their subclasses and add those as well. So the list is built by traversing all subclasses in a depth-first manner, perhaps.

Wait, but the order might not matter here. The problem statement doesn't specify the order, so any order is acceptable.

Now, to prevent duplicates, maybe we should use a set. Because when you have a subclass that is a subclass of multiple classes, adding it multiple times through different branches would result in duplicates. So, perhaps the function should first collect all subclasses in a set, then convert to a list.

Wait, but how would that work? Let me try to outline the code structure.

The function subclasses(cls) would need to collect all subclasses. Let's start with the direct ones. So:

def subclasses(cls):
    sub = []
    for s in cls.__subclasses__():
        sub.append(s)
        sub.extend(subclasses(s))
    return sub

Wait, that's a possible approach. But this might have duplicates? Let's see. Suppose a class has two subclasses, and one of them is a subclass of another. Wait, no, because each subclass is only added once. Let me see an example. Suppose class X has Y as a direct subclass. Y has Z as a subclass. Then when we call subclasses(X), first Y is added. Then, for Y's __subclasses__(), we add Z. Then, for Z's __subclasses__(), nothing. So the list would be [Y, Z], which is correct.

Another case where a class has multiple parent paths. Like if class Z is a subclass of both Y and W, and Y and W are both subclasses of X. Then when starting from X, the first pass would add Y and W. Then when processing Y's subclasses, Z is added. Then when processing W's subclasses, Z is also added. So the list would have Y, W, Z, Z. That's a duplicate. So that's a problem.

Ah right, so this code would have duplicates in such a scenario. So how can I avoid that?

Hmm, maybe I should track the classes I've already added. So perhaps we need to keep a set of classes that have been processed, or a list and check before adding.

Wait, the problem is that Z could be a subclass of Y and also of W, which are both under X. So when we process Y's subclasses, Z is added. Then when processing W's subclasses, Z is again found and added again. So the list would include Z twice.

Therefore, to prevent duplicates, I need to make sure each subclass is only added once. So maybe we need a set to collect all the subclasses.

But then, since the order might be arbitrary, perhaps the function should return a list but ensure uniqueness. So here's the plan: use a list, but before adding a subclass, check if it's already in the list. Alternatively, use a set and then convert to a list. But __subclasses__() returns a list, so maybe the set approach is better.

Wait, but in the recursive approach, each call to subclasses(s) will return all the subclasses of s, which might include some already in the list. So the initial approach would have duplicates because the same subclass is added through different paths.

So, perhaps the correct approach is to use a set to collect all subclasses, and then return the list version. Let me think of modifying the code to use a set.

But how to do that. Let me try:

def subclasses(cls):
    subs = set()
    def _subclasses(cls):
        for s in cls.__subclasses__():
            if s not in subs:
                subs.add(s)
                _subclasses(s)
    _subclasses(cls)
    return list(subs)

Wait, but this is using a helper function and a closure. The problem is that the set 'subs' is initialized once, and the helper function adds to it. But the initial function's first call to __subclasses__() will add Y and W to subs, then when processing Y, it adds Z. When processing W, since Z is not in subs (no, wait, in the first loop, Y's subclasses are Z, so Z is added. Then when processing W, which also has Z as a subclass, the helper would check if Z is in subs, which it is, so it skips adding again. So that would work?

Wait, let me see. Let's walk through the example again. Suppose X has Y and W as direct subclasses, and both Y and W have Z as a subclass. So when we call _subclasses(X):

Loop over Y and W. For Y, add to subs (so Y is in the set). Then call _subclasses(Y). Y's __subclasses__ is Z. So check if Z is in subs. Since it's not, add it, then call _subclasses(Z). Z's __subclasses__ may be empty, so nothing. Then back to the loop for W. Adding W to subs (since it's not there yet). Then call _subclasses(W). W's __subclasses__ includes Z again. But Z is already in the set, so it doesn't add again. So the set will have Y, W, Z. So the final list is correct. That's better.

Alternatively, using the initial approach but with a set inside the function. Wait, but in the initial approach, the list would accumulate all the subclasses each time, but duplicates would occur. So the helper function with a set is better. But how to handle the set across recursive calls?

Wait, in the code above, the _subclasses function is inside the main function. The 'subs' variable is a set that's created each time the main function is called. So that should work. But maybe the initial function is not using the helper correctly. Let me see:

Wait, in the code I wrote above, the _subclasses function loops through the direct subclasses, checks if they are in the set. But the first call is to _subclasses(cls), which is X. So for each s in X's __subclasses__(), which are Y and W. Then, if they are not in the set, add them and recurse.

Wait, but the problem is that the helper function is called with cls as the parameter, but the first call is to _subclasses(cls). Wait, in the code, the helper is called with the original class. Wait, perhaps the helper function should be called with the current class, but the 'subs' set is initialized in the outer function. Wait, maybe the code should be:

def subclasses(cls):
    subs = set()
    work = [cls]
    while work:
        current = work.pop()
        for s in current.__subclasses__():
            if s not in subs:
                subs.add(s)
                work.append(s)
    return list(subs)

Wait, that's a BFS approach. Alternatively, maybe a recursive approach can be done, but the problem is that the helper function needs to have access to the same 'subs' set.

Wait, let me think again. The first approach I had was using a list and recursion, but that can lead to duplicates. The second approach uses a set and a helper function. But in the code above, the helper function is defined inside subclasses, so the set is correctly captured.

Wait, let me test this code in my mind. Suppose X has Y and W. Y has Z, and W also has Z.

The main function's first call would set subs as empty. Then work is initialized as [X]. Then current is X. The loop over its subclasses (Y and W). For Y: not in subs, so add it, and append to work. Then W: not in subs, add to subs and append to work. The work is now [W, Y]. Next iteration, pop Y (or W first?), depending on LIFO. Let's say pop Y next. Then current is Y. Its subclasses are Z. Z is not in subs, so add it and append to work. Then work is [W, Z]. Then pop W. Its subclasses include Z, but Z is already in subs. So nothing added. Then Z is popped. Its __subclasses__() is empty, so nothing. So the set is {Y, W, Z}, so the list is correct.

That seems okay. But the first approach with the recursive helper would do the same. Let me see:

def subclasses(cls):
    subs = set()
    def _collect(subclass):
        for s in subclass.__subclasses__():
            if s not in subs:
                subs.add(s)
                _collect(s)
    _collect(cls)
    return list(subs)

Wait, no. Because the _collect function is called with the original class, but then for each of its subclasses, add them and recurse. That would collect all subclasses in the hierarchy under cls. But the problem is that the original class's own subclasses are being added. Wait, but in the first approach, the helper function is called with cls, but the code loops through the subclasses of cls, adding them. Then, for each of those, it calls _collect again, which adds their subclasses. So the code should work. Let me see in the example:

When the main function is called with X, the _collect is called with X. Then, for each s in X's subclasses (Y and W). Y is not in subs, so add to subs, then call _collect(Y). In _collect(Y), look at Y's subclasses (Z). Add Z to subs and call _collect(Z). Then, back to the loop for Y, done. Then back to the first loop (for X's subclasses), next is W. Check if W is in subs (it was added when Y was processed? Wait no, because when we first added Y, that's part of the subs set. Wait, but the code for _collect adds the subclass to subs. Wait, no, in the code above, the _collect function loops through the __subclasses__ of the subclass (the parameter). So when _collect is called with X, it loops through X's subclasses (Y and W). For Y, check if it's in subs. Initially, subs is empty. So Y is not in subs, so we add it to subs. Then call _collect(Y), which looks at Y's subclasses (Z). Z is not in subs, so add it, then call _collect(Z). Z's subclasses are none, so nothing. Then back to processing W. Since W is not in subs (the subs set has Y and Z at this point?), wait, no. Wait, when we process X's subclasses, the first s is Y. So Y is not in subs (empty), so we add it to subs. Then we process W. W is also not in subs (since subs only has Y now), so add W to subs and then call _collect(W). In that call, W's subclasses include Z. So Z is checked again. Since Z is not in subs yet (only Y and W are there), so when W's loop processes Z, it's added to subs. So in the end, subs has Y, W, Z. So that works. Wait, but in the code, when the _collect function is called with X, it's adding the direct subclasses (Y and W) to the set, but the loop is over s in X's __subclasses__(). Each s is added to subs, but the parameter to _collect is the current subclass, and their own subclasses are then processed.

Wait, perhaps the code I thought of first (the recursive one with a set) would work. Let me try to write it again.

Alternatively, perhaps the first approach (without the set) would have duplicates because in the example, when processing W's subclasses, Z is already in the list from Y's processing, but in the initial approach, the list would have Z added again. So using a list without checking would lead to duplicates. Therefore, the set approach is better.

Hmm, but how to implement the recursive version with a set. Let me think. The code I had earlier with the helper function:

def subclasses(cls):
    subs = set()
    work = [cls]
    while work:
        current = work.pop()
        for s in current.__subclasses__():
            if s not in subs:
                subs.add(s)
                work.append(s)
    return list(subs)

Wait, this uses a list as a stack (since we pop from the end, it's a DFS). Alternatively, using a queue (pop from front) would be BFS, but either way, the order doesn't matter as long as all are included once.

Wait, but in the code above, the 'work' list is used to keep track of which classes to process next. Starting with the original class, then popping it, and adding its direct subclasses to work. Each time, we process the current class's subclasses, adding them to the 'subs' set if they're not already there. So this should work.

Wait, but when you start with the original class, you process its subclasses first. Then each of those is added to work, and their own subclasses are processed. So the set will collect all the subclasses correctly, without duplicates.

Yes, this should work. So the code would look like that. Alternatively, using a recursive approach:

def subclasses(cls):
    subs = set()
    def _collect(current):
        for s in current.__subclasses__():
            if s not in subs:
                subs.add(s)
                _collect(s)
    _collect(cls)
    return list(subs)

Wait, but in this case, the initial call to _collect(cls) would process the direct subclasses. Wait, let me see: the first call is with cls as the parameter to _collect. Then, for each s in cls's __subclasses__(), add them to subs, then call _collect(s). So that's the same as the loop in the helper function. So that should work as well, but with recursion. But recursion depth could be a problem for very deep class hierarchies. But in practice, class hierarchies aren't that deep, so maybe it's okay.

Wait, but in the first code example with the loop, the work starts as [cls], and then you pop and process each of their subclasses. The recursive approach is similar but uses the call stack. So either way, the set is correctly built.

Wait, but in the first code (the recursive one), when you call _collect(cls), the first step is to look at the direct subclasses of cls. Each of those is added to the set, then their own subclasses are processed recursively. So that's the same as the loop approach. So the code would work.

But which is better? The loop approach is iterative and avoids recursion depth issues, but the problem is to write code based on the function's signature and docstring. The docstring says "Return all subclasses of a class, recursively". So maybe the recursive approach is preferred here. Wait, but the first approach using the helper function with recursion uses a closure variable 'subs' which is a set, and that's okay.

Wait, but in the first approach (the one with the for loop and extend), the problem with duplicates arises. So using the set-based approach is better.

Wait, let me think again. The first code idea was:

def subclasses(cls):
    sub = []
    for s in cls.__subclasses__():
        sub.append(s)
        sub.extend(subclasses(s))
    return sub

This code would have duplicates. Let's test the example again. Let's say X has Y and W. Y has Z. W also has Z. Then when we call subclasses(X):

The first loop runs over Y and W. For Y, we append Y to sub, then call subclasses(Y). That function will loop over Y's subclasses (Z). So Z is added. Then, when processing W, we append W to sub, then call subclasses(W). That function loops over W's subclasses (Z). Then in the W's case, when we call subclasses(Z), it has no subclasses. So the sub list for X would be [Y, W, Z, Z], so duplicates. Therefore, the set approach is necessary.

So the correct code should use a set to collect all subclasses, ensuring each is added once. So the code with the set is better. The function can be written either with a loop or recursion, but the loop approach is more straightforward.

Alternatively, perhaps there's a more Pythonic way. Let me see the standard way to do this. Maybe using a generator and recursion, but tracking the visited classes.

Wait, here's another approach: using a set that's built by recursively collecting all subclasses. The function could be written as:

def subclasses(cls):
    sub_classes = set()
    for s in cls.__subclasses__():
        sub_classes.add(s)
        sub_classes.update(subclasses(s))
    return list(sub_classes)

Wait, this is a recursive approach but with a set. Let me see: each call to subclasses(cls) returns the set of all subclasses of cls. Wait, but the function is supposed to return all subclasses of the original cls, not of the current one. Wait, no, in this case, the function is called for each subclass. Let's walk through the example again.

Original call: subclasses(X). The loop runs over Y and W. For Y, add to sub_classes. Then call subclasses(Y) which returns Y's subclasses (Z). So sub_classes.update(subclasses(Y)) adds Z. Then for W, add to sub_classes (so now Y and W are there). Then call subclasses(W), which loops over W's subclasses (Z). The sub_classes for W would be {Z}, so adding that to X's sub_classes via update would add Z again, but since it's a set, it's already there. So the total sub_classes would be {Y, W, Z}.

Wait, that's right. Because in the recursive call, the function returns the set of subclasses of the current s (Y or W), and then we add those to the parent's set. But since the set is a collection, duplicates are automatically handled. Let me see step by step:

First, in the call to subclasses(X):

sub_classes starts as empty.

Loop over Y and W.

First s is Y. Add Y to sub_classes (now {Y}).

Then call subclasses(Y), which returns Y's subclasses (Z's set). So sub_classes.update adds Z, now {Y, Z}.

Then next s is W. Add W to sub_classes (now {Y, Z, W}).

Call subclasses(W), which loops over its __subclasses__(). Let's say Z is there.

In the call to subclasses(W), the loop starts with s in W's subclasses (Z). So add Z to W's sub_classes (which is a new set here). Then, the code for W's subclasses would call subclasses(Z), which has no subclasses, so returns empty set. So the W's sub_classes is {Z}, so when we do sub_classes.update({Z}), but Z is already in X's sub_classes, so no duplication.

So the final sub_classes for X is {Y, W, Z}, so converting to list gives all three.

Yes, that seems to work. So this code would handle duplicates automatically because sets don't allow them. So each time, the subclasses of each s are added to the set, but duplicates are ignored.

So the code would be:

def subclasses(cls):
    """
    Return all subclasses of a class, recursively
    """
    sub_classes = set()
    for s in cls.__subclasses__():
        sub_classes.add(s)
        sub_classes.update(subclasses(s))
    return list(sub_classes)

Wait, but let me check if that's correct. Let's take another example where a subclass is further down the hierarchy. Suppose X has Y, Y has Z, Z has A. Then:

Calling subclasses(X):

Loop over Y. Add to sub_classes. Then call subclasses(Y) which loops over Z. Add Z to sub_classes. Then call subclasses(Z), which loops over A. Add A to sub_classes. Then call subclasses(A), which has nothing. So the sub_classes for X would be {Y, Z, A}. The function returns that as a list. So that's correct.

Another case: a subclass that is a subclass of multiple parents. Like Z is a subclass of both Y and W, which are both subclasses of X. The first approach would correctly collect them without duplicates.

Yes, this approach seems correct. The base case is when a class has no subclasses, so the function returns an empty set. For each direct subclass, we add it to the set, then recursively add all of its subclasses. Since the set is being updated each time, duplicates are avoided.

Wait, but in this code, each call to subclasses(s) returns the set of s's subclasses, including their own subclasses. So when we do sub_classes.update(subclasses(s)), it's adding all of those, which is correct.

So this should work. Let me think of possible edge cases. What if the class has no subclasses? Then the function returns an empty list, which is correct. What about if a class has a subclass that's a metaclass or something? Probably okay, since __subclasses__() returns all direct subclasses regardless.

Hmm, maybe this is the correct solution. Let me see if that's the case. Let me check the standard approach. Oh, right, sometimes people use a list and have to check if they have been added before, but using a set is better here.

Alternatively, maybe the code can be written as:

def subclasses(cls):
    subs = cls.__subclasses__()
    return subs + [g for s in subs for g in subclasses(s)]

But this would have duplicates. Because if a subclass is in multiple branches, it would be added multiple times. So converting to a set first would help. Wait, but the initial approach using the set is better.

So the code with the set is the way to go. So the function starts with an empty set. Then, for each direct subclass s, it adds s to the set and then gets all of s's subclasses (recursively) and adds those to the set. Finally, return the list of the set elements.

Wait, but in the code I wrote earlier, the function is written as:

def subclasses(cls):
    sub_classes = set()
    for s in cls.__subclasses__():
        sub_classes.add(s)
        sub_classes.update(subclasses(s))
    return list(sub_classes)

Yes, that should work. Let me see if that's the case. Let me try with a simple example. Suppose there's a base class A with a subclass B, and B has a subclass C. Then:

subclasses(A) would first add B to the set. Then call subclasses(B), which adds C and then calls subclasses(C). Since C has no subclasses, it returns an empty list. So the sub_classes for A would be {B, C}, converted to list.

So that's correct. So this code should work. I think this is the right approach. The key is using a set to collect all the subclasses so that duplicates are not included. The recursion handles going through each subclass's hierarchy.

Therefore, the code should be written as above. Let me make sure that the __subclasses__() method is called correctly. Because in Python, a class's __subclasses__() returns a list of its immediate subclasses. So the code is correct in that.

Another possible approach is using a generator and a helper function to track visited classes, but the set method is concise and works.

Wait, but in the code above, each call to subclasses(cls) creates a new sub_classes set. Wait, no. Wait, the function is called for the original cls, then for each of its subclasses. Each call is independent. Wait, no, let me see:

Wait, for the original call, let's say X, the sub_classes is {Y, W, Z} as before. But when the function is called for Y, the sub_classes is {Z}, and for W, it's also {Z}. So when you do the update, the Z is added once to the parent's sub_classes. So that's okay.

Wait, the code for the function is: when you call subclasses(X), the first sub_classes is initialized. Then, for each s in X's direct subclasses (Y and W), add s to sub_classes and then do update with the result of subclasses(s). 

So when s is Y, we call subclasses(Y). That function's sub_classes starts empty. Then it loops over Y's subclasses (Z). Adds Z to its own sub_classes and then calls subclasses(Z). Subclasses(Z) returns empty set, so the sub_classes for Y is {Z}, so when we do the update in the parent, the Z is added to the original set. 

Then when processing W, the call to subclasses(W) starts with an empty set for its own sub_classes. Then loops over W's subclasses (Z). Adds Z to W's sub_classes (so that's {Z}), then calls subclasses(Z) which returns empty. So the update adds the same Z again, but since the original sub_classes already has Z, it won't be added again. 

Therefore, the code works because each recursive call is building its own set, but when we do sub_classes.update, we are adding all elements from the returned set of subclasses(s) into the parent's set. So even if the same subclass is in multiple branches, it's only added once.

Yes, that makes sense. So this code should work. Let me test with another example where there's a diamond structure. Suppose:

class A: pass
class B(A): pass
class C(A): pass
class D(B, C): pass

Wait, D is a subclass of both B and C, which are both subclasses of A. So A's direct subclasses are B and C. B's direct subclasses are D. C's direct subclasses are D. Then, when we call subclasses(A):

The initial loop over B and C. So first add B to sub_classes (A's first call). Then call subclasses(B). B's __subclasses__() is [D]. So the sub_classes for B would be {D} plus any of D's subclasses. Suppose D has none. So subclasses(B) returns [D]. Then, the update adds D to the original set.

Next, the loop processes C. Add C to the original sub_classes (so now B and C are in the set). Then call subclasses(C). C's __subclasses__() is [D]. So in the C's call, D is added to its own sub_classes set (which is initially empty). Then, since D has no subclasses, the set for C's call is {D}. The original sub_classes then does an update with this, which adds D again, but since it's already there, it doesn't change. 

So the final sub_classes for A would be {B, C, D}, which is correct. 

So that code works. 

Wait, but in the code above, the function returns a list, but the set is converted to a list. The order is not guaranteed, but the problem statement doesn't mention order, so that's okay.

Therefore, this code should be the correct solution. Let me write it as per the requirements. The user wants the code in Python with the function signature and docstring. So the code would be:

def subclasses(cls):
    """
    Return all subclasses of a class, recursively
    """
    sub_classes = set()
    for s in cls.__subclasses__():
        sub_classes.add(s)
        sub_classes.update(subclasses(s))
    return list(sub_classes)

Wait, but what about the case where a class has no subclasses? Then the loop doesn't run, and returns an empty list. That's correct.

Hmm, I think this is the correct code. Let me see if I can think of any other issues. The function uses __subclasses__() which may not work for built-in classes, but the problem statement probably expects it to work with standard classes. Also, in Python, the __subclasses__() method returns a list of immediate subclasses, so this is the right approach.

Another possible point: the order of the list. Since we're using a set, the order is arbitrary. But the problem doesn't specify order, so that's acceptable.

Yes, this should be the correct code. So I'll output that.
