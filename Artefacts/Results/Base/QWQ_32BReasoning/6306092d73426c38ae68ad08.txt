Okay, I need to generate Python code for the function _get_conditionally_required_args based on the provided docstring. Let me start by understanding the parameters. The function takes command_name, options_spec, and args. The goal is to return a list of argument names that have their required_when condition met.

Hmm, so first, I should loop through each option in options_spec. For each option, check if it has a 'required_when' attribute. If it does, then I need to evaluate whether that condition is met given the args.

Wait, how are the options structured? The options_spec is a list of command spec options. Each option is probably a dictionary or an object with keys like 'name' and 'required_when'. Let's assume they are dictionaries for simplicity. So each option has a 'name' key, and maybe a 'required_when' which is a function or a condition.

Wait, the required_when is a condition. How is that condition specified? The problem mentions it's a condition that's matched. Maybe required_when is a function that takes the command name and the args, and returns a boolean? Or perhaps it's a string that can be evaluated in some way. Since the user didn't specify, perhaps I should assume that required_when is a function that takes command_name and args as parameters and returns True if the argument is required.

So for each option in options_spec, I check if 'required_when' is present in the option. If it is, then I call that function with command_name and args. If the function returns True, then add the option's name to the result list.

Wait, but maybe required_when is a list of conditions? The problem's docstring says "required_when condition matched", so probably each option has a required_when that is a single condition. Let me think again. The function's return is all arguments where their required_when condition is met. So the logic would be:

Initialize an empty list to hold the required args.

For each option in options_spec:
   if the option has a 'required_when' key (or attribute), then:
      evaluate the required_when condition. If it's true:
          add the option's name to the list.

But how to evaluate the required_when? The options might have their required_when as a function. So perhaps each option in options_spec is an object with a required_when method, or a function. Alternatively, maybe required_when is a string that can be parsed, but that's less likely in a well-structured Python code. Probably, the required_when is a function that the user has provided, so we can just call it.

So the code steps:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    result = []
    for option in options_spec:
        if 'required_when' in option:  # or check if the option has that attribute
            # assuming required_when is a function here
            if option['required_when'](command_name, args):
                result.append(option['name'])
    return result

Wait, but the parameters are options_spec, which is a list. Each element in options_spec is an option. The options might have a 'name' key and a 'required_when' key. So the code above would work if that's the case. But maybe the required_when is part of the option's spec, like a nested structure? Or perhaps the 'required_when' is a list of conditions? The problem's wording isn't clear here. The docstring says "condition matched" in singular, so probably each option has a single required_when condition. 

Alternatively, maybe required_when is a list of conditions, and any of them being true would make the argument required. But the problem states "condition matched", so perhaps it's a single condition. The user's example in the docstring probably expects the code to check each option's required_when and collect those names where the condition returns True.

Another point: the function is part of a class, so self is available. But the parameters don't mention using self, so maybe the options_spec is independent of the instance.

Wait, but the function is an instance method (since it has self), so maybe some of the required_when functions might use self's attributes. But the parameters given are command_name, options_spec, and args. So the code should probably just process each option in the options_spec list, check if required_when is present, call it with the given parameters, and collect the names.

So the code structure is straightforward. Iterate through each option in options_spec. For each, check if it has a 'required_when' key. If it does, evaluate it by passing command_name and args. If the evaluation is True, append the option's 'name' to the result list. Return that list.

Wait, but maybe the required_when is a method of the option object? Like, if options are instances of a class, then required_when is a method. But in that case, the code would call option.required_when(command_name, args). But the problem's parameters mention options_spec as a list of command spec options. Without more context, perhaps the options are dictionaries. So using the key is better.

Alternatively, perhaps the options have a 'name' attribute and a 'required_when' method. So the code would need to check if the option has a required_when attribute, then call that method. But since the problem's parameters are given as options_spec, and the function is inside a class, maybe it's better to handle it as attributes. Hmm, but the docstring's parameters say options_spec is the list of command spec options. The function's docstring uses "options_spec" as the parameter, so perhaps each option in the list is a dictionary with 'name' and 'required_when' as keys. 

Alternatively, maybe the 'required_when' is a list of callables, but the problem says "condition matched", so perhaps it's a single condition. The code should check for each option's required_when and if it evaluates to True, collect the name.

So putting it all together, the code would look like this. Let me make sure that the required_when is a function. So for each option in options_spec:

if option has a 'required_when' key (or attribute), then call that function with command_name and args. 

Wait, maybe the required_when function takes only the args? Or perhaps the command name is part of the context. The function's parameters include command_name, so perhaps the required_when function uses that as well. 

The code as I thought before should work. Let me write that. 

Wait, but in the code, maybe the options are objects, not dictionaries. So perhaps the code should check if the option has a required_when attribute. Like:

if hasattr(option, 'required_when'):

Then call option.required_when(command_name, args). 

Alternatively, perhaps the required_when is stored as a key in a dictionary. Since the parameters are given as options_spec, which is a list, perhaps each element is a dictionary. The problem's description isn't specific here, but the docstring's parameters mention options_spec as the list of command spec options, so maybe each option is a dictionary with 'name' and 'required_when' keys. 

So, to cover both possibilities, perhaps the code should check for the existence of 'required_when' in the option's keys. 

Therefore, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](command_name, args):
                required_args.append(option['name'])
    return required_args

Wait, but maybe some options don't have required_when. So the code skips those. 

Alternatively, maybe the required_when is a list of functions, and any of them returning True would make it required. But the problem says "condition", so perhaps it's a single function. 

Alternatively, maybe the required_when is a condition that's a string, like "some_key == 'value'", which needs to be evaluated. But that's more complex. The problem's description doesn't specify that, so I think the first approach is correct, assuming required_when is a function.

Another possible edge case: what if the option's required_when is a function that returns a boolean, but when called, it might have different parameters. For example, maybe it takes only the args, not the command_name. But according to the docstring's parameters, the required_when condition would be matched based on the command_name and the args. So the function should pass both parameters. 

Therefore, the code is as above. Let me make sure that the options are being checked properly. So each option in options_spec must have a 'name' key and possibly a 'required_when' key. 

Wait, but maybe the required_when is a method that's part of the class, and the option has some parameters to check. For example, the required_when function might be a closure that checks the presence of another argument in args. 

But regardless, the code structure is to loop through each option, check if it has required_when, call it with command_name and args, and collect the name if the function returns True. 

Yes, I think that's the right approach. So the code would be as written. Let me also check for possible typos. Like, maybe the 'name' key is stored under a different name, but the docstring says "argument names", so the option should have a 'name' key. 

Therefore, the code is correct. Let me write it in the required markdown code format. The user wants the code output only, in Python code blocks. So I need to present it as:

```python
def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](command_name, args):
                required_args.append(option['name'])
    return required_args
```

Wait, but maybe the options are stored as objects with attributes instead of dictionaries. For example, if the options are instances with 'name' and 'required_when' attributes, then the code would need to check if the option has the required_when attribute, and then call it. 

In that case, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required = []
    for opt in options_spec:
        if hasattr(opt, 'required_when'):
            if opt.required_when(command_name, args):
                required.append(opt.name)
    return required

But how do I know which structure the options have? The problem's parameters say options_spec is a list of command spec options, but the docstring's parameters mention "options_spec: the list of command spec options". Since the user provided a docstring that refers to 'required_when' as part of the condition, perhaps the options are dictionaries with those keys. 

Alternatively, maybe the required_when is a list of conditions, but the problem's wording suggests a single condition. 

The problem's docstring says "arguments with required_when condition matched". So singular, so each option has a single condition. 

Given that, the code I wrote first should be correct. But maybe the required_when is a function that returns True when the argument is required. So the code calls that function with command_name and args, and if it returns true, adds the name to the list. 

Yes, that's the approach. 

Alternatively, perhaps the required_when function is supposed to take the args alone. But the first parameter is command_name, so the function is part of the options_spec, so maybe the function is designed to take command_name and the args. 

So I think the first code block is correct. Let me also think about possible errors. What if required_when is not a function but a different type? But the function's responsibility is to check when the condition is met, so perhaps the required_when is a predicate function. 

Therefore, the code should work. The only thing is to ensure that the options are dictionaries and the keys are correct. 

Another possible scenario: maybe the required_when is a list of functions. Then, the code would have to check any of them. But the problem's description doesn't indicate that. 

I think the initial approach is the way to go. So the code is as above. Let me make sure that the function is properly indented and uses the correct parameters. 

Yes, the parameters are self, command_name, options_spec, and args. The code loops through each option in options_spec, checks if required_when is present, calls it, and appends the name. 

That's the solution.
