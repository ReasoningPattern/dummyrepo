Okay, I need to create a Python decorator called cached that uses a cache object and a key function, and maybe a lock. The decorator should save the results of the function in the cache. Let me think about how decorators with parameters work. 

First, the structure of a decorator with parameters. The outer function takes the parameters, like cache, key, and lock. Then it returns the actual decorator that will wrap the target function. So the cached function is the outer one that returns the decorator.

The key parameter is a function that generates the key. By default, it's hashkey, but I guess the user can provide another function. The lock is optional, so maybe for thread safety?

The decorator itself needs to handle the caching. When the decorated function is called, it should check if the key is in the cache. If it is, return the cached value. If not, compute the result, store it in the cache, and then return it. 

Wait, how to generate the key? The key function probably takes the function's arguments. So the key would be generated by calling key(*args, **kwargs) or something like that. Wait, the key function's parameters might need the function's name and arguments? Or maybe it's supposed to take the function's arguments as input. The docstring says "key=hashkey" so I should assume that hashkey is a function that can generate a unique key based on the function's arguments.

So the steps would be:

1. The outer function cached takes cache, key, and lock as parameters.
2. It returns a decorator function, let's call it decorate.
3. decorate takes the actual function to be decorated, so it's the function that will be called when the decorated function is invoked.
4. When the decorated function is called, the key is generated using the key function. The key might need the function's name, its arguments, etc. Wait, perhaps the key function is supposed to take the function's arguments and return a string. So in the decorator, when the function is called, we pass the args and kwargs to the key function. Like key_func = key, then cache_key = key_func(*args, **kwargs). Hmm, but maybe the key function is supposed to take the function and its arguments? Or maybe the function's name and the arguments? Not sure. The problem statement says the key is hashkey by default. Maybe the user is supposed to provide a function that can create a key based on the arguments. Let me assume that the key function takes the function's arguments and returns a key. So when the decorator is applied, the key is generated each time the function is called.

Wait, but how does the key function know which function's arguments to use? Oh right, because when the decorator is created, it's bound to the function, so the key function is called with the arguments passed to the decorated function. 

So the decorator function would look like this:

def decorate(func):
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # generate the key
        cache_key = key(func, *args, **kwargs)  # or just key(*args, **kwargs)
        # check if the key exists in the cache
        if cache_key in cache:
            return cache[cache_key]
        # if not, compute the result
        result = func(*args, **kwargs)
        # store it in the cache
        cache[cache_key] = result
        return result
    return wrapper

Wait, but the default key is hashkey. I need to make sure that hashkey is a function that can take the function and its arguments. Wait, perhaps the key function is supposed to be a function that takes the function and its arguments. Or maybe the key function just takes the arguments. Let me think again. The problem says the default key is hashkey. So maybe hashkey is a function that can generate a key based on the function's name and arguments. For example, maybe hashkey is a function like this: def hashkey(func, *args, **kwargs). So in the cached decorator, the key function is called with the function, its args and kwargs. That makes sense because the same key function might be used for multiple functions, so the key would need to include the function's identity.

Therefore, in the wrapper function, when generating the key, we should pass the function itself along with the arguments. So cache_key = key(func, *args, **kwargs). 

Wait, but then the default key function would have to accept the function as the first argument. So the user must define their key functions in a way that they can take the function and its arguments. Alternatively, maybe the key function is only supposed to take the arguments. That's possible. The problem statement isn't clear, but since the default is hashkey, maybe the key function expects to have the function as an argument. 

Alternatively, perhaps the key is just a function that takes the arguments. Let me think of the standard use cases. For example, in a simple cache, you might generate a key based on the arguments. Maybe the hashkey function is supposed to take the args and kwargs. Hmm. The problem says the key is hashkey, but I'm not sure. Well, since the problem didn't give any examples, I have to make a decision here. Let's assume that the key function takes the function's arguments as parameters, so when called with *args and **kwargs, it returns a unique key for those parameters. 

Wait, but the function's name isn't part of the key. That might be a problem if two different functions have the same arguments. The cache would store under the same key, leading to incorrect results. So perhaps the key function needs to take the function as an argument, so that the key includes the function's identity. 

Therefore, the correct approach is that the key function must take (func, *args, **kwargs) as parameters. So the default hashkey must do that. 

Okay, so in the wrapper, the key is generated by key(func, *args, **kwargs). 

Now, about the lock. If a lock is provided, we should use it to synchronize access to the cache. So when checking the cache, storing the result, etc., we need to acquire the lock. 

So the code would need to handle the lock. For example:

if lock is not None:
    with lock:
        # check and store
else:
    # proceed without lock

So putting it all together, the wrapper function would first compute the key, then check the cache (with a lock if needed). 

Wait, but how to handle the cache? Let's say the cache is a dictionary. The decorator's wrapper would first check if the key is present in the cache. If not, compute the result, store it, and return. 

So the steps in the wrapper are:

1. Compute the key using key(func, *args, **kwargs)
2. Check if the key is in the cache (with lock if needed)
3. If present, return the value
4. Else, compute the result, store it in the cache (using the lock?), and return.

But when using a lock, the entire block should be atomic. So we need to acquire the lock before checking the cache and storing. So the code would be something like:

def wrapper(*args, **kwargs):
    cache_key = key(func, *args, **kwargs)
    if lock:
        with lock:
            if cache_key in cache:
                return cache[cache_key]
            result = func(*args, **kwargs)
            cache[cache_key] = result
            return result
    else:
        if cache_key in cache:
            return cache[cache_key]
        result = func(*args, **kwargs)
        cache[cache_key] = result
        return result

Hmm, but this might have a problem where multiple threads could compute the same result simultaneously. Because without a lock, two threads might check the cache at the same time, both find it missing, compute the result, and then both store it. But in a non-lock scenario, maybe the user is okay with that. Or perhaps the lock is meant to prevent that. Alternatively, maybe the lock is used to guard the entire process. 

Alternatively, maybe the lock is a reentrant lock or some kind of context manager. The code uses lock as a context manager with 'with lock', so that's correct. 

Wait, but the problem says "lock=None". So if a lock is provided, we use it. 

Wait, perhaps the lock is used to guard the cache access. So even if the cache is a thread-safe data structure, the lock is for atomic operations. 

So the code structure is correct. 

Now, the key function's default is hashkey, but in the problem's code, the user might have to pass it. Wait, in the function signature, key is set to hashkey. But where is hashkey defined? Since the user is supposed to have it, perhaps the code doesn't need to define it, but the decorator expects that it's a function. 

Therefore, the code can proceed as is. 

Also, need to use functools.wraps to preserve the function's metadata. So the decorate function must use wraps on the wrapper. 

Wait, in Python, when using a decorator with parameters, the outer function returns the decorator, which then wraps the function. So the code would need to import functools and use @functools.wraps. 

Putting it all together:

The cached function is the outer function. It returns a decorate function, which in turn returns a wrapper function. 

So the code would look like this:

import functools

def cached(cache, key=hashkey, lock=None):
    def decorate(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(func, *args, **kwargs)
            if lock:
                with lock:
                    if k in cache:
                        return cache[k]
                    v = func(*args, **kwargs)
                    cache[k] = v
                    return v
            else:
                if k in cache:
                    return cache[k]
                v = func(*args, **kwargs)
                cache[k] = v
                return v
        return wrapper
    return decorate

Wait, but in the code above, the key is called as key(func, *args, **kwargs). So the default hashkey function must accept the function as the first argument. 

Alternatively, maybe the key function is supposed to just take the arguments and not the function. Then the code would be:

k = key(*args, **kwargs)

But then the key can't differentiate between different functions. So I think the first approach is correct. 

Wait, the problem's docstring says the key is hashkey, so I need to assume that the hashkey function is designed to take the function and its arguments. 

Therefore, the code should be structured that way. 

Wait, but in the function signature for the cached decorator, the key is passed as a parameter. So the user can provide a key function that takes the same arguments as the key. 

Wait, perhaps the key function is supposed to be a function that takes the function's arguments and returns a key. In that case, the key function would not take the function as an argument. So the code would be:

k = key(*args, **kwargs)

But then, the key would be the same for different functions with the same arguments, which is not desired. So maybe the key function should accept the function as an argument. So the user's key function would have to take (func, *args, **kwargs). 

So the code needs to call key with the function as the first argument. 

Therefore, the key function in the code is called with key(func, *args, **kwargs). 

But in the problem's function signature, the key is given as a parameter. The default is hashkey. So the hashkey function must be expecting those parameters. 

Thus, the code is okay. 

Wait, but the user might have a key that doesn't take the function. Maybe the problem's hashkey is a function that can take variable arguments. Let me think. Maybe the hashkey is a function that can generate a key based on the function's name and its arguments. But that's implementation details. 

The code as written requires that the key function takes the function as an argument. So the user must provide a key that does that. 

Alternatively, maybe the key is a function that takes the arguments and returns the key. In that case, the key would be key(*args, **kwargs). But then the key would be the same for different functions with the same parameters, leading to cache collisions. 

Hmm. The standard way to handle this in decorators is to include the function in the key. So for example, the default key could be something like the function's name plus the arguments. 

So the code's approach is correct. 

Another thing: the cache is passed as an object. So the code assumes that cache is a mutable mapping, like a dictionary. So we can use cache[k] = v. 

Now, the code structure. The outer function cached takes the parameters, returns the decorate function. The decorate function takes the function to be decorated, and returns the wrapper. 

Wait, the code I wrote above is missing the import of functools. Oh right, because the @functools.wraps is needed. So the code must start with importing functools. 

Wait, but the problem says to output the code without any explanation, so I just have to write the code. But the user might not have hashkey defined. Wait, the problem says the default is hashkey, so the code must have that. Oh, but the code can't define hashkey. So perhaps the hashkey is a function from some module, but the problem expects that the user has that. So the code doesn't need to define it. 

Wait, but maybe the hashkey is a function that the user is supposed to pass. The problem's function signature shows key=hashkey. So that implies that hashkey is a variable in the current scope. 

But in the code I'm writing, I can't assume that. So perhaps the code is correct as written, but the user must have hashkey defined. 

Alternatively, maybe the hashkey is a function that is part of the code. Wait, but the problem says to generate code based on the given signature and docstring, so I shouldn't add any other functions unless they are part of the decorator. 

Therefore, the code should work as written. 

Wait, but in Python, if the default is hashkey, but that's not defined, the code would have an error. So perhaps the problem expects that the key function is part of the code. But the problem's code only has the cached function. 

Hmm, maybe the hashkey is a placeholder, and the user is supposed to define it. Since the problem's docstring says "key=hashkey", perhaps the hashkey is a function that the user can define. Therefore, the code doesn't need to include it. 

Therefore, the code I wrote earlier is correct. 

Wait, but I think the standard approach for such a decorator is to have the key function generate a key based on the function's arguments. So perhaps the key function is supposed to take the function's arguments and not the function itself. 

Alternatively, maybe the key function is supposed to take the function's name and its arguments. 

Hmm, this is a bit ambiguous, but given that the problem's default is hashkey, which is probably a function that can take the function and its arguments. 

Alternatively, perhaps the key function is supposed to be a function that takes the function's name, *args, and **kwargs. 

Wait, perhaps the key function is supposed to be a function that takes the arguments and returns a string. 

Let me think of an example. Suppose we have a function add(a, b), then the key for (1,2) would be something like 'add_1_2' or similar. 

The hashkey function would need to know the function's name or id to generate the key. 

Therefore, the key function must have access to the function, so the first argument is the function. 

So the code is correct. 

Now, the code uses 'k in cache' and 'cache[k]'. So the cache must be a dictionary-like object. 

Another point: the lock is optional. So if it's provided, we use it as a context manager. 

Wait, but what if the lock is not a context manager? The problem probably expects that the lock is a threading.Lock instance or similar, which can be used with 'with'. 

Therefore, the code is okay. 

Wait, the code for the wrapper can be written more concisely. Let me see. 

In the case where there is a lock, the code is:

with lock:
    if k in cache:
        return cache[k]
    v = func(*args, **kwargs)
    cache[k] = v
    return v

Wait, but even with the lock, there's a race condition between checking and storing. Wait no, because the lock is held during the entire check and store. So if two threads are in the 'with lock' block, only one can proceed at a time. 

Therefore, the lock ensures that the check and store are atomic. 

So the code is okay. 

Now, the code needs to use functools.wraps. So the import is necessary. 

Putting all that together, here's the code. Wait, but in the problem's code, the function is named cached, and the parameters are cache, key, lock. 

Wait, the outer function is called 'cached', which takes those parameters, and returns the decorate function. 

Wait, the code I wrote earlier is correct. Let me check again.

Wait, the structure is:

def cached(cache, key=hashkey, lock=None):
    def decorate(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            ... compute key using key(func, ...)
            ... check cache with lock ...
        return wrapper
    return decorate

Yes. So the code should be as above. 

Wait, but in the problem's function signature, the key is set to hashkey. So the code must have hashkey defined. Or perhaps the user is supposed to pass a key function, and hashkey is a function that the user must have. Since the problem says "generate Python code based on the function signature and docstring", I think the code should just proceed as written, assuming that hashkey is already defined elsewhere. 

Therefore, the code I wrote is correct. 

Wait, but in the code, the key is called with (func, *args, **kwargs). So if the default hashkey function is expecting those parameters, then that's okay. 

Therefore, the code is correct. 

Now, I need to make sure to include the import of functools. 

Wait, in the code I wrote earlier, I did import functools. 

So the code starts with that. 

Wait, but the problem says "do not include any explanation or markdown formatting. Output only the code generated in Python markdown format." So I have to write the code with the markdown syntax, like putting it in triple backticks. Wait, the user's instruction says to output the code in Python markdown format. Wait, maybe they mean just the code, without the markdown. Because markdown format for code would be enclosed in triple backticks, but the problem might just want the code itself. 

Wait, the user's exact instruction is: "Output ONLY the code generated, in python markdown format." 

Hmm, perhaps they mean to put the code in a code block using markdown syntax. So like:

```python
# code here
```

So the code should be enclosed in triple backticks. 

But the problem says "do not include any explanation, reasoning, or markdown formatting". Wait, maybe they want just the code, not the markdown. But the part after says "output ONLY the code generated, in Python markdown format." So maybe they want the code block with the markdown syntax. 

So I'll write the code inside triple backticks. 

Wait, but I also have to make sure that the code is properly indented. 

Wait, let me check again. 

The code structure:

import functools

def cached(cache, key=hashkey, lock=None):
    def decorate(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(func, *args, **kwargs)
            if lock:
                with lock:
                    if k in cache:
                        return cache[k]
                    v = func(*args, **kwargs)
                    cache[k] = v
                    return v
            else:
                if k in cache:
                    return cache[k]
                v = func(*args, **kwargs)
                cache[k] = v
                return v
        return wrapper
    return decorate

Wait, but in the key function call, the parameters are func, *args, **kwargs. So the key function must accept the function as the first argument. 

Assuming that's okay, then this code should work. 

Wait, but in the case where the key is not hashkey, like if the user passes a different function, that function must also take the function, args, and kwargs. 

Alternatively, perhaps the key function is supposed to take just the arguments. Then the code would be different. 

Hmm, this is a critical point. Let me think again. 

The problem says the decorator should save the results in the cache. The key is used to generate the key for the cache. Since different functions with the same arguments should have different keys, the key function must have access to the function's identity. 

Therefore, the key function must take the function as an argument. 

Therefore, the code is correct. 

Another point: in the else clause (when no lock is present), the code checks the cache, then if not present, calls the function. But without a lock, there's a possibility of race conditions where two threads check the cache at the same time, both not find the key, then both compute the result. That's a problem. So the lock is necessary for thread safety. 

But the problem states that the lock is optional. So if the user doesn't provide it, the decorator isn't thread-safe. That's acceptable because the user can choose to use a lock if needed. 

Therefore, the code is okay. 

Now, the code needs to be written properly. Let me check for syntax errors. 

Wait, the key is called as key(func, *args, **kwargs). So that's correct. 

Yes. 

So the final code should look like this, enclosed in triple backticks. 

Wait, but in Python, the default parameter for key is hashkey. So if hashkey is not defined in the current scope, the code would raise an error. But perhaps the problem expects that the user has a hashkey function available. 

Therefore, the code is correct as written. 

I think that's all. Now, I'll write the code accordingly.
