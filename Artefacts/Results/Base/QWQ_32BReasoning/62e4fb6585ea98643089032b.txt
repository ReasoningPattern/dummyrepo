Okay, I need to write a Python function called parse_version that takes a string and returns a tuple of integers. The docstring says it converts a string concatenated by dots into such a tuple. So, the input is something like "1.2.3" and the output should be (1,2,3). 

First, I should think about how to split the string into parts. The string is separated by dots, so using the split('.') method makes sense here. Once I split it, I'll get a list of strings like ["1", "2", "3"].

But each of those parts needs to be converted to an integer. So I can loop through each element in the split list and convert them. Maybe a list comprehension would work well here. Like [int(part) for part in s.split('.')].

Wait, but what if the string has leading or trailing whitespace? The problem statement doesn't mention handling that, so I guess I can assume the input is properly formatted. 

Also, what about cases where the string might have parts that aren't numbers? The function's docstring says it's converting a properly concatenated string, so perhaps we can assume that each part is a valid integer. So no error checking needed here.

The function should return a tuple, not a list. So I can convert the list comprehension into a tuple. So, tuple(int(part) for part in s.split('.')).

Hmm, that's straightforward. Let me test some examples. For instance, "0.11.4" would become (0,11,4). What about "3.14"? That should be (3,14). And "2" alone would be (2,). Oh right, because the tuple needs to have at least one element. 

Wait, the function's return type is tuple[int, ...], which means all elements are integers and the tuple can have any number of them. So splitting on dots and converting each part should cover all cases. 

So putting it all together, the code would be:

def parse_version(s: str) -> tuple[int, ...]:
    return tuple(int(part) for part in s.split('.'))

I think that's it. Let me see if there are any edge cases. Like an empty string? But the function probably expects a non-empty version string. What if the input is "1.0.0.0"? Then the tuple would be (1,0,0,0), which is correct. 

Another test case: "1.2.3.4.5" becomes (1,2,3,4,5). Yeah, that works. 

What about leading zeros in the numbers? Like "1.002.3"? Well, converting "002" to an integer would be 2, so the tuple would be (1,2,3). But maybe that's acceptable because the function's job is to parse the string into integers, and leading zeros in numbers are common in versioning but treated as part of the integer. Wait, no, in versioning like 1.002.3, the actual numeric values are 1, 2, 3. Because leading zeros in numbers don't affect their integer value. So the code is correct here.

I think that's all. The function should split the string by dots, convert each part to an integer, and return the tuple. So the code is simple as that. Let me just make sure I didn't miss anything. The function's parameters are a string, and it returns a tuple of ints. The examples I can think of all work. So the code should be as above.
