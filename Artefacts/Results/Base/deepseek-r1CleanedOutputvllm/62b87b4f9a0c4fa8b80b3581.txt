class Histogram:
    def __init__(self, bins):
        self.bins = bins
        self.scale = None  # Will store the computed scale

    def scale(self, other=None, recompute=False):
        """
        Compute or set scale (integral of the histogram).

        If *other* is ``None``, return scale of this histogram.
        If its scale was not computed before,
        it is computed and stored for subsequent use
        (unless explicitly asked to *recompute*).
        Note that after changing (filling) the histogram
        one must explicitly recompute the scale
        if it was computed before.

        If a float *other* is provided, rescale self to *other*.

        Histograms with scale equal to zero can't be rescaled.
        :exc:`.LenaValueError` is raised if one tries to do that.
        """
        if other is None:
            if recompute or self.scale is None:
                self.scale = sum(self.bins)
                if self.scale == 0:
                    raise LenaValueError("Scale cannot be zero")
            # Ensure scale is not zero after computation
            if self.scale == 0:
                raise LenaValueError("Scale cannot be zero")
            return self.scale
        else:
            if not isinstance(other, float):
                raise TypeError("Other must be a float")
            if self.scale == 0:
                raise LenaValueError("Cannot scale by zero")
            # Rescale each bin
            for i in range(len(self.bins)):
                self.bins[i] = self.bins[i] * other / self.scale
            return