Okay, I need to write a Python function called remove_ending_os_sep that takes an input_list as an argument. The docstring explains that if the input is None, we return an empty list. Otherwise, we iterate over a string list and remove trailing OS separators. Each string is checked if its length is greater than one and if the last character is a path separator. The function should return the modified list.

First, I'll handle the case where input_list is None. So, the function starts with checking if input_list is None. If it is, return an empty list.

Next, I'll process each string in the list. For each string, I need to check if its length is more than one. If it's not, I'll leave it as is. If it is longer, I'll look at the last character. If the last character is either '/' or '\', I'll slice the string to remove that character. Otherwise, I'll leave the string unchanged.

I'll create a new list, maybe called cleaned_list, and append each processed string to it. After processing all strings, I'll return cleaned_list.

Let me think about how to implement this. For each s in input_list, if len(s) > 1, check s[-1]. If it's in ('/', '\\'), then s = s[:-1]. Append s to cleaned_list. Else, append s as is.

Wait, but what if the string is just one character? Like 'a'? Then len(s) is 1, so we don't process it. That's correct because we can't have a trailing separator in a single character string.

Testing some examples: For example, if input_list is ['file.txt', 'dir/', ''], then the output should be ['file.txt', 'dir', ''] because 'dir/' becomes 'dir' and the empty string remains. But wait, the empty string's length is 0, so it's not processed. Hmm, but in the function, the condition is len(s) > 1, so empty string is skipped.

Wait, but what about a string like 'test//'? Because in some OS, '//' is considered a separator. But according to the problem statement, we're only checking for the trailing OS separator, which is either '/' or '\', not multiple. So if the string ends with '//', only the last character is removed. So 'test//' becomes 'test/'.

But the problem says to remove trailing OS separators, so perhaps we should keep removing until the last non-separator character. However, the problem's docstring says to remove the trailing OS separator, implying only the last one. So perhaps the function should only remove the last character if it's a separator.

Wait, looking back at the problem statement: "remove trailing os seperator characters." So it's only the last character. So for a string like 'file.txt//', it would become 'file.txt/'.

But the initial approach I thought of only removes the last character if it's a separator. So that's correct.

Another example: input_list = ['a/b/c', 'd', ''] returns ['a/b/c', 'd', ''] because 'a/b/c' doesn't end with a separator, 'd' is length 1, and empty string is skipped.

Wait, but if the string is 'file.txt', it's fine. If it's 'file.txt/', it becomes 'file.txt'. If it's 'file.txt//' (on Windows), it would become 'file.txt/'.

So the function correctly handles that.

Now, writing the code:

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    cleaned_list = []
    for s in input_list:
        if len(s) > 1:
            if s[-1] in ('/', '\\'):
                cleaned_list.append(s[:-1])
            else:
                cleaned_list.append(s)
        else:
            cleaned_list.append(s)
    return cleaned_list

Wait, but in the case where the string is empty, len(s) is 0, so it's added as is. That's correct.

Testing another case: input_list = ['test', 'test.txt', 'test/'] becomes ['test', 'test.txt', 'test'].

Yes, that's correct.

I think this should work.
