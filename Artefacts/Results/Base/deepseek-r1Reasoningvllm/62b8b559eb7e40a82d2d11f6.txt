Okay, I need to write a Python function called determine_metaclass that takes in bases and an optional explicit_mc. The docstring says it's to determine the metaclass based on the bases and an optional explicit __metaclass__. 

Hmm, I remember that in Python, the metaclass is determined by the bases of a class. If a class doesn't specify a metaclass, it uses the first metaclass in the chain of its bases. So, the function should look through the bases to find the appropriate metaclass.

Wait, if explicit_mc is provided, it should take precedence over the bases. So the function should first check if explicit_mc is not None. If it is, return that.

If explicit_mc is None, then iterate through the bases. But wait, the bases are classes, right? So I need to get their metaclasses. But how do I do that? Oh right, the type() function can be used. So for each base in bases, I can get its metaclass using type(base).metaclass.

But wait, that's not exactly right. Because if a base is a class defined in the current module, type(base) gives the class, and its metaclass is stored as a class attribute. But if the class is inherited from another module, maybe through inheritance or from __future__, that could complicate things. However, for the purpose of this function, I think it's safe to assume that the metaclass is stored in type(base).__metaclass__.

Wait, no, in Python 3, the metaclass is an attribute of the class object. So for a class c, c.__metaclass__ gives the metaclass. So I should use that.

So the function should loop through each base in bases. For each base, get its metaclass. But wait, if a base is a class that doesn't have a metaclass explicitly set, it will use the default, which is type's metaclass, which is type.__metaclass__. But that's probably not what we want. We want the first metaclass in the bases hierarchy.

So, the function should find the first metaclass from the bases. So it should iterate through each base, get the metaclass, and if it's not None, return it. If none are found, return type.__metaclass__.

Wait, but the function's docstring says it's based on 1+ bases, so at least one base is provided. So we don't need to handle the case where bases is empty.

Putting it all together:

If explicit_mc is not None, return it.

Otherwise, for each base in bases:
    get the metaclass of the base (base.__metaclass__)
    if it's not None, return it
After checking all bases, if none found, return type.__metaclass__

Wait, but what if a base's metaclass is None? That can't happen because in Python, every class has a metaclass. So maybe I should handle that case.

But perhaps it's better to proceed as such.

So the code would look like:

def determine_metaclass(bases, explicit_mc=None):
    if explicit_mc is not None:
        return explicit_mc
    for base in bases:
        base_metaclass = type(base).__metaclass__
        if base_metaclass is not None:
            return base_metaclass
    return type.__metaclass__

Wait, but in Python, for a class defined in the current module, type(base) gives the class, and type(base).__metaclass__ is the metaclass. So this should work.

But wait, in Python 3, the __metaclass__ attribute is a class attribute, and it's an instance of type. So this should correctly get the metaclass.

I think that's the correct approach. So the code should be as written.
