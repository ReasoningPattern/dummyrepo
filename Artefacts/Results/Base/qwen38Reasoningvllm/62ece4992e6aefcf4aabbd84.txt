
Okay, I need to write a Python function called is_ipv4 that checks if a given target is a valid IPv4 address. Let me think about how to approach this.

First, I remember that an IPv4 address is made up of four octets separated by dots. Each octet must be a number between 0 and 255. So the function should split the target by dots and check if there are exactly four parts. Also, each part needs to be a valid integer in that range.

Wait, but what about leading zeros? Like, if someone writes "192.168.00.1", that's invalid because leading zeros are not allowed. So I need to make sure each octet doesn't have leading zeros unless it's just a single zero.

Hmm, so the steps are: split the target into parts using the dot as a delimiter. Then check if there are exactly four parts. For each part, verify that it's a string that can be converted to an integer, and that the integer is between 0 and 255. Also, check for leading zeros. Oh right, like "01" is invalid because it's a leading zero and not a single zero.

So, let's outline the steps. Split the target by '.' into a list. If the length isn't 4, return False. Then iterate over each part. For each part, check if it's a valid integer. Also, if the part starts with a zero and its length is more than 1, it's invalid. For example, "0" is okay, but "00" or "012" are not.

Wait, but how to handle cases where the part is empty? Like if the target is "192.168..1", splitting would give parts with empty strings. So that's another check: each part must be a non-empty string.

So the function should:

1. Split the target by '.' into parts.
2. Check if there are exactly four parts.
3. For each part:
   a. Check if it's a valid integer string.
   b. Check if it doesn't have leading zeros (unless it's a single zero).
   c. Check if the integer value is between 0 and 255.

How to implement this in Python?

Let me think about using a loop. For each part in the split list:

- If the part is empty, return False.
- If the part starts with '0' and has more than one character, return False.
- Try converting to integer. If it's not possible, return False.
- Check if the integer is in 0-255 range. If not, return False.

So, code steps:

Split the target into parts = target.split('.')

If len(parts) !=4, return False.

Then loop through each part in parts:

for part in parts:
    if not part.isdigit():
        return False
    if len(part) > 1 and part[0] == '0':
        return False
    num = int(part)
    if num < 0 or num > 255:
        return False

Wait, but what about parts that are like '255a'? The isdigit() check would catch that because '255a' is not all digits.

Yes, so first check if each part is composed of digits only. Then check leading zeros. Then check the numeric range.

But wait, what about parts that are empty? Like if the target is '192.168.1', split would give three parts, but if there's something like '192..168.1', then splitting would give parts with empty strings. So in that case, during the loop, the empty string would fail the isdigit() check.

Wait, no. For example, if the target is '192.168.0.1', split gives ['192','168','0','1'], which is okay. But if there's a part that's empty, like in '192.168..1', then splitting would give ['192','168','','1'], which would have len(parts) as 4, but the third part is empty. So in that case, during the loop, the empty string would fail isdigit(), so return False.

So that's covered.

But what about leading zeros? For example, '192.168.01.1' would have the third part as '01', which starts with 0 and has length 2. So that's invalid. So the code should check for that.

So the code would be:

def is_ipv4(target):
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if len(part) > 1 and part[0] == '0':
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True

Wait, but what about parts that are like '256'? The code would check if num is >255, which it is, so return False.

Yes.

But wait, what about leading zeros in the case of '0'? Like, if a part is '0', that's allowed. So the code checks if len(part) >1 and starts with 0. So '0' is okay, but '00' is not.

That seems correct.

But let me test some cases.

Test case 1: '192.168.1.1' → should return True.

Test case 2: '255.255.255.255' → True.

Test case 3: '0.0.0.0' → True.

Test case 4: '1.2.3.04' → the last part is '04', which starts with 0 and has length 2 → returns False.

Test case 5: '1.2.3.4a' → split into parts, the last part is '4a', which is not digits → returns False.

Test case 6: '192.168.1.256' → 256 is over 255 → returns False.

Test case 7: '192.168.1' → len(parts) is 3 → returns False.

Test case 8: '192.168.01.1' → third part is '01' → len>1 and starts with 0 → returns False.

What about '192.168.1.0'? That's valid. The code would split into four parts, each is digits, no leading zeros, and numbers are within 0-255. So returns True.

Another case: '192.168.1.00' → the last part is '00', len>1 and starts with 0 → returns False.

What about '192.168.1.2a'? The split would have '2a' as a part, which is not digits → returns False.

But wait, what if the target is something like '192.168.1.05'? The code would check if len(part) >1 and starts with 0. '05' has len 2 and starts with 0 → returns False.

Yes, that's correct.

But wait, what about parts that are empty? Like, if the target is '192.168.1.0.' → split into ['192','168','1','0', ''] → len is 5, so returns False.

So the code seems to handle that.

But wait, what if the target is '192.168.1.0'? Split into four parts, each is valid. So returns True.

Another edge case: '0.0.0.0' → valid.

What about '255.255.255.255'? Valid.

What about '123.45.67.89'? Valid.

What about '123.45.67.890'? The last part is 890, which is over 255 → returns False.

So the code should handle all these cases.

But wait, the code splits on '.' and then checks each part. So, for example, if the target is '192.168.1.1', it's okay. But if there's a part that's like 'a.b.c.d', then split into parts would have 'a', 'b', 'c', 'd', which are not digits. So the code returns False.

But what about leading zeros in the first part? Like '012.34.56.78'? The first part is '012', which starts with 0 and has length 3 → returns False.

Yes.

So the code seems to handle all the cases.

But wait, what about parts that are like '0'? That's allowed. So the code checks len(part) >1 and part[0] == '0' → for '0', len is 1, so no problem.

Another thing: the code converts each part to integer. So even if the part is '0', it's okay. But what about parts that are '000'? Well, the code would check len(part) is 3, which is >1 and starts with 0 → returns False.

So that's correct.

So putting it all together, the code would be:

def is_ipv4(target):
    """
    Test if IPv4 address or not.

       Returns: Boolean, True if target is IPv4 address, else False.
    """
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        if len(part) > 1 and part[0] == '0':
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True

Wait, but what about parts that are empty? Like, if the target is '192.168.1.0', split into four parts, each is non-empty. But if the target is '192.168.1', split into three parts. So the code returns False.

But what if the target is '192.168.1.0.'? Then split into 5 parts, so returns False.

So that's covered.

But wait, what if the target is '192.168.1.0a'? Then split into ['192','168','1','0a'], and '0a' is not digits → returns False.

Yes.

Another edge case: '255.255.255.255' → all parts are 255, which is allowed.

What about '123.045.067.089'? Each part has leading zeros and len>1 → returns False.

Yes.

So this code should handle all the cases. But wait, what about parts that are like '0'? That's allowed. So '0.0.0.0' is valid.

But what if a part is '00'? Then len(part) is 2, starts with 0 → returns False.

So that's correct.

I think this code should work. Let me check for some possible errors.

Wait, the code checks if the part is digits, but what about if the part is empty? For example, if the target is '192.168.1.', then split into ['192','168','1',''], which would have len 4. Then the last part is empty. The isdigit() check for empty string would return False, so the code returns False. That's correct.

Another case: target is '192.168.1.05' → the last part is '05', which is digits, but len>1 and starts with 0 → returns False.

Yes.

So the code seems to handle all these cases. Therefore, this should be the correct implementation.
