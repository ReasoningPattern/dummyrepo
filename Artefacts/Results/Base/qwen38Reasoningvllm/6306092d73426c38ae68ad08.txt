
Okay, let's see. I need to generate Python code for the function _get_conditionally_required_args. The function's purpose is to list arguments that meet the required_when condition. The parameters are command_name, options_spec, and args. The options_spec is a list of command spec options, and args is the input arguments.

First, I should figure out what the required_when condition entails. From the docstring, it seems like each option in options_spec might have a required_when condition that depends on the command name and the provided arguments. So the function needs to check for each option if its required_when condition is met based on the command name and the args.

Wait, but how are the options_spec structured? Probably, each element in options_spec is a dictionary or an object that has a 'required_when' key. The required_when could be a condition that checks if certain arguments are present. For example, maybe it's a lambda function or a string that evaluates to a boolean.

Hmm, the function needs to iterate through each option in options_spec and determine if the required_when condition is satisfied. If it is, then add the argument name to the result list.

So the steps would be:

1. Initialize an empty list to collect the argument names.
2. Loop through each option in options_spec.
3. For each option, check if 'required_when' is present. If not, maybe skip or consider as not required?
4. Evaluate the required_when condition using the command_name and args. But how? The condition might be a function that takes command_name and args as parameters. Or maybe it's a string that represents a condition, like "args['arg1'] is not None".

Wait, the docstring says the function returns arguments with matched required_when condition. So the required_when is probably a function that determines if the argument is required based on the command name and the current args.

But the parameters to the function are command_name, options_spec, and args. So for each option in options_spec, we need to check if the required_when condition is met. If yes, add the argument name to the result.

So the code would look something like:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            # evaluate the condition
            if option['required_when'](command_name, args):
                required_args.append(option['name'])
    return required_args

But wait, maybe the required_when is a string that needs to be parsed. For example, a condition like "command_name == 'create' and args['param1'] is not None". In that case, we'd need to evaluate that string in some way. However, the docstring doesn't specify that, so perhaps it's intended that required_when is a function.

Alternatively, maybe the options_spec is a list of dictionaries where each has a 'required_when' key that's a function. So the code would check each option's required_when function with the command_name and args.

But the user hasn't provided the structure of options_spec. So I need to make assumptions here. Let's assume that each option in options_spec is a dictionary with a 'name' key and a 'required_when' key. The 'required_when' is a function that takes command_name and args and returns True or False.

So the code would loop through each option, check if required_when is present, then evaluate it. If it returns True, add the name to the list.

Wait, but the function is part of a class, so maybe the options_spec is a list of objects or something else. However, given the parameters, the code should work with whatever structure options_spec has. So perhaps the code is written in a way that each option has a 'required_when' attribute or key that can be checked.

Alternatively, maybe the required_when is a condition that depends on the command name. For example, some arguments are required only when the command is a certain name. But the docstring says the condition is matched based on the command name and the args.

So, the code would need to check for each option's required_when condition. Let me think of possible implementations.

Another possibility: the required_when is a string that represents a condition, like "command_name == 'create' and args['param1'] is not None". Then, we need to evaluate that string in the context of the current command_name and args. But evaluating arbitrary strings can be dangerous, so maybe it's better to assume that required_when is a function.

But since the user hasn't specified, perhaps the safest way is to assume that required_when is a function. So the code would check if the option has a 'required_when' key, then call that function with command_name and args. If it returns True, add the argument name.

Wait, but the function is part of a class. So maybe the options_spec is a list of objects that have attributes like name and required_when. Or maybe they are dictionaries.

In any case, the code would need to process each option in options_spec. Let me write the code assuming that each option is a dictionary with 'name' and 'required_when' keys. The required_when is a function that takes command_name and args.

So the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](command_name, args):
                required_args.append(option['name'])
    return required_args

But wait, maybe the options_spec is a list of tuples or something else. However, given the parameters, the code should be generic enough. Alternatively, perhaps the options_spec is a list of dictionaries where each has 'name' and 'required_when' keys.

Another thing to consider: the args parameter is the received input arguments. So, when evaluating the required_when condition, we need to check if certain arguments are present in args. For example, if the condition is "args['param1'] is not None", then we need to access args as a dictionary.

But how is args structured? Maybe it's a dictionary, so we can check for keys. So the code would need to pass args to the required_when function, which can then check for the presence of certain keys.

Alternatively, maybe the required_when is a condition that depends on the command name and the presence of other arguments. For example, a condition like "command_name == 'create' and 'param1' in args".

But again, without more info, I'll proceed with the assumption that required_when is a function that takes command_name and args as parameters and returns a boolean.

So the code would loop through each option in options_spec, check if the required_when condition is met, and collect the names.

Another possible edge case: what if the required_when is not present? The docstring says to return arguments with matched required_when, so perhaps options without required_when are not considered. So the code checks for 'required_when' in the option.

So the code would be as above. Let me write that.
