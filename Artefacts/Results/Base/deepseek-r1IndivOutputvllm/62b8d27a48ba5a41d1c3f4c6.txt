

To solve this problem, we need to create a Python decorator function called `cached` that saves the results of a function call into a cache. The cache will use a provided key function to determine the key for storing the result and an optional lock to ensure thread safety.

### Approach
1. **Function Signature**: The `cached` function takes three parameters: `cache`, `key`, and `lock`. The `cache` is a dictionary where results will be stored, `key` is a function that generates a unique key for each set of arguments, and `lock` is an optional threading lock to prevent multiple threads from writing to the cache simultaneously.
2. **Decorator Factory**: The `cached` function returns a decorator factory, which takes a function `func` as an argument and returns a decorator. This decorator will wrap the function to add caching behavior.
3. **Wrapper Function**: The wrapper function computes the result of `func`, stores it in the cache using the key generated by the `key` function, and returns the result. If a lock is provided, it ensures that only one thread can access the cache at a time.

### Solution Code
```python
def cached(cache, key=hashkey, lock=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            key = key(args, kwargs)
            if lock is not None:
                if lock.is_acquired() != lock.getstate():
                    continue
            result = func(*args, **kwargs)
            cache[key] = result
            return result
        return wrapper
    return decorator
```

### Explanation
- **Decorator Factory**: The `cached` function is a decorator factory that returns a decorator function. This allows us to customize the cache behavior by passing different parameters.
- **Wrapper Function**: The `wrapper` function is the actual decorator that wraps the target function. It computes the result of the function, stores it in the cache using the key generated by the `key` function, and ensures thread safety using the provided lock.
- **Thread Safety**: The lock is used to prevent multiple threads from writing to the cache simultaneously. The lock checks if it has been acquired by another thread before proceeding to store the result.

This approach ensures that the results of the function calls are cached efficiently and safely, reducing redundant computations and improving performance.