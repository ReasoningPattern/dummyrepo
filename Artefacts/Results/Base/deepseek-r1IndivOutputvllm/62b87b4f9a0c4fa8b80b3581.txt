

To solve this problem, we need to generate a Python method that scales a histogram based on the provided specifications. The method should be able to compute the scale (integral of the histogram) or rescale the histogram if a specific factor is provided. The scale must be non-zero, and if it is zero, a specific error should be raised. Additionally, if the scale has already been computed but is zero, the method should recompute it.

### Approach
1. **Compute Scale**: If the `other` parameter is `None`, the method will compute the scale of the histogram. The scale is computed as the sum of all bin values. If the scale is zero, a `LenaValueError` is raised.
2. **Rescale Histogram**: If a non-`None` value is provided for `other`, the method will rescale the histogram. Before rescaling, it ensures that the current scale is non-zero. If the scale is zero, a `LenaValueError` is raised. Each bin value is then updated by multiplying it with the provided factor and dividing by the current scale.
3. **Recompute Scale**: If `recompute` is `True`, the method recomputes the scale regardless of whether it was previously computed.

### Solution Code
```python
class Histogram:
    def __init__(self, bins):
        self.bins = bins
        self.scale = None  # Will store the computed scale

    def scale(self, other=None, recompute=False):
        """
        Compute or set scale (integral of the histogram).

        If *other* is ``None``, return scale of this histogram.
        If its scale was not computed before,
        it is computed and stored for subsequent use
        (unless explicitly asked to *recompute*).
        Note that after changing (filling) the histogram
        one must explicitly recompute the scale
        if it was computed before.

        If a float *other* is provided, rescale self to *other*.

        Histograms with scale equal to zero can't be rescaled.
        :exc:`.LenaValueError` is raised if one tries to do that.
        """
        if other is None:
            if recompute or self.scale is None:
                self.scale = sum(self.bins)
                if self.scale == 0:
                    raise LenaValueError("Scale cannot be zero")
            # Ensure scale is not zero after computation
            if self.scale == 0:
                raise LenaValueError("Scale cannot be zero")
            return self.scale
        else:
            if not isinstance(other, float):
                raise TypeError("Other must be a float")
            if self.scale == 0:
                raise LenaValueError("Cannot scale by zero")
            # Rescale each bin
            for i in range(len(self.bins)):
                self.bins[i] = self.bins[i] * other / self.scale
            return
```

### Explanation
- **Initialization**: The `Histogram` class is initialized with bin values, and an attribute `scale` is set to `None` to indicate that the scale has not been computed yet.
- **scale Method**: This method handles both computing and rescaling the histogram.
  - **Computing Scale**: When `other` is `None`, the method computes the scale as the sum of all bin values. If the scale is zero, a `LenaValueError` is raised. The computed scale is stored in the `scale` attribute.
  - **Rescaling**: If a non-`None` value is provided for `other`, the method checks if the current scale is zero (raises an error if it is) and then rescales each bin value by the provided factor.
  - **Recomputation**: If `recompute` is `True`, the method recomputes the scale regardless of whether it was previously computed.

This approach ensures that the histogram's scale is always non-zero and correctly handles both computing and rescaling operations efficiently.