
Okay, I need to generate Python code for the function make_find_paths based on the given signature and docstring. The function's purpose is to transform a sequence of paths into glob patterns, leaving existing patterns untouched. Let me think about how to approach this.

First, I should understand what "glob patterns" mean here. Glob patterns typically use wildcards like * (matches any sequence of characters), ? (matches any single character), and [set] (matches any character in the set). So the function needs to check if a path is already a glob pattern and leave it as is, otherwise convert it into a glob pattern.

Wait, but how do I determine if a path is already a glob pattern? Maybe by checking if it contains any of the glob special characters. For example, if a path has * or ? or [ in a way that indicates a pattern. However, there's a catch: some paths might have these characters but not be intended as glob patterns. But according to the problem statement, we should pass through existing patterns untouched. So the function should leave any path that already contains glob syntax as is, and convert others into glob patterns.

But how to convert a regular path into a glob pattern? For example, converting "file.txt" into "file.txt" (since it's already a literal), but maybe the function is supposed to add wildcards? Wait, no. Wait the docstring says "transform all path into glob patterns. Pass through existing patterns untouched." So if a path is already a glob pattern (like "file*.txt"), leave it. Otherwise, convert it into a glob pattern. But how?

Wait, perhaps the function is supposed to take a path and make it a glob pattern by adding wildcards. For example, converting "file.txt" into "file.txt" (since it's already a literal), but maybe the intention is to make it a pattern that matches exactly. But that's not a glob pattern. Hmm, maybe the function is supposed to convert paths into patterns that match exactly, but using glob syntax. For example, turning "file.txt" into "file.txt" (since it's already a literal), but if the path is "file", maybe convert it to "file*" to match any file name? Or maybe the function is supposed to add wildcards to the end? Or perhaps the function is supposed to convert paths into patterns that match exactly, but using glob syntax. But that's unclear.

Alternatively, maybe the function is supposed to take paths and convert them into glob patterns by replacing slashes with something? Or perhaps the function is intended to make paths into patterns that can be used with globbing, like adding wildcards. For example, turning "dir" into "dir/" to match directories, or adding * to match any files. But without more context, it's a bit ambiguous.

Wait, the docstring says "transform all path into glob patterns. Pass through existing patterns untouched." So the function's job is to take each path in the input sequence and turn it into a glob pattern. But how? For example, if the input is a normal path like "file.txt", how to convert it into a glob pattern? Well, perhaps the function is supposed to add wildcards to the end. For example, "file.txt" becomes "file.txt*", or maybe "file.txt" is already a glob pattern (since it's a literal). But that's not a glob pattern. Wait, maybe the function is supposed to make sure that each path is a glob pattern by adding * at the end. But that's just a guess.

Alternatively, maybe the function is supposed to convert paths into patterns that match exactly, but using glob syntax. For example, "file.txt" would be converted to "file.txt" (since it's already a literal), but if the path is "file", then it would be converted to "file*" to match any file with that name. But how to determine which paths are already glob patterns?

This is a bit confusing. Let me think again. The function's purpose is to transform paths into glob patterns. So, perhaps the function is supposed to take a path and make it a glob pattern by adding wildcards. For example, converting "file.txt" into "file.txt" (since it's already a literal), but maybe the function is supposed to add * at the end to make it a pattern that matches any file with that name. But how to decide?

Alternatively, perhaps the function is intended to convert paths into patterns that can be used with the glob module. For example, turning "file.txt" into "file.txt" (since it's a literal), but if the path is "file", then it's converted to "file*" to match any file starting with "file". But again, without more context, it's hard to know.

Wait, maybe the function is supposed to take a path and make it a glob pattern by replacing slashes with something? Or perhaps the function is supposed to add wildcards to the end of each path. For example, turning "dir" into "dir/*" to match all files in the directory. But again, this is speculative.

Alternatively, perhaps the function is supposed to check if the path already contains any glob characters (like *, ?, [), and if not, add wildcards. For example, if the path is "file.txt", then convert it to "file.txt*" to match any file that starts with "file.txt". But that's not standard. Or maybe the function is supposed to make sure that each path is a glob pattern by adding * at the end. But how to handle existing patterns?

Alternatively, maybe the function is supposed to convert paths into patterns that match exactly, but using glob syntax. For example, "file.txt" would be converted to "file.txt" (since it's already a literal), but if the path is "file", then it's converted to "file" (no change). But that doesn't make sense. Maybe the function is supposed to add wildcards to the end of each path to make them match any file with that name. For example, "file.txt" becomes "file.txt*", "file" becomes "file*".

But how to determine whether a path is already a glob pattern? For example, if a path is "file*", then it's already a glob pattern and should be left as is. So the function needs to check if the path contains any glob characters. But how to do that?

So the plan is: for each path in find_paths, check if it contains any glob characters (like *, ?, [). If it does, leave it as is. Otherwise, convert it into a glob pattern. But how to convert it? For example, adding * at the end? Or maybe adding * at the end and beginning? Or maybe converting it into a pattern that matches exactly, but using glob syntax. For example, turning "file.txt" into "file.txt" (since it's already a literal), but that's not a glob pattern. Wait, but maybe the function is supposed to make sure that each path is a glob pattern by adding * at the end. For example, "file.txt" becomes "file.txt*", "file" becomes "file*", etc. But then, if the path is already a glob pattern, like "file*", it's left as is.

But how to implement this? Let's think of the steps:

For each path in the input sequence:

1. Check if it's already a glob pattern. How? Check if it contains any of the glob special characters (*, ?, [). But need to be careful with cases like [a-z], which is a valid glob pattern. So the check would be: if any of the characters in the path are *, ?, or [ (but not part of an escape sequence, but assuming that the input paths are not escaped). But for simplicity, perhaps the function just checks if the path contains any of these characters. If yes, leave as is. If not, convert to a glob pattern.

But how to convert a normal path into a glob pattern? For example, turning "file.txt" into "file.txt*" to match any file that starts with "file.txt". Or maybe "file.txt" is already a glob pattern (since it's a literal), but that's not correct. Wait, in glob syntax, a literal path is a pattern that matches exactly. So "file.txt" is a valid glob pattern. So perhaps the function is supposed to leave it as is. But that would mean that the function does nothing. That can't be right.

Wait, maybe the function is intended to convert paths into patterns that can be used with the glob module. For example, if the path is a directory, maybe adding a trailing slash and a wildcard. But again, without more context, it's hard to know.

Alternatively, maybe the function is supposed to take paths and make them into patterns that match exactly, but using glob syntax. For example, converting "file.txt" into "file.txt" (since it's already a literal). But then, what's the purpose of the function? It would just return the same paths. That doesn't make sense.

Hmm, perhaps there's a misunderstanding here. Let me re-read the docstring.

The docstring says: "Given a sequence of path, transform all path into glob patterns. Pass through existing patterns untouched."

Ah, perhaps the function is supposed to take a path and convert it into a glob pattern, but if it's already a glob pattern, leave it. So for example, if the path is "file.txt", convert it into "file.txt" (which is already a glob pattern). But that's not a transformation. So perhaps the function is supposed to add wildcards to the end of the path to make it a pattern that matches any file with that name. For example, turning "file.txt" into "file.txt*" to match any file that starts with "file.txt". Or maybe adding * at the end to make it match any file with that name. But how to decide?

Alternatively, maybe the function is supposed to convert paths into patterns that match exactly, but using glob syntax. For example, "file.txt" becomes "file.txt", which is already a glob pattern. So the function would return the same paths. But that's not useful.

This is confusing. Maybe the function is supposed to take paths and convert them into patterns that can be used with the glob module, but in a way that ensures they are treated as glob patterns. For example, if the path is a directory, add a trailing slash and a wildcard. But again, without more context, it's hard to say.

Alternatively, perhaps the function is intended to convert paths into patterns that match exactly, but using glob syntax. For example, turning "file.txt" into "file.txt" (which is already a glob pattern), but if the path is "file", then it's converted to "file" (same as before). So the function does nothing. But that's not helpful.

Wait, perhaps the function is supposed to take paths and make them into glob patterns by adding * at the end. For example, "file.txt" becomes "file.txt*", "file" becomes "file*", etc. But then, if the path is already a glob pattern (like "file*"), it's left as is. So the function would check if the path contains any glob characters. If not, add * at the end. Otherwise, leave it.

But how to implement that. Let's think of code.

For each path in find_paths:

- Check if it contains any of the glob characters (*, ?, [). If yes, leave as is.

- Else, add * at the end.

But how to check for the presence of these characters. For example, the path could be "file[1].txt", which contains [ and is a glob pattern. So we leave it as is.

So the code would be:

def make_find_paths(find_paths):
    transformed = []
    for path in find_paths:
        if any(c in {'*', '?', '['} for c in path):
            transformed.append(path)
        else:
            transformed.append(path + '*')
    return tuple(transformed)

But wait, what about paths that end with a slash? Like "dir/". Adding * would make it "dir/*", which might be intended. But perhaps the function should not add * to directories. But without more context, it's hard to know.

Alternatively, maybe the function should add * to the end of each path to make it a pattern that matches any file with that name. But again, this is a guess.

But according to the docstring, the function is supposed to transform paths into glob patterns, leaving existing ones untouched. So the code I wrote above would do that. For example, if the input is ["file.txt", "file*", "dir/"], the output would be ["file.txt*", "file*", "dir/*"].

But maybe the function is supposed to add * at the end only if the path is not already a glob pattern. So that's what the code does.

But how to test this? Let's think of test cases.

Test case 1: input ["file.txt"] → output ["file.txt*"]

Test case 2: input ["file*", "dir/"] → output ["file*", "dir/*"]

Test case 3: input ["file?txt"] → output ["file?txt"]

But what about paths that contain [ but not as part of a glob? Like "file[1].txt" → it would be considered a glob pattern and left as is.

But maybe the function should also check for other glob patterns, like {a,b} or **. But the problem statement doesn't mention those, so perhaps we can assume that the glob patterns are those with *, ?, or [.

So the code seems plausible.

Now, the user wants the code generated, but also to follow a test-driven development approach, first generating comprehensive unit tests before writing the actual code.

So first, I need to write unit tests for the function.

Let me think of possible test cases.

Test case 1: input is empty → output is empty tuple.

Test case 2: input is ["file.txt"] → output is ["file.txt*"]

Test case 3: input is ["file*", "dir/"] → output is ["file*", "dir/*"]

Test case 4: input is ["file?txt", "file[1].txt"] → output is ["file?txt", "file[1].txt"]

Test case 5: input is ["file", "file.txt", "file*"] → output is ["file*", "file.txt*", "file*"]

Test case 6: input is ["file.txt/", "file.txt/*"] → output is ["file.txt/*", "file.txt/*"]

Test case 7: input is ["file[1].txt"] → output is ["file[1].txt"]

Test case 8: input is ["file", "file.txt", "file*"] → output is ["file*", "file.txt*", "file*"]

So the unit tests would cover these cases.

Now, the code would be written based on these tests.

But the user wants the code generated, and the output should be the code in Python markdown format, only the code, no explanations.

But the user also said to follow a test-driven approach, first generating comprehensive unit tests before writing the actual code. However, the user's instruction says to generate the code based on the function signature and docstring, and output only the code. So perhaps the user wants the code, not the tests. But the initial instruction says to generate the code based on the function signature and docstring, and the tips say to follow TDD, first generate tests then code.

But the user's final instruction says to output only the code generated, in python markdown format.

So perhaps the user wants the code, not the tests. But the initial instruction says to generate the code based on the function signature and docstring, and the tips say to follow TDD, but the user might not want the tests in the output.

So I think the user wants the code, not the tests. But the initial instruction says to generate the code based on the function signature and docstring, and the tips mention TDD, but the final output is only the code.

So I'll proceed to write the code.

But I need to make sure that the code correctly transforms the paths into glob patterns, leaving existing ones untouched.

So the code would be:

def make_find_paths(find_paths):
    """
    Given a sequence of path, transform all path into glob patterns. Pass through existing patterns untouched.

    Args:
        find_paths: sequence of path
    Returns:
        tuple of transformed path
    """
    transformed = []
    for path in find_paths:
        if any(c in {'*', '?', '['} for c in path):
            transformed.append(path)
        else:
            transformed.append(path + '*')
    return tuple(transformed)

But wait, what about paths that are empty? Or paths that contain other characters? For example, a path like "file" would become "file*".

But what if the path is a directory? Adding * might make it match files in the directory. But that's up to the function's design.

Another thing: the function should return a tuple of transformed paths. The code does that.

But what about paths that already end with *? Like "file*" → it's left as is.

Yes.

But what about paths that have other glob characters, like "file[1].txt" → it's left as is.

Yes.

So this code should satisfy the requirements.

But I need to make sure that the code is correct.

Another edge case: path is empty string → transformed to "*".

But perhaps that's acceptable.

So the code seems correct.
