
Okay, let's tackle this problem. The function is supposed to group files by XML filenames and return a dictionary. Let me think about what the parameters mean. The source is probably the directory or path where the files are located. Then, xmls is a list of XML filenames, and files is a list of all files. Wait, maybe the function is supposed to group the files (files) based on the XML filenames (xmls) from the source directory?

Wait, the function's docstring says it groups files by xmls and returns a dict. So maybe for each XML file in xmls, we need to collect related files. But how are the files related to the XMLs? Maybe each XML file has some associated files, and we need to group those files under each XML.

But the parameters are source, xmls, files. Maybe the source is the directory where these files are stored. So, for each XML file in xmls, we need to find all files in the source directory that are related to it. But how to determine the relationship? Maybe the files are named in a way that they are associated with the XMLs. For example, maybe each XML file has a corresponding data file, or maybe the files are grouped by the XML's name.

Alternatively, perhaps the function is supposed to group the files (files) into a dictionary where the keys are the XML filenames (from xmls) and the values are the corresponding files. But that would be straightforward. For example, if xmls is a list of XML filenames, and files is a list of all files, maybe we need to map each XML to its associated files. But how?

Wait, perhaps the function is part of a larger system where each XML file has some associated files. For example, maybe each XML file is in the source directory, and the files parameter includes all files in that directory. So the function needs to group the files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are related to that XML. But how to determine which files are related?

Alternatively, maybe the function is supposed to group the files (files) by their XML filename. For example, if the files are in the source directory, and each file has an XML filename associated with it. But without more context, it's a bit unclear.

Wait, the function's name is _group_files_by_xml_filename. So perhaps the idea is that for each XML filename in xmls, we group the files (files) that are associated with that XML. But how to determine that association?

Alternatively, maybe the files are in the source directory, and each file's name is related to an XML filename. For example, maybe the XML filenames are in xmls, and the files are those that are related to them. For example, if the XML files are named like 'data.xml', then the associated files might be 'data.txt' or something. But without knowing the exact relationship, it's hard to code.

But given that the user hasn't provided more details, perhaps we need to make some assumptions. Let me think of possible scenarios.

Scenario 1: The function is supposed to group all files (files) into a dictionary where each key is an XML filename from xmls, and the value is a list of files that have the same name as the XML file but with a different extension. For example, if xmls contains 'data.xml', then files that are 'data.txt' would be grouped under 'data.xml'.

Scenario 2: The function is supposed to group files based on their XML filename. For example, each file in files is associated with an XML file in xmls. Maybe the files are in the source directory, and each file's name is derived from the XML filename. For example, if the XML file is 'data.xml', then the associated file is 'data.xml' itself, but that seems redundant.

Alternatively, perhaps the function is supposed to group the files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are in the source directory and have the same base name as the XML file. For example, if xmls has 'data.xml', then files like 'data.xml' and 'data.txt' would be grouped under 'data.xml'.

But without more context, it's challenging. Let me think about the parameters again. The function is called _group_files_by_xml_filename, which suggests that the grouping is based on the XML filenames. So maybe for each XML filename in xmls, we need to collect all files (from the files list) that are related to it. But how?

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where the keys are the XML filenames (from xmls), and the values are the corresponding files. But if xmls is a list of XML filenames, and files is a list of all files, perhaps the function is supposed to map each XML filename to its corresponding file. But that would require that each XML filename in xmls has exactly one corresponding file in files.

But perhaps the function is supposed to group all files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are associated with that XML. For example, if the XML filename is 'data.xml', then the associated files could be 'data.xml' itself and any other files that are related, like 'data_config.xml' or 'data_output.xml'.

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where each key is the XML filename (from xmls), and the value is a list of files that have the same base name as the XML filename. For example, if the XML filename is 'data.xml', then the files with base name 'data' (like 'data.txt', 'data.csv') would be grouped under 'data.xml'.

But how to determine the relationship between the XML filenames and the files? Since the parameters are source, xmls, files, perhaps the source is the directory where these files are located, and the files are all the files in that directory. Then, for each XML filename in xmls, we need to find all files in the source directory that are related to it. But again, without knowing the relationship, it's hard to code.

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where the keys are the XML filenames (from xmls), and the value is a list of files that are in the source directory and have the same name as the XML filename. For example, if the XML filename is 'data.xml', then the file 'data.xml' would be grouped under that key.

But then, if xmls is a list of XML filenames, and files is a list of all files in the source directory, then for each XML in xmls, we check if it exists in files, and group it. But that would be a simple mapping.

But perhaps the function is supposed to group the files (files) into a dictionary where each key is the XML filename (from xmls), and the value is a list of files that are in the source directory and have the same base name as the XML filename. For example, if the XML filename is 'data.xml', then any file in the source directory with base name 'data' (like 'data.txt', 'data.json') would be grouped under 'data.xml'.

But again, without knowing the exact relationship, it's hard to proceed. However, given the function's name and parameters, perhaps the intended logic is that for each XML filename in xmls, we group all files (files) that are in the source directory and have the same base name as the XML filename. For example, if the XML filename is 'data.xml', then any file in the source directory with base name 'data' (like 'data.txt', 'data.csv') would be grouped under 'data.xml'.

But how to implement this? Let's think about the steps:

1. For each XML filename in xmls, extract the base name (without the extension). For example, 'data.xml' becomes 'data'.
2. For each file in files, extract its base name (without the extension).
3. Group the files by their base name, and then map each base name to the corresponding XML filename.

Wait, but that would group files by their base name, not by the XML filename. So if multiple XML files have the same base name, this approach would group all files with that base name under all XML filenames with that base name. But that might not be intended.

Alternatively, perhaps the function is supposed to group the files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are in the source directory and have the same name as the XML filename. For example, if the XML filename is 'data.xml', then the file 'data.xml' would be grouped under that key.

But then, if the same file is present in both xmls and files, it would be grouped. However, if the files list includes multiple files with the same name, that could be an issue.

Alternatively, perhaps the function is supposed to group the files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are in the source directory and have the same name as the XML filename. But how to determine that? For example, if the source is a directory, then the files in files are the files in that directory. So for each XML filename in xmls, check if it exists in the files list, and group it.

But that would be a simple mapping. However, the function's parameters include 'source', which is not used in this approach. So perhaps the source is used to determine the files. For example, maybe the files are all the files in the source directory, and the xmls are the XML files in that directory. Then, the function is supposed to group the files (files) into a dictionary where each key is an XML filename (from xmls), and the value is a list of files that are in the source directory and are associated with that XML.

But again, without knowing the association, it's hard to proceed. Maybe the function is part of a system where each XML file has associated files, and the files parameter is a list of all files in the source directory. The function is supposed to group those files into a dictionary where each key is an XML filename, and the value is a list of files that are related to that XML. For example, if the XML file is 'data.xml', then the associated files could be 'data.txt', 'data.csv', etc.

But how to determine which files are associated with which XML? Maybe the associated files have the same base name as the XML filename. So for each XML filename in xmls, we look for all files in the source directory with the same base name. For example, if the XML filename is 'data.xml', then files like 'data.txt', 'data.json' would be grouped under 'data.xml'.

In that case, the function would:

- For each XML filename in xmls:
   - Extract the base name (without the extension)
   - Find all files in the source directory (files) that have the same base name
   - Group those files under the XML filename in the result dictionary.

But how to get the files in the source directory? The 'files' parameter is passed as a list, so perhaps it's already the list of files in the source directory. So the function is supposed to group those files into a dictionary based on their base names, but using the XML filenames as keys.

Wait, that seems conflicting. If the files are in the source directory, and the XML filenames are in xmls, then perhaps the function is supposed to group the files (files) into a dictionary where each key is an XML filename, and the value is a list of files that have the same base name as the XML filename.

But that would require that each XML filename in xmls has a corresponding base name, and the files list contains files with that base name.

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where each key is the base name of the XML filename (from xmls), and the value is a list of files in the source directory with that base name. But then the key would be the base name, not the XML filename.

But the function's name is _group_files_by_xml_filename, so the keys should be the XML filenames.

This is getting a bit stuck. Let's think of possible test cases.

Test case 1: xmls = ['data.xml'], files = ['data.xml', 'data.txt']

The expected output would be {'data.xml': ['data.xml', 'data.txt']} ?

Or perhaps, the function is supposed to group the files (files) into a dictionary where each key is an XML filename, and the value is a list of files that are in the source directory and are associated with that XML. For example, if the XML filename is 'data.xml', then the associated files are 'data.xml' and 'data.txt'.

But how to determine the association? Maybe the associated files are those that have the same base name as the XML filename. So for 'data.xml', the base name is 'data', and any file in the source directory with base name 'data' would be grouped under 'data.xml'.

In that case, the function would group all files with base name 'data' under the key 'data.xml'.

But then, if there are multiple XML filenames with the same base name, like 'data.xml' and 'data2.xml', then files with base name 'data' would be grouped under 'data.xml', and files with base name 'data2' would be grouped under 'data2.xml'.

So the function would:

- For each XML filename in xmls:
   - Extract the base name (without the extension)
   - Find all files in the files list that have the same base name
   - Add those files to the dictionary under the XML filename as the key.

But how to extract the base name? For example, for 'data.xml', the base name is 'data'. For 'data.txt', the base name is 'data'.

So the code would need to process each XML filename to get its base name, then for each file in files, get its base name, and group them.

But then, the function would return a dictionary where each key is an XML filename, and the value is a list of files (from files) that have the same base name as the XML filename.

But how to handle files that have the same base name as multiple XML filenames? For example, if there are two XML filenames 'data.xml' and 'data2.xml', and a file 'data.txt', then 'data.txt' would be grouped under both 'data.xml' and 'data2.xml'? Or only under 'data.xml'?

This depends on the logic. But perhaps the function is supposed to group each file under all XML filenames that have the same base name as the file. But that would result in multiple entries for the same file.

Alternatively, maybe the function is supposed to group each file under the first XML filename that has the same base name as the file. Or perhaps it's supposed to group all files under all XML filenames that have the same base name as the file.

But without more context, it's challenging. Let's proceed with the assumption that for each XML filename in xmls, we group all files in files that have the same base name as the XML filename. So the key is the XML filename, and the value is the list of files with the same base name.

So the code would:

- Initialize an empty dictionary.
- For each xml in xmls:
   - Get the base name of xml (without extension)
   - Find all files in files that have the same base name
   - Add to the dictionary: key is xml, value is the list of files
- Return the dictionary.

But how to get the base name? For example, for a filename like 'data.xml', the base name is 'data'. So we can split on the last '.'.

But what if the filename has multiple dots, like 'data.version.xml'? Then splitting on the last '.' would give 'data.version' as the base name.

So the code for getting the base name would be something like:

base_name = os.path.splitext(xml)[0]

Then, for each file in files, we do the same.

So, the function would group files by their base name, but using the XML filenames as keys.

But then, if two XML filenames have the same base name, they would both have the same list of files. For example, if xmls is ['data.xml', 'data2.xml'], and files has 'data.txt', then both 'data.xml' and 'data2.xml' would have 'data.txt' in their lists. But that's probably not intended.

Alternatively, perhaps the function is supposed to group files by their base name, and the XML filenames are just the keys. But that doesn't make sense.

Alternatively, maybe the function is supposed to group the files into a dictionary where the keys are the base names of the XML filenames, and the values are the list of files with that base name. But then the function's name would be misleading.

Hmm. This is a bit of a dead end. Maybe I should think about the parameters again. The function is called _group_files_by_xml_filename, which suggests that the grouping is based on the XML filenames. So perhaps the function is supposed to group the files (files) into a dictionary where each key is an XML filename, and the value is a list of files that are associated with that XML. But how?

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where each key is the XML filename, and the value is a list of files that are in the source directory and have the same name as the XML filename. For example, if the XML filename is 'data.xml', then the file 'data.xml' is grouped under that key.

In that case, the code would:

- Initialize an empty dictionary.
- For each xml in xmls:
   - Check if the xml exists in files (i.e., if it's present in the files list)
   - If yes, add it to the dictionary with the key as xml and value as a list containing the file
   - If not, maybe add an empty list or skip?

But how to check if the file exists in files? Because files is a list of filenames, perhaps the function is supposed to assume that each XML filename in xmls is present in the files list. Or maybe not.

Alternatively, the function could be intended to group all files into a dictionary where the keys are the XML filenames, and the values are the files that are in the source directory and have the same name as the XML filename. But that would require that each XML filename in xmls is present in the files list.

But this seems too simplistic. Let's think of a possible test case.

Test case 1:

source = '/path/to/source'
xmls = ['data.xml', 'info.xml']
files = ['data.xml', 'info.xml', 'data.txt', 'info.txt']

Expected output: {'data.xml': ['data.xml'], 'info.xml': ['info.xml']} ?

Or maybe the function is supposed to group all files that are in the source directory and have the same name as the XML filenames. So for each XML filename in xmls, if it exists in the files list, it's grouped under that key. But what about other files?

But the function's name suggests that it's grouping files by XML filenames, which implies that the XML filenames are the keys, and the grouped files are the values.

Alternatively, maybe the function is supposed to group the files (files) into a dictionary where each key is an XML filename, and the value is a list of files that are in the source directory and are associated with that XML. For example, if the XML file is 'data.xml', then the associated files could be 'data.xml' and 'data_config.xml'.

But again, without knowing the association, it's hard to code.

At this point, perhaps the best approach is to make an assumption and proceed. Let's assume that the function is supposed to group all files (files) into a dictionary where each key is an XML filename from xmls, and the value is a list of files that have the same base name as the XML filename. This would mean that for each XML filename in xmls, we look for all files in the files list with the same base name and group them under that XML filename.

So, the code would:

- For each xml in xmls:
   - Get the base name (without extension)
   - Find all files in files with the same base name
   - Add to the dictionary: key is xml, value is the list of files

But how to handle files that have the same base name as multiple XML filenames? For example, if there are two XML filenames 'data.xml' and 'data2.xml', and a file 'data.txt', then 'data.txt' would be grouped under both 'data.xml' and 'data2.xml'.

But perhaps that's acceptable.

Now, let's think about the code. We need to process each XML filename in xmls, get their base names, and then group the files.

In Python, to get the base name without the extension, we can use os.path.splitext. For example:

import os

xml_base = os.path.splitext(xml)[0]

Then, for each file in files, we do the same:

file_base = os.path.splitext(file)[0]

If xml_base == file_base, then the file is grouped under the XML filename.

So, the code would look like:

def _group_files_by_xml_filename(source, xmls, files):
    grouped = {}
    for xml in xmls:
        xml_base = os.path.splitext(xml)[0]
        grouped_files = []
        for file in files:
            file_base = os.path.splitext(file)[0]
            if file_base == xml_base:
                grouped_files.append(file)
        grouped[xml] = grouped_files
    return grouped

But wait, this would group all files with the same base name as the XML filename under that XML. However, if there are multiple XML filenames with the same base name, they would all have the same list of files.

For example, if xmls is ['data.xml', 'data2.xml'], and files has 'data.txt', then both 'data.xml' and 'data2.xml' would have 'data.txt' in their lists.

But that might not be intended. However, given the lack of more information, this seems like a plausible approach.

Now, let's think about the test cases.

Test case 1:

xmls = ['data.xml', 'info.xml']
files = ['data.xml', 'info.xml', 'data.txt', 'info.txt']

Expected output: {'data.xml': ['data.xml', 'data.txt'], 'info.xml': ['info.xml', 'info.txt']}

Test case 2:

xmls = ['data.xml']
files = ['data.txt', 'data.xml', 'other.txt']

Expected output: {'data.xml': ['data.xml', 'data.txt']}

Test case 3:

xmls = ['data.xml', 'data2.xml']
files = ['data.txt', 'data2.txt']

Expected output: {'data.xml': ['data.txt'], 'data2.xml': ['data2.txt']}

But in this case, the files 'data.txt' and 'data2.txt' have base names 'data' and 'data2', respectively. So each XML filename would group their respective files.

This seems to make sense.

Now, the function's parameters include 'source', but in the code above, it's not used. That's a problem. The 'source' parameter is part of the function's parameters, but in the current code, it's not used. So why is it there?

Ah, perhaps the 'source' is used to determine the files. For example, maybe the 'files' parameter is not provided, and the function is supposed to read all files from the source directory. But in the current function signature, 'files' is a parameter, so perhaps the 'source' is not used. This is confusing.

Wait, the function signature is:

def _group_files_by_xml_filename(source, xmls, files):

So, the parameters are source, xmls, and files. But in the code I wrote earlier, the 'source' is not used. That's a problem. So perhaps the 'source' is used to determine the files, but the 'files' parameter is already provided. This is conflicting.

Maybe the 'source' is the directory path, and the 'files' is a list of files in that directory. But the function is supposed to group those files by the XML filenames in xmls. But how?

Alternatively, maybe the 'source' is not used, and the 'files' parameter is the list of files to group. But then why include 'source' as a parameter?

This is unclear. Given the ambiguity, perhaps the 'source' parameter is not used in the function, and the 'files' is the list of files to group. But that seems odd. Maybe the 'source' is used to determine the files, but the 'files' parameter is already provided, which would be redundant.

Alternatively, perhaps the 'source' is the directory path, and the 'files' is a list of files in that directory, and the function is supposed to group those files by the XML filenames in xmls. But again, without knowing how the XML filenames relate to the files, it's unclear.

At this point, perhaps the 'source' parameter is not used in the function, and the 'files' parameter is the list of files to group. So the function's code would proceed as before, ignoring 'source'.

But that seems odd. However, given the lack of information, perhaps that's the way to proceed.

Alternatively, maybe the 'source' is used to determine the files. For example, the function is supposed to read all files from the source directory, and then group them by XML filenames in xmls. But in that case, the 'files' parameter would be redundant. So perhaps the function is supposed to read files from the source directory, and the 'files' parameter is not used. But that would contradict the function signature.

This is a problem. Given the ambiguity, perhaps the 'source' parameter is not used, and the 'files' is the list of files to group. So the code proceeds as before.

But the user might have intended for the 'source' to be used. For example, maybe the 'files' is a list of files in the source directory, and the function is supposed to group them based on their XML filenames. But again, without knowing the relationship, it's hard to proceed.

Given the time I've spent and the need to proceed, I'll proceed with the code that groups files by their base name matching the XML filenames, ignoring the 'source' parameter. However, this might not be correct, but given the information, it's the best I can do.

Now, writing the code with the assumption that 'source' is not used, and the function groups files by their base name matching the XML filenames.

Now, the unit tests. Let's think of test cases.

Test case 1:

source = '/path/to/source'
xmls = ['data.xml', 'info.xml']
files = ['data.xml', 'info.xml', 'data.txt', 'info.txt']
expected = {'data.xml': ['data.xml', 'data.txt'], 'info.xml': ['info.xml', 'info.txt']}

Test case 2:

source = '/path/to/source'
xmls = ['data.xml']
files = ['data.txt', 'data.xml', 'other.txt']
expected = {'data.xml': ['data.xml', 'data.txt']}

Test case 3:

source = '/path/to/source'
xmls = ['data.xml', 'data2.xml']
files = ['data.txt', 'data2.txt']
expected = {'data.xml': ['data.txt'], 'data2.xml': ['data2.txt']}

Test case 4:

source = '/path/to/source'
xmls = ['data.xml']
files = ['data.txt', 'data.xml', 'data2.txt']
expected = {'data.xml': ['data.xml', 'data.txt']}

Test case 5:

source = '/path/to/source'
xmls = ['data.xml']
files = ['data2.txt', 'data.txt']
expected = {'data.xml': ['data.txt']}

Now, the code would pass these tests.

But what if a file has a base name that matches multiple XML filenames? For example, xmls = ['data.xml', 'data2.xml'], files = ['data.txt', 'data2.txt']. Then, 'data.txt' would be grouped under 'data.xml', and 'data2.txt' under 'data2.xml'.

But what if a file's base name matches none of the XML filenames? It would not be included in the dictionary.

So the code would return a dictionary with keys as the XML filenames, and values as the list of files with matching base names.

Now, the code for the function:

import os

def _group_files_by_xml_filename(source, xmls, files):
    grouped = {}
    for xml in xmls:
        xml_base = os.path.splitext(xml)[0]
        grouped_files = []
        for file in files:
            file_base = os.path.splitext(file)[0]
            if file_base == xml_base:
                grouped_files.append(file)
        grouped[xml] = grouped_files
    return grouped

But wait, the 'source' parameter is not used. So perhaps the 'source' is supposed to be used to determine the files. For example, maybe the 'files' parameter is not provided, and the function is supposed to read all files from the source directory. But in the current function signature, 'files' is a parameter, so that's not the case.

Alternatively, maybe the 'source' is used to determine the files, and the 'files' parameter is not used. But that would be a problem because the 'files' parameter is part of the function signature.

This is a problem. Given that, perhaps the 'source' is not used, and the 'files' is the list of files to group. So the code proceeds as above.

Now, writing the unit tests. Let's think about how to test this function.

For example:

import os
import unittest

class TestGroupFilesByXmlFilename(unittest.TestCase):
    def test_group_files_by_xml_filename(self):
        # Test case 1
        xmls = ['data.xml', 'info.xml']
        files = ['data.xml', 'info.xml', 'data.txt', 'info.txt']
        expected = {
            'data.xml': ['data.xml', 'data.txt'],
            'info.xml': ['info.xml', 'info.txt']
        }
        result = _group_files_by_xml_filename(None, xmls, files)
        self.assertEqual(result, expected)

        # Test case 2
        xmls = ['data.xml']
        files = ['data.txt', 'data.xml', 'other.txt']
        expected = {'data.xml': ['data.xml', 'data.txt']}
        result = _group_files_by_xml_filename(None, xmls, files)
        self.assertEqual(result, expected)

        # Test case 3
        xmls = ['data.xml', 'data2.xml']
        files = ['data.txt', 'data2.txt']
        expected = {
            'data.xml': ['data.txt'],
            'data2.xml': ['data2.txt']
        }
        result = _group_files_by_xml_filename(None, xmls, files)
        self.assertEqual(result, expected)

        # Test case 4: file not in xmls
        xmls = ['data.xml']
        files = ['data.txt', 'data.xml', 'data2.txt']
        expected = {'data.xml': ['data.xml', 'data.txt']}
        result = _group_files_by_xml_filename(None, xmls, files)
        self.assertEqual(result, expected)

        # Test case 5: no matching files
        xmls = ['data.xml']
        files = ['other.txt']
        expected = {'data.xml': []}
        result = _group_files_by_xml_filename(None, xmls, files)
        self.assertEqual(result, expected)

if __name__ == '__main__':
    unittest.main()

But the 'source' parameter is not used in the function. So in the tests, we pass None for source.

But the function's parameters include 'source', which is not used. This might be an error. But given the lack of information, it's the best we can do.

So the final code is as above, with the function and the unit tests.

But the user asked to generate the code based on the function signature and docstring, and to output only the code in Python markdown format. So the code should be the function with the docstring, and the unit tests.

But the user said to generate the code based on the function signature and docstring. The docstring says "Groups files by xmls and returns data in dict format." So the function's code should implement that.

So the final code would be:

import os

def _group_files_by_xml_filename(source, xmls, files):
    """
    Groups files by xmls and returns data in dict format.
    """
    grouped = {}
    for xml in xmls:
        xml_base = os.path.splitext(xml)[0]
        grouped_files = []
        for file in files:
            file_base = os.path.splitext(file)[0]
            if file_base == xml_base:
                grouped_files.append(file)
        grouped[xml] = grouped_files
    return grouped

But the 'source' parameter is not used. However, the user's function signature includes it, so it's part of the function. So the code is as above.

Now, the user also mentioned to follow a test-driven development approach, first generating comprehensive unit tests before writing the actual code. So I should generate the unit tests first.

But the user's instruction says to generate the code based on the function signature and docstring, and output only the code. However, the initial instruction says to generate the code based on the function signature and docstring, and to output only the code, but the tips say to follow TDD, first generating unit tests.

But the user's final instruction says to output only the code generated, in python markdown format. So perhaps the code should include the function with the docstring and the unit tests.

But the user might expect the code to be the function, not the tests. However, the initial instruction says to generate the code based on the function signature and docstring, which includes writing the function.

But the user also provided the tips to follow TDD, first generating unit tests. So perhaps the answer should include the unit tests and the function.

But the user says to output only the code generated, in python markdown format. So the code should be the function, not the tests. However, the initial instruction says to generate the code based on the function signature and docstring, which is the function itself.

So the final answer is the function code as above.
