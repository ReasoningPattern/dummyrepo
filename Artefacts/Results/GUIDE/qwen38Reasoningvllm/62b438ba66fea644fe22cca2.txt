
Okay, I need to generate Python code for the deep_merge_nodes function based on the given docstring. Let me start by understanding the problem. The function is supposed to merge nodes, which I assume are some kind of data structures, possibly dictionaries or custom objects. The docstring says to merge any node values corresponding to duplicate keys. If there are colliding keys with non-MappingNode values, the last one remains.

First, I need to figure out what a "node" is here. Since the function is called deep_merge_nodes, maybe nodes are nested structures. The term "MappingNode" is mentioned, which might imply that nodes are mappings (like dictionaries) and can have nested mappings. So, the function needs to recursively merge these nested mappings.

Wait, the docstring says "If there are colliding keys with non-MappingNode values, the last of the values remains." So, when two nodes have the same key, if the values are not MappingNodes (like lists, strings, etc.), the last one in the list of nodes takes precedence. But if they are MappingNodes, then they should be merged recursively.

So the approach would be: iterate through each node in the nodes list. For each key in the node, check if it's already present in the result. If it is, check if the existing value and the new value are both MappingNodes. If they are, merge them recursively. If not, the last one wins. If the key isn't present, add it.

But how to represent the nodes? Are they dictionaries? Let me assume that nodes are dictionaries, and "MappingNode" refers to a dictionary. So, the function needs to merge a list of dictionaries, recursively merging nested dictionaries.

Wait, but the function is called deep_merge_nodes, which suggests that the nodes are part of a tree structure. Maybe each node is a dictionary, and the function merges all the nodes into one, combining nested dictionaries.

So, the steps for the function:

1. Initialize a result dictionary.
2. Iterate over each node in the nodes list.
3. For each key-value pair in the current node:
   a. If the key is already in the result:
      i. Check if both the existing value and the new value are dictionaries (MappingNodes).
      ii. If yes, recursively merge them.
      iii. If not, the new value replaces the existing one (since the last one wins).
   b. If the key is not in the result, add it.
4. Return the merged dictionary.

Wait, but the function is supposed to merge "any node values corresponding to duplicate keys". So, for each key in all nodes, combine their values. But how to handle multiple nodes with the same key? For example, if three nodes have the same key, how to merge them? The docstring says that if there are colliding keys with non-MappingNode values, the last one remains. So, for multiple nodes with the same key, the last one in the list of nodes takes precedence, but if they are MappingNodes, they are merged.

Wait, perhaps the function is supposed to merge all nodes into a single structure, where for each key, if the value is a MappingNode (like a dict), then merge them recursively. Otherwise, take the last occurrence.

So, for example, if nodes are [ {'a': 1}, {'a': 2}, {'a': {'b': 3}} ], then the merged result would be {'a': {'b': 3}} because the last node's value is a dict, and it's merged. But if the last node's value is not a dict, like {'a': 5}, then the merged value would be 5.

Wait, but how to handle multiple nodes with the same key. Suppose nodes are [ {'a': 1}, {'a': 2}, {'a': 3} ] — then the merged result would be 3, since it's the last one. But if the nodes are [ {'a': 1}, {'a': {'b': 2}}, {'a': 3} ] — then the first two nodes have 'a' as a key. The first is a non-MappingNode (integer), the second is a MappingNode (dict). So, how to merge them? The docstring says that if there are colliding keys with non-MappingNode values, the last one remains. So, in this case, the first node's value is 1 (non-MappingNode), the second is a dict. So, when merging, since the second is a MappingNode, we need to merge them. But the first is not. So perhaps the merging process is: for each key, collect all values from all nodes, and then merge them according to the rules.

Alternatively, maybe the function is supposed to merge all the nodes into a single structure, where for each key, if the value is a MappingNode (like a dict), then merge them recursively. Otherwise, take the last occurrence.

So, the merging process would be similar to the standard Python dictionary merge, but with deep merging for nested dictionaries.

But how to implement this?

Let me think of the standard approach for deep merging dictionaries. For example, the 'deepmerge' library does this. But since the user wants to implement this from scratch.

So, the function deep_merge_nodes takes a list of nodes (which are dictionaries), and merges them into one dictionary. For each key in the nodes, if the key is present in multiple nodes, then:

- If the values are both dictionaries, merge them recursively.
- If one is a dictionary and the other is not, the dictionary takes precedence (since the last one is kept? Or perhaps the non-dictionary is merged into the dictionary? Or maybe the last one is kept regardless? The docstring says that if there are colliding keys with non-MappingNode values, the last of the values remains. So, if the existing value is a non-MappingNode and the new value is also a non-MappingNode, the last one wins. If one is a MappingNode and the other is not, then the MappingNode is merged into the existing value? Or the non-MappingNode is replaced by the MappingNode? Or perhaps the MappingNode is merged into the existing value?

Wait, the docstring says: "merge any node values corresponding to duplicate keys and return the result. If there are colliding keys with non-MappingNode values, the last of the values remains."

So, for colliding keys, if the values are non-MappingNode (like integers, strings, etc.), the last one remains. But if one or both are MappingNodes, then they are merged. So, for example:

If two nodes have the same key, and both values are MappingNodes, then merge them. If one is a MappingNode and the other is not, then the MappingNode is merged into the existing value? Or the non-MappingNode is replaced by the MappingNode? Or perhaps the non-MappingNode is treated as a MappingNode? Or maybe the non-MappingNode is kept, and the MappingNode is merged into it? Or perhaps the MappingNode is merged into the existing value, but if the existing value is not a MappingNode, then it's replaced by the MappingNode?

This is a bit ambiguous. Let me think of an example.

Suppose node1 is {'a': 1}, node2 is {'a': {'b': 2}}. So, the key 'a' is present in both. The first value is a non-MappingNode (integer), the second is a MappingNode (dict). How to merge them?

According to the docstring, since the existing value (from node1) is a non-MappingNode and the new value (from node2) is a MappingNode, then the colliding key has non-MappingNode values? Wait, no. The existing value is non-MappingNode, and the new value is a MappingNode. So, the colliding keys have one non-MappingNode and one MappingNode. The docstring says "If there are colliding keys with non-MappingNode values, the last of the values remains." So, perhaps the rule is: if both values are non-MappingNodes, the last one remains. If one is a MappingNode, then merge them. Wait, but how?

Alternatively, perhaps the rule is: for each key, collect all the values from all nodes. Then, if any of the values is a MappingNode, then merge them recursively. Otherwise, take the last one.

But that's not clear. Maybe the function is supposed to merge all nodes, and for each key, if the value is a MappingNode (like a dict), then merge them recursively. Otherwise, take the last occurrence.

So, for example:

If nodes are [{'a': 1}, {'a': 2}, {'a': {'b': 3}}], then the merged result would be {'a': {'b': 3}}, since the last node's value is a MappingNode, and the previous ones are non-MappingNodes. But how to handle merging when there are multiple MappingNodes?

Alternatively, perhaps the function is supposed to merge all nodes, and for each key, if the value is a MappingNode (dict), then merge them recursively. Otherwise, take the last occurrence.

So, the merging process would be:

Initialize the result as an empty dict.

For each node in the nodes list:

   For each key in the node:

      if the key is already in the result:

          if the existing value is a dict and the new value is a dict:

              merge them recursively

          else:

              the new value replaces the existing one (since it's the last one)

      else:

          add the key-value pair to the result.

But this approach would only handle the case where the existing value is a dict. What if the existing value is not a dict, but the new value is a dict? For example, existing value is 1 (non-dict), new value is {'b': 2} (dict). According to the docstring, since the existing value is non-MappingNode and the new value is a MappingNode, how to handle it? The docstring says that if there are colliding keys with non-MappingNode values, the last one remains. So, if the existing value is non-MappingNode and the new value is a MappingNode, then the new value is a MappingNode, so we should merge them? Or replace the existing value with the new value?

This is unclear. Let me re-read the docstring:

"merge any node values corresponding to duplicate keys and return the result. If there are colliding keys with non-MappingNode values, the last of the values remains."

So, the merging is done for duplicate keys. For colliding keys, if the values are non-MappingNode, the last one remains. If the values are MappingNode, then they are merged. So, for example:

If two nodes have the same key, and both values are non-MappingNode, then the last one wins. If one is a MappingNode and the other is not, then the non-MappingNode is considered as a non-MappingNode, so the last one remains. Wait, no. Because if one is a MappingNode and the other is not, then the colliding keys have one MappingNode and one non-MappingNode. So, according to the docstring, the rule applies only when there are colliding keys with non-MappingNode values. So, if one is a MappingNode, then the merging is done.

Wait, the wording is: "If there are colliding keys with non-MappingNode values, the last of the values remains." So, the condition is that both values are non-MappingNode. If one or both are MappingNodes, then they are merged. So, the merging process is:

For each key:

   collect all values from all nodes.

   if all values are non-MappingNode, then take the last one.

   else, merge them recursively.

But how to implement this?

Alternatively, perhaps the merging is done as follows:

For each key in the nodes, the merged value is determined by:

- If the key is present in multiple nodes:

   if any of the values is a MappingNode, then merge all the MappingNodes recursively, and if there are non-MappingNode values, they are merged into the MappingNode (or perhaps the last one is kept?).

This is getting complicated. Maybe I should look for an example.

Let's say nodes are:

node1 = {'a': 1}

node2 = {'a': 2}

node3 = {'a': {'b': 3}}

So, the keys are all 'a'. The values are 1, 2, and {'b': 3}.

According to the docstring, since the first two are non-MappingNodes, the last one (node3's value) is a MappingNode. So, how to merge them?

The docstring says that for colliding keys with non-MappingNode values, the last one remains. But here, the third value is a MappingNode. So, perhaps the rule is that if any of the values is a MappingNode, then we merge them. Otherwise, take the last one.

In this case, since there's a MappingNode (node3's value), we need to merge the previous values into it. But how?

Alternatively, perhaps the merging is done by checking if the existing value is a MappingNode. For example, when merging, if the existing value is a MappingNode and the new value is also a MappingNode, merge them. If the existing is a MappingNode and the new is not, then the new value replaces the existing. If the existing is not a MappingNode and the new is a MappingNode, then replace the existing with the new value. If both are not MappingNodes, take the last one.

Wait, but that's not correct. For example, if existing is a non-MappingNode and new is a MappingNode, then the new value is a MappingNode, so we should replace the existing with the new value. But if the existing is a MappingNode and the new is a non-MappingNode, then the new value replaces the existing.

But how to handle multiple nodes with the same key. For example, nodes are [{'a': 1}, {'a': 2}, {'a': {'b': 3}}]. The first two are non-MappingNodes, the third is a MappingNode. So, the merged value would be {'a': {'b': 3}}?

But what if there are multiple MappingNodes? Like nodes [{'a': {'b': 1}}, {'a': {'b': 2}}, {'a': {'c': 3}}]. Then, the merged value would be {'a': {'b': 2, 'c': 3}}.

So, the approach is: for each key, collect all the values from all nodes. Then, if any of the values is a MappingNode, then merge them. Otherwise, take the last one.

But how to implement this?

Another approach: the function should recursively merge all the nodes. For each key, if the value is a MappingNode (dict), then merge it with the existing value. Otherwise, take the last one.

So, the algorithm would be:

def deep_merge_nodes(nodes):
    result = {}
    for node in nodes:
        for key, value in node.items():
            if key in result:
                # Check if both are MappingNodes
                if isinstance(result[key], dict) and isinstance(value, dict):
                    # Merge recursively
                    result[key] = deep_merge_nodes([result[key], value])
                else:
                    # Take the last one
                    result[key] = value
            else:
                result[key] = value
    return result

Wait, but this code is not correct. Because the function is supposed to merge all nodes, not just the current node. For example, if there are multiple nodes with the same key, each subsequent node's value is merged into the result. But the code above would process each node in sequence, and for each key in the node, check if it's in the result. If so, merge if both are dicts, else replace.

But this approach would not handle cases where the existing value is a dict and the new value is not. For example, existing value is {'a': 1}, new value is 2. Then, since the existing is a dict and the new is not, the code would replace the existing with 2. But according to the docstring, if there are colliding keys with non-MappingNode values, the last one remains. Wait, in this case, the existing is a dict (MappingNode), and the new is a non-MappingNode. So, according to the docstring, since the colliding key has a non-MappingNode value (the new one), then the last one remains. But the existing is a MappingNode. So, how to handle that?

The docstring says that if there are colliding keys with non-MappingNode values, the last one remains. So, the rule is: if both values are non-MappingNodes, take the last. If one or both are MappingNodes, merge them.

So, the code should check if either value is a MappingNode. If so, merge. Otherwise, take the last one.

But how to implement that. For example:

If existing is a dict (MappingNode) and new is not, then since the new is not a MappingNode, we should merge them? Or replace the existing with the new?

The docstring says that if there are colliding keys with non-MappingNode values, the last one remains. So, in this case, the existing is a MappingNode (so it's a MappingNode), and the new is a non-MappingNode. So, the colliding keys have one MappingNode and one non-MappingNode. Therefore, the rule does not apply. So, we need to merge them. But how?

This is getting complicated. Perhaps the correct approach is:

For each key, collect all the values from all nodes. Then:

- If all values are non-MappingNodes, take the last one.

- Else, merge them recursively. For merging, if both are dicts, merge them. If one is a dict and the other is not, replace the non-dict with the dict. Or maybe the dict takes precedence?

Alternatively, the merging process is similar to the standard Python dictionary merge, but with deep merging. For example, when merging two dictionaries, for each key, if both are present, merge them. If one is present, take it. But for nested dictionaries, merge recursively.

But how to handle the case where one value is a dict and the other is not. For example, existing value is {'a': 1}, new value is 2. How to merge them? According to the docstring, since the new value is a non-MappingNode, and the existing is a MappingNode, then the colliding keys have one MappingNode and one non-MappingNode. So, the rule does not apply. Therefore, we need to merge them. But how?

This is unclear. Perhaps the function is intended to merge all nodes into a single dictionary, where for each key, if the value is a dict, merge it with the existing value. Otherwise, take the last one.

So, the code would be:

def deep_merge_nodes(nodes):
    result = {}
    for node in nodes:
        for key, value in node.items():
            if key in result:
                if isinstance(result[key], dict) and isinstance(value, dict):
                    # Merge recursively
                    result[key] = deep_merge_nodes([result[key], value])
                else:
                    # Take the last one
                    result[key] = value
            else:
                result[key] = value
    return result

But this code is not correct. Because the function is supposed to merge all nodes, not just the current node. For example, if there are three nodes with the same key, the code would process each node in order, and for each key, if it's already in the result, merge if both are dicts, else replace. But this would only handle merging between the current node and the existing result. However, the function is supposed to merge all nodes, so perhaps the code should process all nodes in sequence, merging each into the result.

But this code would work for the case where the nodes are processed in order, and each node's keys are merged into the result. However, this approach would not handle cases where a later node has a key that was previously merged with a dict, and then another node adds a new key to that dict.

Wait, let's take an example:

nodes = [{'a': {'b': 1}}, {'a': {'c': 2}}, {'a': {'d': 3}}]

The code would process the first node, adding 'a' with {'b': 1}. Then the second node has 'a' with {'c': 2}. Since both are dicts, it would merge them into {'b': 1, 'c': 2}. Then the third node has 'a' with {'d': 3}, which is a dict. So, merge the existing {'b': 1, 'c': 2} with {'d': 3} to get {'b': 1, 'c': 2, 'd': 3}.

That seems correct.

Another example: nodes = [{'a': 1}, {'a': 2}, {'a': {'b': 3}}]. The code would process the first node, add 'a' as 1. Then the second node has 'a' as 2, which is not a dict, so replace the existing value with 2. Then the third node has 'a' as {'b': 3}, which is a dict. Since the existing value is 2 (non-dict), the code would replace it with {'b': 3}.

So the final result is {'a': {'b': 3}}. That seems correct according to the docstring.

Another example: nodes = [{'a': 1}, {'a': {'b': 2}}, {'a': 3}]. The first node adds 'a' as 1. The second node has 'a' as {'b': 2}, which is a dict. Since the existing value is 1 (non-dict), the code would replace it with {'b': 2}. Then the third node has 'a' as 3, which is non-dict. Since the existing is a dict, the code would replace it with 3. So the final result is {'a': 3}.

But according to the docstring, if the colliding keys have non-MappingNode values, the last one remains. In this case, the third node's value is a non-MappingNode, and the existing value is a dict. So, the colliding key has a non-MappingNode value (the third node's value), so the last one remains. So the code is correct.

But what if the existing value is a dict, and the new value is a non-dict. According to the code, it would replace the existing with the new value. Which is correct.

So, this code seems to handle the cases.

But wait, the function is called deep_merge_nodes, which takes a list of nodes. The code above assumes that each node is a dictionary. But what if the nodes are not dictionaries? The docstring says "node values corresponding to duplicate keys". So perhaps the nodes are dictionaries, and the function is supposed to merge them.

So, the code would be as follows.

But the function is supposed to merge any node values corresponding to duplicate keys. So, the function is given a list of nodes, and each node is a dictionary. The function merges all the nodes into one dictionary, with the rules described.

So, the code would be:

def deep_merge_nodes(nodes):
    result = {}
    for node in nodes:
        for key, value in node.items():
            if key in result:
                if isinstance(result[key], dict) and isinstance(value, dict):
                    # Merge recursively
                    result[key] = deep_merge_nodes([result[key], value])
                else:
                    # Take the last one
                    result[key] = value
            else:
                result[key] = value
    return result

Wait, but the function is called deep_merge_nodes, which takes a list of nodes. But the code above is merging the current node's key-value pairs into the result. However, the code is passing [result[key], value] to deep_merge_nodes, which is a list containing two dictionaries. But the function is supposed to merge a list of nodes. So, in this case, the code is recursively calling deep_merge_nodes with a list containing two dictionaries, which would merge them. But this is not correct. Because the function is supposed to merge all nodes in the list, not just two.

Wait, no. The function is supposed to merge all nodes in the list. So, when merging two dictionaries (result[key] and value), we need to merge them. But how? The function deep_merge_nodes takes a list of nodes. So, to merge two dictionaries, we can pass them as a list. For example, deep_merge_nodes([dict1, dict2]) would merge them.

But in the code above, when merging two dictionaries, we call deep_merge_nodes([result[key], value]), which would merge them. That's correct.

Let me test this with an example.

Example 1: nodes = [{'a': 1}, {'a': 2}]. The code would process the first node, adding 'a' as 1. Then the second node's 'a' is 2. Since both are non-dicts, replace with 2. Result is {'a': 2}.

Example 2: nodes = [{'a': {'b': 1}}, {'a': {'c': 2}}]. The code would process the first node, add 'a' as {'b': 1}. Then the second node's 'a' is {'c': 2}. Both are dicts. So, call deep_merge_nodes([{'b': 1}, {'c': 2}]). Wait, no. Wait, the code is passing [result[key], value], which is [{'b': 1}, {'c': 2}]. But the function deep_merge_nodes is supposed to merge a list of nodes. So, in this case, the function would merge these two nodes. But how?

Wait, the function deep_merge_nodes is called with a list of nodes. So, in this case, the list is [{'b': 1}, {'c': 2}]. The function would process each node in the list. For the first node, 'b' is added. Then the second node's 'c' is added. The merged result would be {'b': 1, 'c': 2}.

So, the code would correctly merge the two dictionaries.

Another example: nodes = [{'a': {'b': 1}}, {'a': {'b': 2}}, {'a': {'c': 3}}]. The first node adds 'a' as {'b': 1}. The second node has 'a' with {'b': 2}, which is a dict. So, merge [{'b': 1}, {'b': 2}] → {'b': 2} (since the second node's value is the last one). Then the third node has 'a' with {'c': 3}, which is a dict. Merge {'b': 2} and {'c': 3} → {'b': 2, 'c': 3}.

So, the final result is {'a': {'b': 2, 'c': 3}}.

This seems correct.

So, the code seems to handle the cases correctly.

Now, what about if a node has a key that is not in the result, but the existing value is a dict. For example, nodes = [{'a': 1}, {'a': {'b': 2}}]. The first node adds 'a' as 1. The second node's 'a' is a dict. So, since the existing value is 1 (non-dict), the code replaces it with the dict. So the result is {'a': {'b': 2}}.

Yes.

Now, what about if there are multiple nodes with the same key, some with dicts and some with non-dicts. For example:

nodes = [{'a': 1}, {'a': 2}, {'a': {'b': 3}}, {'a': 4}]

The code would process:

First node: 'a' is 1.

Second node: 'a' is 2 → replace with 2.

Third node: 'a' is {'b': 3} → replace with {'b': 3}.

Fourth node: 'a' is 4 → replace with 4.

So the final result is {'a': 4}.

Which is correct according to the docstring.

So, the code seems to handle the cases.

Now, the next step is to write the code. However, the function is supposed to take a list of nodes. But in the code above, the function is called with nodes as a list. So, the code is correct.

But what about if the nodes are not dictionaries? For example, if a node is a list. But according to the docstring, the function is supposed to merge node values corresponding to duplicate keys. So, perhaps the nodes are dictionaries, and the function is supposed to merge them.

So, the code is correct.

Now, the user also mentioned to follow a test-driven development approach, first generating comprehensive unit tests before writing the actual code. But the user's instruction says to generate the code based on the function signature and docstring, and output only the code in Python markdown format.

So, the code should be written as per the above logic.

But I need to make sure that the code is correct. Let me think of some test cases.

Test case 1: nodes = [{'a': 1}, {'a': 2}]. Expected result: {'a': 2}.

Test case 2: nodes = [{'a': 1}, {'a': {'b': 2}}]. Expected result: {'a': {'b': 2}}.

Test case 3: nodes = [{'a': {'b': 1}}, {'a': {'b': 2}}, {'a': {'c': 3}}]. Expected result: {'a': {'b': 2, 'c': 3}}.

Test case 4: nodes = [{'a': 1}, {'a': 2}, {'a': 3}]. Expected result: {'a': 3}.

Test case 5: nodes = [{'a': {'b': 1}}, {'a': {'c': 2}}, {'a': {'d': 3}}]. Expected result: {'a': {'b': 1, 'c': 2, 'd': 3}}.

Test case 6: nodes = [{'a': 1}, {'a': {'b': 2}}, {'a': 3}]. Expected result: {'a': 3}.

Test case 7: nodes = [{'a': 1}, {'a': {'b': 2}}, {'a': {'b': 3}}]. Expected result: {'a': {'b': 3}}.

So, the code should handle these cases.

Now, the code is:

def deep_merge_nodes(nodes):
    result = {}
    for node in nodes:
        for key, value in node.items():
            if key in result:
                if isinstance(result[key], dict) and isinstance(value, dict):
                    result[key] = deep_merge_nodes([result[key], value])
                else:
                    result[key] = value
            else:
                result[key] = value
    return result

But wait, the function is called deep_merge_nodes, which takes a list of nodes. However, in the recursive call, we pass [result[key], value], which is a list containing two dictionaries. But the function is supposed to merge a list of nodes. So, when we call deep_merge_nodes([result[key], value]), it's merging those two nodes. Which is correct.

But what if the nodes are not dictionaries? For example, if a node is a list. But according to the docstring, the nodes are presumably dictionaries. So, the code assumes that the nodes are dictionaries.

So, this code should work.

Now, the user wants the code in Python markdown format, only the code. So, the final answer is the code as written.
