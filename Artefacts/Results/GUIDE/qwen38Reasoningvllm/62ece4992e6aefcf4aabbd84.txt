
Okay, I need to write a Python function called is_ipv4 that checks if a given target is a valid IPv4 address. Let me think about how to approach this.

First, the function should return True if the target is a valid IPv4, else False. So, what makes an IPv4 valid? Well, an IPv4 address is four octets separated by dots. Each octet must be a number between 0 and 255. Also, the target should be a string, right? Or maybe it could be something else, but the function's docstring says it's testing if the target is an IPv4 address, so I assume the input is a string.

Wait, but the function's parameters are just 'target', so maybe it's expecting a string. But maybe the function should handle other types? Probably, the function should first check if the input is a string. If it's not, return False.

So the steps I need to take are:

1. Check if the target is a string. If not, return False.
2. Split the string by dots. There should be exactly four parts.
3. For each part, check if it's a numeric string (digits only), and then convert to integer.
4. Each integer must be between 0 and 255, inclusive.
5. Also, check that there are no leading zeros unless the number is zero itself. For example, '00' is invalid, but '0' is okay.

Wait, but the standard IPv4 address allows leading zeros? Wait, no. Wait, in IPv4 addresses, each octet is a number between 0-255. But when written as a string, leading zeros are allowed? Or are they not? For example, is '192.168.01.1' a valid IPv4? Well, according to some sources, leading zeros are not allowed. So, for example, '01' is invalid because it's not a valid integer representation. So the function should check that each octet is a valid integer without leading zeros, except when the octet is zero.

So, for each part:

- It must be a string of digits (so no letters, etc.)
- If the length is more than 1, the first character can't be '0' (so no leading zeros)
- The numeric value must be between 0 and 255.

So, let's outline the steps again:

Check if target is a string. If not, return False.

Split the target into parts using '.' as the delimiter. If there are not exactly four parts, return False.

For each part in the split list:

- Check if it's all digits. If not, invalid.
- Check if the part is empty (like if there's a '.' at the start or end). Also, if the part is empty, invalid.
- Check for leading zeros: if the length is greater than 1, and starts with '0', then invalid.
- Convert to integer and check if between 0 and 255.

So, for example:

'192.168.0.1' is valid.

'192.168.01.1' is invalid because '01' has leading zero.

'255.255.255.255' is valid.

'256.0.0.0' is invalid because 256 > 255.

Now, how to implement this in Python.

First, the function:

def is_ipv4(target):

So, first check if target is a string. But wait, what if the target is something like an integer? Like 192.168.0.1 as an integer? Probably, the function should expect a string. So, if the input is not a string, return False.

So:

if not isinstance(target, str):
    return False

Then split the target into parts:

parts = target.split('.')

If len(parts) != 4, return False.

Then for each part in parts:

Check if it's all digits. So, for part in parts:

if not part.isdigit():
    return False

Also, check for leading zeros. For example, part is '0' → okay. part is '00' → invalid. So:

if len(part) > 1 and part[0] == '0':
    return False

Then, convert to integer and check between 0 and 255.

But wait, what about parts like '0'? That's okay. So:

for part in parts:
    if not part.isdigit():
        return False
    if len(part) > 1 and part[0] == '0':
        return False
    num = int(part)
    if num < 0 or num > 255:
        return False

Wait, but since part is digits, converting to int will be >=0. So maybe check if num > 255.

So, putting it all together.

But wait, what about parts that are empty? Like if the target is '192.168..1', then split would give ['192', '168', '', '1'], which would fail the check for empty parts. So, in the loop, for each part, check if it's empty. So:

for part in parts:
    if not part:  # empty string
        return False
    if not part.isdigit():
        return False
    if len(part) > 1 and part[0] == '0':
        return False
    num = int(part)
    if num > 255:
        return False

Wait, but what about if the part is '0'? Then len(part) is 1, so no problem. And num is 0, which is okay.

So, putting all together:

def is_ipv4(target):
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part:  # empty part
            return False
        if not part.isdigit():
            return False
        if len(part) > 1 and part[0] == '0':
            return False
        num = int(part)
        if num > 255:
            return False
    return True

Wait, but what about if the part is '255'? That's okay. But what about '0'? Also okay.

But wait, what about if the part is '000'? Then, len(part) is 3, starts with 0 → returns False.

So that's correct.

Testing some cases:

Test case 1: '192.168.0.1' → should return True.

Test case 2: '255.255.255.255' → True.

Test case 3: '256.0.0.0' → returns False because 256 > 255.

Test case 4: '0.0.0.0' → True.

Test case 5: '192.168.01.1' → returns False because '01' has leading zero.

Test case 6: '192.168.1.01' → returns False.

Test case 7: '192.168.1.0' → True.

Test case 8: '192.168.1.0a' → returns False because '0a' is not digits.

Test case 9: '192.168.1.0.' → split into ['192', '168', '1', '0.'] → no, wait, target is '192.168.1.0.' → split into ['192', '168', '1', '0.'] → the last part is '0.'? Wait, no. Wait, splitting on '.' would split '192.168.1.0.' into ['192', '168', '1', '0', ''] → len(parts) is 5, so returns False.

Another test case: '192.168.1.0' → valid.

What about '192.168.1.00'? The last part is '00' → len is 2, starts with 0 → returns False.

What about '192.168.1.0'? → valid.

What about '192.168.1.255' → valid.

What about '192.168.1.256' → returns False.

What about '192.168.1.abc' → returns False because 'abc' is not digits.

What about '192.168.1.0.1' → split into 5 parts → returns False.

What about '192.168.1' → split into 3 parts → returns False.

What about '192.168.1.0' → valid.

Now, what about leading zeros in the middle? Like '192.168.01.01' → parts are '192', '168', '01', '01' → third part is '01' → len>1 and starts with 0 → returns False.

So the code seems to handle that.

But wait, what about the case where the part is '0'? That's allowed. So '0.0.0.0' is valid.

Another edge case: '255.255.255.255' → valid.

What about '0.0.0.0' → valid.

What about '123.45.67.89' → valid.

Now, what about if the target is not a string? Like an integer. For example, 192.168.0.1 → the function returns False, which is correct.

But what if the target is a string with leading or trailing whitespace? Like ' 192.168.0.1 ' → split into parts would have ' 192', etc. So, the code would check if each part is digits. But ' 192' is not all digits (has space), so returns False. So that's correct.

So the code seems to handle that.

Now, the user wants me to generate the code, but also to follow a test-driven development approach, first generating comprehensive unit tests before writing the actual code.

But the user says to output only the code generated, in Python markdown format. So perhaps the initial answer should include the code, but the thinking process includes the test cases.

But the user's instruction says: "Output ONLY the code generated, in python markdown format."

So perhaps the code is the function, and the tests are not part of the output. But the user mentioned that the assistant should follow a test-driven approach, first generating tests. However, the final output is only the code.

So perhaps the code is the function is_ipv4 as written above.

But maybe there are some edge cases I missed. Let me think again.

Another edge case: '0.0.0.0' → valid.

Another case: '1.2.3.4' → valid.

What about '1.2.3.04'? The last part is '04' → len>1 and starts with 0 → invalid.

What about '1.2.3.0'? Valid.

What about '1.2.3.00'? Invalid.

What about '1.2.3.0'? Valid.

Another case: '123.045.067.089' → each part has leading zeros → invalid.

So the code seems to handle that.

Another case: '123.45.67.89' → valid.

What about '123.45.67.89a' → invalid because of 'a'.

So the code seems correct.

Now, the code as written:

def is_ipv4(target):
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part:  # empty part
            return False
        if not part.isdigit():
            return False
        if len(part) > 1 and part[0] == '0':
            return False
        num = int(part)
        if num > 255:
            return False
    return True

Wait, but what about if the part is '0'? Then len(part) is 1, so no problem. And num is 0, which is okay.

But what about if the part is '000'? Then len(part) is 3, starts with 0 → returns False.

Yes.

But what about if the part is '0'? It's allowed.

So, the code seems correct.

Now, the user wants the code in Python markdown format. So, the code is written as:

```python
def is_ipv4(target):
    """
    Test if IPv4 address or not.

    Returns: Boolean, True if target is IPv4 address, else False.
    """
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part:
            return False
        if not part.isdigit():
            return False
        if len(part) > 1 and part[0] == '0':
            return False
        num = int(part)
        if num > 255:
            return False
    return True
```

But wait, what about the case where the part is '0'? It's allowed. But what about if the part is '00'? Then len(part) is 2, starts with 0 → returns False. Which is correct.

Another thing: the code checks if the part is empty. For example, if the target is '192.168.1.', then split into ['192', '168', '1', ''] → the last part is empty → returns False.

Yes.

So this code should handle all the cases.
