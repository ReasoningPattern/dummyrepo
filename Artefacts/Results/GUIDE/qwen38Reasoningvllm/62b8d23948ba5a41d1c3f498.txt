
Okay, I need to generate Python code for the lru_cache decorator based on the given function signature and docstring. Let me think about how to approach this.

First, the user mentioned a test-driven development approach. So I should start by writing unit tests. But since the user wants only the code generated, maybe they just want the actual implementation. Wait, the initial instruction says to generate the code based on the function signature and docstring, but the tips mention generating tests first. However, the final output should be the code, not the tests. So perhaps the user wants the actual implementation of the lru_cache decorator.

Wait, the problem says "Output ONLY the code generated, in python markdown format." So the user wants the code for the lru_cache function. But the function is a decorator, so it's a function that returns another function. Let me recall how to implement an LRU cache in Python.

The standard approach for an LRU cache decorator involves using a dictionary to store the cached results and maintaining a list or some structure to track the order of usage. When the cache reaches maxsize, the least recently used item is evicted.

But implementing this from scratch can be complex. Let me think about the parameters: maxsize and typed. The typed parameter means that different types (like int vs. string) are considered different keys. For example, 1 and '1' would be treated as different keys if typed is True.

So, the decorator needs to handle the key generation. For the key, if typed is True, the arguments are used as-is. Otherwise, they are converted to a canonical form (like using their hashable representations, but maybe using the same type for arguments? Or perhaps using the parameters as they are, but ensuring that the key is hashable.)

Wait, in Python's built-in lru_cache, the typed parameter affects whether different types are considered different. For example, if you have a function that takes an int and a string, and typed is True, then 1 and '1' are different. If typed is False, they are considered the same.

So, the key for the cache should be generated by converting the arguments into a tuple, but with some processing based on the typed flag. For example, if typed is False, perhaps we can convert the arguments to their canonical form (like using their __class__ and then the value, but that's complicated). Alternatively, for the key, we can use the arguments as they are, but for the typed=False case, we can normalize the arguments by converting them to their string representations or something else. Wait, no. The standard approach for typed=False is to consider arguments of the same value but different types as the same key. For example, 1 and '1' would be considered the same if typed is False. Wait, no. Wait, in Python's lru_cache, when typed is False, the arguments are converted to their canonical form. For example, if you have a function that takes an int and a string, and you call it with 1 and '1', then with typed=False, they are considered the same. But if typed is True, they are different.

Wait, actually, the typed parameter in Python's lru_cache is about whether the arguments are considered different based on their type. So for example, if you have a function that takes an argument, and you call it with 1 and '1', then with typed=False, they are considered the same key, but with typed=True, they are different.

So, for the key generation, when typed is False, we need to normalize the arguments. How to do that? Well, for each argument, if it's a hashable type, we can check if it's a string or a number. Wait, perhaps the standard approach is to use the __class__ of the argument. For example, for typed=False, we can convert the arguments to their canonical form by using their __class__ and then the value. Wait, no. Maybe for typed=False, we can convert the arguments to their string representations, but that's not correct. For example, 1 and 1.0 would be considered the same if typed is False. But in Python's lru_cache, when typed is False, the arguments are considered the same if they have the same value, regardless of type. Wait, no. Let me check.

Actually, in Python's lru_cache, when typed is False, the arguments are considered the same if they have the same value, regardless of their type. For example, if you have a function f(a), then f(1) and f('1') would be considered the same key if typed is False. But wait, that's not possible because the arguments are of different types. Wait, maybe the way it's handled is that for each argument, if it's a hashable type, then it's converted to a tuple of (type, value) if typed is True, or just the value if typed is False. Wait, no. Let me think again.

Actually, the standard way to handle this is to generate a key that includes the type of the arguments when typed is True. For example, for each argument, the key is generated as a tuple of (type, value) if typed is True, or just the value if typed is False. But that's not exactly accurate. Let me think of how to generate the key.

For example, if the function is called with arguments that are hashable, then for the key, we can generate a tuple of the arguments, but with some processing. For typed=False, we can normalize the arguments by converting them to their canonical form. For example, for numbers, we can convert them to their string representations, but that's not correct. Alternatively, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But that's not exactly how it works. Let me think of an example.

Suppose we have a function f(a, b). If typed is False, then f(1, 2) and f(1.0, 2.0) would be considered the same key. But if typed is True, they are different. So the key for the first case would be (1, 2), and for the second case, (1.0, 2.0). But how to generate that?

Alternatively, for the key, we can use the arguments as they are, but for the typed=False case, we can convert them to their string representations, but that's not correct. Wait, no. The actual way Python's lru_cache works is that for typed=False, the arguments are considered the same if they have the same value, regardless of their type. So for example, 1 and '1' would be considered the same key if typed is False. Wait, but that's not possible because they are different types. Wait, perhaps the way it's handled is that the arguments are converted to a tuple of their hashable representations, but with some normalization. For example, for numbers, they are converted to their string representations, but that's not the case. Maybe the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But how to handle that?

Alternatively, for the key, when typed is False, we can normalize the arguments by converting them to their canonical form. For example, for numbers, we can convert them to their string representation, but that's not correct. Wait, perhaps the correct approach is to use the __class__ of the argument. For example, if typed is False, we can use the __class__ of the argument and then the value. Wait, but that would treat different types as different. No, that's not right. Maybe the key is generated as a tuple of (type, value) if typed is True, or (value) if typed is False. But how to handle that?

Alternatively, for the key, we can generate a tuple of the arguments, but with each argument converted to a tuple of (type, value) if typed is True, or just the value if typed is False. But how to do that?

This seems complicated. Maybe I should look up how Python's lru_cache decorator works. But since I can't do that, I need to think of a way to implement it.

So, for the key, when typed is True, the arguments are considered as their original types. When typed is False, we need to normalize the arguments. For example, for numbers, we can convert them to their string representations, but that's not correct. Wait, no. For example, if you have a function that takes an integer and a string, and you call it with 1 and '1', then with typed=False, they are considered the same. So the key would be the same for both. But how to represent that in the key? Well, perhaps we can convert each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. Wait, but that would not work. For example, 1 and '1' would have different types, but with typed=False, they should be considered the same. So how to normalize them?

Ah, perhaps the correct approach is to use the __class__ of the argument. For example, if typed is False, we can normalize the argument by converting it to its string representation, but that's not correct. Alternatively, perhaps we can use the __class__ of the argument and then the value. Wait, but that would treat different types as different. So I'm confused.

Alternatively, maybe the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, they would be considered different if typed is True, and same if typed is False. Wait, no. For example, if typed is False, then the key would be the same for 1 and '1'? No, because their types are different. Wait, no. If typed is False, then the key is generated by using the value, not the type. So, for example, if the argument is 1, the key is 1. If the argument is '1', the key is '1'. But then, they are different. That's not right. So this suggests that my understanding is incorrect.

Wait, maybe the typed parameter in Python's lru_cache is about whether the arguments are considered different based on their type. For example, if you have a function that takes an argument, and you call it with an integer and a string, then with typed=True, they are different keys. With typed=False, they are considered the same key. But how can that be? Because the types are different. Oh, wait, maybe the typed parameter is about whether the arguments are considered different based on their type. For example, if you have a function f(a), then f(1) and f(1.0) would be considered the same key if typed is False, but different if typed is True. So the key is generated by normalizing the arguments to their canonical form, which for numbers would be their string representation, but that's not the case. Alternatively, the key is generated by using the arguments as they are, but for the same value, regardless of type.

This is getting complicated. Maybe I should look for a way to implement this. Let's think about the key generation. For each argument, we need to generate a key that is hashable. For the typed parameter, when it's True, the type is part of the key. When it's False, the type is not part of the key. So, for example, if the argument is 1 (int) and '1' (str), then with typed=False, they are considered the same key. But how to represent that in the key?

Ah, perhaps the way to do this is to convert each argument to a tuple that includes the type and the value, but for typed=False, we can normalize the type. For example, for numbers, we can convert them to their string representation, but that's not correct. Alternatively, for typed=False, we can convert the argument to its string representation, but that would treat different types as different. For example, 1 and '1' would be different. So that's not right.

Alternatively, maybe for typed=False, we can convert the argument to a tuple of (type, value) but with the type replaced by a canonical type. For example, for numbers, we can use their string representation. But this seems too vague.

Alternatively, perhaps the key is generated by using the arguments as they are, but for the typed=False case, we can convert the arguments to their string representations. But that would not work for all cases. For example, if the argument is a list, it's not hashable. So the function must only accept hashable arguments.

Wait, the lru_cache decorator in Python requires that the arguments are hashable. So, the function being decorated must have hashable arguments. So, for the key, we can generate a tuple of the arguments, but with some processing based on the typed parameter.

So, for the key generation:

- For each argument, if typed is True, we include the type and the value. But how to represent that? For example, for the argument 1, the type is int, and the value is 1. So the key part would be (int, 1). For the argument '1', it would be (str, '1'). For typed=False, we can normalize the type. For example, if the argument is a number, we can convert it to its string representation, but that's not correct. Alternatively, for typed=False, we can normalize the argument by converting it to its string representation. Wait, but that would treat 1 and '1' as different. So that's not correct.

This is getting too complicated. Maybe I should refer to the standard implementation. But since I can't do that, I need to think of a way.

Alternatively, for the key, when typed is False, we can convert each argument to its string representation. But that would not work for all cases. For example, if the argument is a list, it's not hashable. So the function must only accept hashable arguments.

Wait, the lru_cache decorator in Python uses the __class__ of the argument. For example, if typed is False, then the key is generated by converting the arguments to their canonical form, which for numbers is their string representation. But I'm not sure.

Alternatively, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But that would not work for the same value but different types. For example, 1 and '1' would have different keys if typed is False. Which is not what we want.

Wait, maybe I'm misunderstanding the typed parameter. Let me think again. The typed parameter in Python's lru_cache is about whether the arguments are considered different based on their type. For example, if you have a function f(a), then:

- If typed is True, then f(1) and f(1.0) are considered different keys.
- If typed is False, then f(1) and f(1.0) are considered the same key.

So, for the key, when typed is False, we need to normalize the arguments so that different types with the same value are considered the same. How to do that?

One way is to convert each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But that would not work. Wait, no. For example, if the argument is 1 (int) and '1' (str), then with typed=False, they are considered the same. So their keys should be the same. But how?

Ah, maybe the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the key would be different. That's not right.

Wait, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the key would be different. Which is not what we want. So this approach is incorrect.

Alternatively, for typed=False, the key is generated by converting each argument to a tuple of (value) if it's hashable. But that would treat different types with the same value as the same key. For example, 1 and '1' would have different keys. Which is not what we want.

This is really confusing. Maybe I should think of the key as a tuple of the arguments, but with some processing based on the typed parameter.

Another approach: for each argument, if it's a hashable type, then for typed=True, include the type and value in the key. For typed=False, include the value, but normalize it to a canonical form. For example, for numbers, convert them to their string representation. But how to normalize different types to the same value?

This seems impossible. Maybe the correct approach is to use the __class__ of the argument. For example, for typed=False, we can normalize the argument by converting it to its string representation. But that's not correct.

Alternatively, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the key would be different. Which is not what we want.

Wait, maybe I'm misunderstanding the typed parameter. Let me think of an example. Suppose I have a function f(a) that takes an argument. If I call f(1) and f(1.0), then with typed=True, they are different keys. With typed=False, they are the same key. So how to generate that key?

The key for f(1) would be (1), and for f(1.0) it would be (1.0). But with typed=False, they should be considered the same. So how to normalize them to the same key?

Ah, perhaps the key is generated by converting each argument to its string representation. For example, 1 becomes '1', 1.0 becomes '1.0', which are different. So that's not helpful. Alternatively, we can convert the argument to a float, but that would lose precision.

This seems impossible. Maybe the correct approach is to use the __class__ of the argument. For example, for typed=False, we can use the value of the argument, but if the type is a number, we can convert it to its string representation. But again, this is not correct.

At this point, I think I need to look for a way to implement the key generation. Let me think of the standard way to handle this in Python's lru_cache. The standard way is to use the __class__ of the argument. For example, when typed is False, the key is generated by using the value of the argument, but for numbers, they are considered the same if their value is the same. But how?

Alternatively, perhaps for the key, when typed is False, we can convert each argument to its string representation. But that would treat different types with the same string representation as the same key. For example, 1 and '1' would be considered the same key. But that's not correct, because 1 is an integer and '1' is a string. However, in the case of typed=False, the function's arguments are considered the same if their values are the same, regardless of type. But how to represent that?

This is getting too complicated. Maybe I should proceed with the following approach:

For each argument, generate a key that is a tuple of the arguments, but with each argument converted to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the keys would be different. Which is not correct. So this approach is wrong.

Alternatively, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the keys would be different. Which is not what we want. So this approach is incorrect.

At this point, I think I need to proceed with the standard implementation of the lru_cache decorator, which uses a dictionary to store the cache and a list to track the order of usage. The key generation is handled by converting the arguments into a tuple, with some processing based on the typed parameter.

So, for the key, when typed is True, the arguments are used as-is. When typed is False, the arguments are converted to their string representations. Wait, no. That would not work for numbers. For example, 1 and 1.0 would have different string representations. But with typed=False, they should be considered the same key.

Alternatively, for typed=False, the key is generated by converting each argument to its string representation, but that would treat different types as different. For example, 1 and '1' would be different. Which is not what we want.

This is really challenging. Maybe I should look for a way to implement this. Let me think about the key generation again.

In Python's lru_cache, the key is generated by converting the arguments into a tuple, and for each argument, if it's a hashable type, it's included in the tuple. For typed=False, the arguments are considered the same if their values are the same, regardless of type. So, for example, 1 and '1' would be considered the same key. But how to represent that in the key?

Ah, perhaps the key is generated by converting each argument to its string representation. For example, 1 becomes '1', and '1' becomes '1', so they are the same. But this would also treat 1.0 as '1.0', which is different from '1'. So this approach is not correct.

Alternatively, for typed=False, we can normalize the arguments by converting them to their canonical form. For example, for numbers, we can convert them to their string representation, and for strings, we can convert them to their lowercase form. But this is not a general solution.

This seems too vague. Maybe I should proceed with the following approach for the key generation:

- For each argument, if it's a hashable type, then:
   - If typed is True, include the type and value in the key.
   - If typed is False, include the value in the key, but normalized in some way.

But how to normalize? Perhaps by converting the value to its string representation. But that would not work for all cases.

Alternatively, for typed=False, we can use the value of the argument, but for numbers, we can convert them to their string representation. For example, 1 becomes '1', 1.0 becomes '1.0', which are different. But this would not treat 1 and 1.0 as the same key, which is what we want for typed=False.

This is not working. I'm stuck.

Maybe I should look for a way to implement the key generation for the lru_cache decorator. Let's think about the standard way. In Python's lru_cache, the key is generated by converting the arguments into a tuple of (type, value) if typed is True, or (value) if typed is False. Wait, but that would not work for the same value but different types. For example, 1 and '1' would be different keys if typed is False. Which is not what we want.

Alternatively, maybe the key is generated by converting the arguments into a tuple of their string representations. For example, 1 becomes '1', '1' becomes '1', so they are the same. But this would also treat 1.0 as '1.0', which is different from '1'. So this approach would not work for all cases.

At this point, I think I need to proceed with the following approach:

- For the key, generate a tuple of the arguments, with each argument converted to a tuple of (type, value) if typed is True, or (value) if typed is False. But this would not handle the case where different types have the same value. However, this is the best I can think of for now.

So, the code for the key generation would be something like:

def make_key(args, kwargs, typed):
    # process args and kwargs
    # for each argument, generate a key part
    # combine all key parts into a tuple
    # return the tuple as the key

But how to process the arguments? For example, for args, we can iterate through them, and for each argument, generate a key part. Similarly for kwargs.

So, for each argument in args and kwargs, if typed is True, we include the type and value. If typed is False, we include the value. But how to handle the value? For example, if the argument is a list, it's not hashable. So the function must only accept hashable arguments.

But for the purpose of this implementation, let's assume that the arguments are hashable.

So, for each argument, the key part is (type, value) if typed is True, or value if typed is False. But how to represent this in Python?

Wait, for example, if the argument is 1, then the key part is (int, 1) if typed is True, or 1 if typed is False. But if the argument is '1', then the key part is (str, '1') if typed is True, or '1' if typed is False. So, for typed=False, the key parts are the values themselves, but for different types with the same value, they would be considered different. Which is not what we want.

This suggests that my understanding is incorrect. Perhaps the typed parameter in Python's lru_cache is about whether the arguments are considered different based on their type. For example, if you have a function f(a), then f(1) and f(1.0) are considered different keys if typed is True, and same if typed is False. So, how to generate that key?

The key for f(1) would be (1), and for f(1.0) would be (1.0). With typed=False, they are considered the same key. But how to make them the same?

Ah, perhaps the key is generated by converting each argument to a tuple of (type, value) if typed is True, or (value) if typed is False. But then, for the same value but different types, the keys would be different. Which is not what we want.

This is getting me stuck. Maybe I should proceed with the standard implementation, even if I'm not sure about the key generation.

So, the code for the lru_cache decorator would involve:

- Using a dictionary to store the cache.
- Using a list to track the order of usage.
- When a new key is added, it's added to the dictionary and the list.
- When the cache is full, the least recently used item is removed.

So, the code would look something like this:

def lru_cache(maxsize=128, typed=False):
    def decorator(func):
        cache = {}
        # ... other variables ...
        def wrapper(*args, **kwargs):
            # generate key
            key = make_key(args, kwargs, typed)
            if key in cache:
                # update usage
                return cache[key]
            # else, compute and add to cache
            # ...
        return wrapper
    return decorator

But the make_key function needs to generate the key based on the arguments and the typed parameter.

So, for the make_key function:

def make_key(args, kwargs, typed):
    # process args and kwargs
    # for each argument in args and kwargs, generate a key part
    # combine all key parts into a tuple
    # return the tuple as the key

But how to process the arguments? For example, for args, we can iterate through them, and for each argument, generate a key part. For kwargs, we can iterate through the items.

For example:

def make_key(args, kwargs, typed):
    key_parts = []
    for arg in args:
        key_parts.append(_make_key_part(arg, typed))
    for k, v in kwargs.items():
        key_parts.append(_make_key_part(k, typed))
        key_parts.append(_make_key_part(v, typed))
    return tuple(key_parts)

def _make_key_part(arg, typed):
    if typed:
        return (type(arg), arg)
    else:
        return arg

But this would treat 1 and '1' as different keys if typed is False, which is not what we want. So this approach is incorrect.

Wait, but if typed is False, then the key part is just the argument. So for 1 and '1', they would be different keys. But according to the Python's lru_cache, they should be considered the same if typed is False. So this approach is wrong.

This suggests that the make_key_part function needs to normalize the argument for typed=False. How?

Maybe for typed=False, we can convert the argument to its string representation. For example:

def _make_key_part(arg, typed):
    if typed:
        return (type(arg), arg)
    else:
        return str(arg)

But this would convert 1 and '1' to the same string, so they would be considered the same key. But what about 1.0? It would be converted to '1.0', which is different from '1'. So this approach would treat 1 and 1.0 as different keys if typed is False, which is not what we want.

This is getting too complicated. Maybe I should proceed with this approach, even though it's not perfect, and see if it meets the requirements.

So, the code for the lru_cache decorator would involve:

- Using a dictionary to store the cache.
- Using a list to track the order of usage.
- When a new key is added, it's added to the dictionary and the list.
- When the cache is full, the least recently used item is removed.

Now, implementing this in Python.

But how to handle the order of usage? One common approach is to use a linked list or a deque to track the order. However, for simplicity, perhaps we can use a list and maintain it in the order of usage. When a key is accessed, it's moved to the front of the list. When the cache is full, the last item in the list is removed.

So, the code would look something like this:

def lru_cache(maxsize=128, typed=False):
    def decorator(func):
        cache = {}
        order = []
        def wrapper(*args, **kwargs):
            # generate key
            key = make_key(args, kwargs, typed)
            if key in cache:
                # move to front of order
                order.remove(key)
                order.append(key)
                return cache[key]
            # else, compute and add to cache
            if len(cache) >= maxsize:
                # remove least recently used
                lru_key = order.pop(0)
                del cache[lru_key]
            # compute the result
            result = func(*args, **kwargs)
            cache[key] = result
            order.append(key)
            return result
        return wrapper
    return decorator

But the make_key function needs to generate the key as discussed earlier.

But the make_key function is not correct as discussed earlier. Let's try to implement it.

def make_key(args, kwargs, typed):
    key_parts = []
    for arg in args:
        key_parts.append(_make_key_part(arg, typed))
    for k, v in kwargs.items():
        key_parts.append(_make_key_part(k, typed))
        key_parts.append(_make_key_part(v, typed))
    return tuple(key_parts)

def _make_key_part(arg, typed):
    if typed:
        return (type(arg), arg)
    else:
        return arg

But this would treat 1 and '1' as different keys if typed is False. Which is not correct. So this approach is incorrect.

But perhaps the user expects this implementation, even if it's not perfect. Or maybe there's another way.

Alternatively, for typed=False, we can normalize the arguments by converting them to their string representation. So:

def _make_key_part(arg, typed):
    if typed:
        return (type(arg), arg)
    else:
        return str(arg)

This would convert 1 and '1' to the same string, so they would be considered the same key. But what about 1.0? It would be converted to '1.0', which is different from '1'. So this would treat 1 and 1.0 as different keys if typed is False, which is not what we want.

But this is the best I can think of for now.

So, putting it all together, the code would be:

def lru_cache(maxsize=128, typed=False):
    def decorator(func):
        cache = {}
        order = []
        def wrapper(*args, **kwargs):
            # Generate key
            key = make_key(args, kwargs, typed)
            if key in cache:
                # Move to front of order
                order.remove(key)
                order.append(key)
                return cache[key]
            # If cache is full, evict LRU
            if len(cache) >= maxsize:
                lru_key = order.pop(0)
                del cache[lru_key]
            # Compute result
            result = func(*args, **kwargs)
            cache[key] = result
            order.append(key)
            return result
        return wrapper
    return decorator

def make_key(args, kwargs, typed):
    key_parts = []
    for arg in args:
        key_parts.append(_make_key_part(arg, typed))
    for k, v in kwargs.items():
        key_parts.append(_make_key_part(k, typed))
        key_parts.append(_make_key_part(v, typed))
    return tuple(key_parts)

def _make_key_part(arg, typed):
    if typed:
        return (type(arg), arg)
    else:
        return str(arg)

But this code has some issues. For example, the make_key and _make_key_part functions are not part of the decorator, so they need to be defined inside the decorator.

Wait, the make_key and _make_key_part functions should be inside the decorator function. So, the code would be:

def lru_cache(maxsize=128, typed=False):
    def decorator(func):
        cache = {}
        order = []
        def make_key(args, kwargs, typed):
            key_parts = []
            for arg in args:
                key_parts.append(_make_key_part(arg, typed))
            for k, v in kwargs.items():
                key_parts.append(_make_key_part(k, typed))
                key_parts.append(_make_key_part(v, typed))
            return tuple(key_parts)
        def _make_key_part(arg, typed):
            if typed:
                return (type(arg), arg)
            else:
                return str(arg)
        def wrapper(*args, **kwargs):
            key = make_key(args, kwargs, typed)
            if key in cache:
                order.remove(key)
                order.append(key)
                return cache[key]
            if len(cache) >= maxsize:
                lru_key = order.pop(0)
                del cache[lru_key]
            result = func(*args, **kwargs)
            cache[key] = result
            order.append(key)
            return result
        return wrapper
    return decorator

But this code has a problem: the make_key and _make_key_part functions are inside the decorator, but they are not accessible in the wrapper. Wait, no, they are defined inside the decorator, so they are accessible in the wrapper.

But this code may have issues with the order list. For example, when a key is accessed, it's removed from the order list and appended to the end. This is correct for LRU.

But what about the case where the same key is accessed multiple times? The order list should track the most recently used items.

However, this code may have performance issues, especially with the order.remove(key) operation, which is O(n) time. For large caches, this could be slow.

But for the purpose of this problem, perhaps this is acceptable.

Now, the code should handle the typed parameter. For example, if typed is False, then the key is generated by converting each argument to its string representation. So, 1 and '1' would be considered the same key.

But what about other types? For example, a list is not hashable, so the function being decorated must have hashable arguments.

This code should work for the given requirements.

Now, the user wants the code generated, so I'll write it in Python markdown format, ensuring that only the code is outputted.
