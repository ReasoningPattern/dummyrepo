Okay, I need to generate Python code for the isoparse method based on the provided docstring. Let me start by understanding the requirements. The function should parse an ISO-8601 datetime string into a datetime.datetime object. The docstring lists various date and time formats that need to be supported, along with time zones.

First, I'll think about the structure. Since this is a method, it's probably part of a class. The function signature is def isoparse(self, dt_str), so I need to make sure it's a method of some class. But for the code generation, maybe I can just write the function as part of a class, perhaps using a helper class or something. Wait, but the user wants the code, so maybe the code should be part of a class. Alternatively, perhaps it's a standalone function, but the signature says it's a method. Hmm.

The docstring mentions that incomplete date formats can't be combined with time. So, for example, "YYYY-MM" can't have a time part. So the parser needs to check that. The date and time are separated by a single character (like T or maybe a space?), but according to the standard, it's T. But the doc says the separator can be any single character? Wait, the first paragraph says the date and time portions are separated by a single character separator, which is T in the standard. So the separator can be any single character, but the standard uses T. So the parser should handle any single separator character between date and time parts.

The supported date formats are listed. Let me note them:

Date formats:

- Common:
  - YYYY (year only)
  - YYYY-MM or YYYYMM (year and month)
  - YYYY-MM-DD or YYYYMMDD (full date)
- Uncommon:
  - YYYY-Www or YYYYWww (ISO week, day defaults to 0)
  - YYYY-Www-D or YYYYWwwD (ISO week and day)

Time formats:

- hh (hours)
- hh:mm or hhmm (minutes)
- hh:mm:ss or hhmmss (seconds)
- hh:mm:ss.ssssss (fractions up to 6 digits, but note the caution that fractional parts beyond seconds are not implemented here)

Midnight can be 00:00 or 24:00. The decimal separator can be . or ,.

Time zone formats include Z, ±HH:MM, ±HHMM, ±HH. The result uses dateutil's tz classes for the timezone.

The return should be a datetime with unspecified components defaulting to the lowest value. Like, if the date is only YYYY, then month and day default to 1? Wait, but the date part can't have a time if it's incomplete. Wait, the incomplete date (like YYYY-MM) can't be combined with time. So for example, "2020-01" can't have a time part. So the date part must be complete to allow a time part.

The function must parse all these cases correctly. 

Hmm, how to approach writing this? Since the user mentioned test-driven development, I should first think of the unit tests. But the code is what's needed here. Wait, the user wants the code generated, so perhaps I can proceed to code.

But first, the code must use dateutil's tz modules, like tzoffset and tzutc. So the code needs to import those. Also, the datetime module from Python.

Wait, the function is part of a class, so maybe the code would be part of a class, perhaps a helper class? Or maybe it's a standalone function, but the signature is a method. Let me structure it as a method of a class, perhaps a parser class.

Alternatively, perhaps the method is part of a class like a datetime parser utility. So the code would be:

class ISO8601Parser:
    def isoparse(self, dt_str):
        # code here

But the user's code needs to be the actual code. Let me think of the steps needed in the code.

The approach would be to parse the input string into its components (date part, time part, timezone), then combine them into a datetime object with appropriate timezone handling.

First, split the string into date and time parts. The separator is a single character. So, check if there's a separator like T, space, or other. The date part is everything up to the first non-date separator. Wait, perhaps split on the first occurrence of a non-digit character that's not part of the date. Alternatively, the date and time are separated by a single character. So the first occurrence of a character that's not part of the date format is the separator, but that's tricky. Maybe split on the first occurrence of a non-digit, non-hyphen, non-W character? Hmm, perhaps the better approach is to check for the presence of a time part by looking for a time separator (like T or a space). But the standard uses T, but the separator can be any single character. So the code must split on the first occurrence of a non-date character that is the separator between date and time.

Alternatively, the code can split the string into two parts: the date part and the time part, separated by any single character. The time part is optional.

Wait, the date and time are separated by a single character. So, for example, "2020-01-02T03:04" would split into date "2020-01-02" and time "03:04", with separator T. Similarly, "2020-01-02 03:04" would split into date and time with separator space. So the code can split on the first occurrence of a character that is not part of the date, but is a separator. Alternatively, the code can look for the first occurrence of a character that is neither part of the date format nor part of the time, but that's vague.

Alternatively, the code can split the string into two parts at the first occurrence of a character that is not part of the date's allowed format. But how to determine that?

Hmm, maybe the first step is to split the string into possible date and time parts. Let's consider that the date part is everything up to the separator (any single character), then the time part is the rest. But the separator is a single character. So, the code could look for the first occurrence of a character that is not part of the date's allowed separators. Wait, perhaps the approach is to iterate through possible separators. Alternatively, perhaps the code can check for the presence of a time part by looking for a character that is not part of the date, then split there. Alternatively, perhaps the code can first check if there is a 'T' or another separator in the string, but that might not be reliable.

Alternatively, the code can split the string into parts based on the presence of a time component. Let me think of the possible cases:

The input string can be:

- Only a date (no time or timezone)
- Date plus time, separated by a single character
- Date plus time plus timezone
- Time plus timezone (but the date part is required? Wait, no. The ISO-8601 standard allows time-only with timezone, but according to the docstring, the date portion is required? Or wait, the first paragraph says the date portion is followed optionally by a time portion. So the date is required, the time is optional. So the time part can only exist if there's a date part. So the entire string must start with a date part, then possibly a separator and time, then maybe timezone.

Wait, the first paragraph says "Parse an ISO-8601 datetime string into a datetime.datetime". So the input must be a full date-time string, but the date can be incomplete (like YYYY). Wait, but the incomplete date can't be combined with time. So the date part can be incomplete but without a time part. 

Hmm, this is getting complicated. Maybe I should proceed with a step-by-step approach.

First, the code needs to parse the date portion. Let's first split the string into the date part and the time part (if present).

So, the first step is to split the input string into the date component and the rest. The separator is any single character between the date and time. So, the code can look for the first occurrence of a character that is not part of the date's allowed characters (like hyphen, W, etc.) and split there. But how?

Alternatively, the code can check if there is a time portion by checking if after the date part, there is a time. Let me think of possible regex patterns. Maybe using regular expressions would be a good approach here.

Yes, perhaps using regex to parse the components. Let's think of a regex that can capture the date part, then the time part, then the timezone.

The regex would need to account for all the possible date and time formats listed.

First, the date part can be:

- YYYY (year only)
- YYYY-MM or YYYYMM (year-month)
- YYYY-MM-DD or YYYYMMDD (full date)
- YYYY-Www or YYYYWww (ISO week)
- YYYY-Www-D or YYYYWwwD (ISO week and day)

Time part:

- hh (hours)
- hh:mm or hhmm (minutes)
- hh:mm:ss or hhmmss (seconds)
- hh:mm:ss.ssssss (fractions up to 6 digits, but not implemented per caution)

Midnight can be 00:00 or 24:00.

Time zone part can be:

- Z (UTC)
- ±HH:MM, ±HHMM, ±HH

So, the regex would need to capture all these possibilities. 

Alternatively, the code can split the string into date and time parts first, then parse each part separately.

Let me outline the steps:

1. Split the input string into date_part and time_part (and timezone_part if present).

The separator between date and time is a single character. So, the first step is to find the first occurrence of a character that is not part of the date's allowed formats, then split there. But how to do that?

Alternatively, the code can look for the first occurrence of a character that is neither part of the date's components nor part of the time's start. For example, in "2020-01-02T03:04Z", the separator is T. In "2020-01-02 03:04Z", the separator is space. So the code can split on the first character that is not part of the date's allowed characters.

Alternatively, the code can look for the first occurrence of a character that is not a digit, hyphen, or 'W' (for week). Let me think: the date part can have hyphens (like YYYY-MM), or 'W' (for ISO week). So any character that is not part of that could be the separator. 

Hmm, this might not be straightforward. Maybe a better approach is to try parsing the entire string as a date part first, then see if the remaining part is a time.

Alternatively, the code can first check if there is a time portion by looking for a time separator (like T or space) followed by time-like characters. But this could be error-prone.

Alternatively, the code can split the string into parts using a regular expression that captures the date part first, then the time part, then the timezone.

Let me try to design a regex that can parse the entire string.

The regex would need to capture:

- The date part (various formats)
- The time part (optional)
- The timezone part (optional)

Let me structure the regex as follows:

The entire string can be broken down into:

date_part (mandatory) + (separator + time_part)? + (timezone_part)?

So, the regex can be:

^
(?P<date_part>...)
(?P<separator>[^0-9W-])?  # Maybe? Not sure
(?P<time_part>...)?
(?P<timezone_part>...)?
$

Hmm, perhaps not. Alternatively, the date_part can be captured with a regex that matches all the possible date formats, then the time part is captured after a single separator character.

Alternatively, the regex for the date part would be something like:

date_pattern = r"""
    (?P<year>\d{4})         # YYYY
    (?:                    # Optional month and day
        (?:-?              # Hyphen or not?
            (?P<month>\d{2})  # MM
            (?:-?          # Hyphen again?
                (?P<day>\d{2})  # DD
            )?
        )?
    )?
    |                      # Or
    (?P<year_week>\d{4})-?W
    (?P<week>\d{2})        # ISO week
    (?:-?                  # Optional day
        (?P<day_of_week>\d)
    )?
"""

Wait, this is getting complicated. Maybe breaking down each possible date format into regex alternatives.

Let me try to outline the regex for the date part:

The date can be:

1. YYYY (year only)
   regex: \d{4}

2. YYYY-MM or YYYYMM (year-month)
   regex: \d{4}[-]?\d{2} (but must ensure that it's either with hyphen or without, but length is 6 or 7?)

Wait, YYYY-MM is 7 characters (like 2020-01), while YYYYMM is 6 (like 202001). So the regex can be (?:\d{4}-\d{2}|\d{6})

3. YYYY-MM-DD or YYYYMMDD (full date)
   10 characters with hyphens (like 2020-01-02) or 8 digits (like 20200102). So regex: (?:\d{4}-\d{2}-\d{2}|\d{8})

4. YYYY-Www or YYYYWww (ISO week, no day)
   The format is like 2020-W12 or 2020W12. The week is two digits. So regex: \d{4}-?W\d{2}

5. YYYY-Www-D or YYYYWwwD (ISO week and day)
   Like 2020-W12-3 or 2020W123. The day is one digit. So regex: \d{4}-?W\d{2}-?\d

So combining all these possibilities into a regex for the date part:

date_re = r"""
    (?:
        (?P<year_only>\d{4}) |
        (?P<year_month>(?:\d{4}-\d{2}|\d{6})) |
        (?P<full_date>(?:\d{4}-\d{2}-\d{2}|\d{8})) |
        (?P<iso_week>(?:\d{4}-?W\d{2})) |
        (?P<iso_week_day>(?:\d{4}-?W\d{2}-?\d))
    )
"""

Wait, but each alternative needs to be captured properly. Maybe using named groups for each case. But this might get complicated. Alternatively, the code can parse the date part first, determine which format it is, then extract the components.

Alternatively, the code can first parse the date part using a regex that captures all possible date formats, then extract the components from the groups.

Hmm, perhaps the code can split the string into parts first. Let me think of the steps again:

The code needs to:

1. Split the input string into the date part, time part (optional), and timezone part (optional).

   The date and time are separated by a single character (the separator). The time part may include a timezone.

   So first, split the input into date_part and the rest (time_part_plus_timezone):

   The separator is the first character after the date_part. But how to find where the date_part ends?

   Alternatively, the code can iterate through the string and check for possible date formats. Let's see:

   For example, for the string "2020-01-02T12:34:56Z", the date_part is "2020-01-02", then the separator is 'T', then the time and timezone.

   To find the end of the date_part:

   The code can check possible date formats and see which one matches the beginning of the string.

   For example, check if the first 4 digits are a year (year_only). Then see if there are more characters indicating a longer date format.

   Alternatively, the code can try different regex patterns for the date part and see which one matches.

   Let me try to structure this.

   The code can first parse the date part using a regex that matches any of the possible date formats, then capture the end of the date part.

   So, the date regex could be:

   r"""
   ^(?P<date>
      (?P<year>\d{4})          # 1. YYYY
      (?:-?                    # optional hyphen
         (?P<month>\d{2})      # 2. YYYY-MM or YYYYMM
         (?:-?                 # optional hyphen
             (?P<day>\d{2})    # 3. YYYY-MM-DD or YYYYMMDD
         )?
      )?
      |                        # OR
      (?P<year_week>\d{4})-?W  # 4. YYYY-Www or YYYYWww
      (?P<week>\d{2})          # week number
      (?:-?                    # optional hyphen
         (?P<day_week>\d)      # 5. YYYY-Www-D or YYYYWwwD
      )?
   )
   """

Wait, but this is getting a bit complex. Maybe the code can use a series of regex patterns for each possible date format and see which one matches the start of the string.

Alternatively, the code can first check if the string starts with a 4-digit year. Then look for more digits or hyphens to determine the format.

Alternatively, here's a possible approach:

- Start parsing from the beginning of the string.

- First, check if the date is in one of the common formats:

   - YYYY (4 digits)
   - YYYY-MM or YYYYMM (6 or 7 characters)
   - YYYY-MM-DD or YYYYMMDD (10 or 8 characters)

- Then check the uncommon formats (ISO week):

   - YYYY-Www or YYYYWww (e.g., 2020-W12 or 2020W12)
   - YYYY-Www-D or YYYYWwwD (e.g., 2020-W12-3 or 2020W123)

Once the date part is parsed, the remainder of the string after the date is split into time and timezone.

But how to determine where the date part ends?

Alternatively, the code can iterate through possible date formats:

For example, check if the first 4 characters are digits (year). Then check for possible extensions:

   If the next characters form a month and day, etc.

Alternatively, perhaps the best approach is to use a regular expression that captures the entire date part, then the rest of the string after the separator.

Wait, here's an idea:

The entire string can be parsed with a regex that first captures the date part (using a group for each possible date format), then captures the separator (any single character), then the time part, then the timezone.

The regex would look something like this:

r"""
^
(?:
    (?P<year_only>\d{4}) |
    (?P<year_month>\d{4}[-]?\d{2}) |
    (?P<full_date>\d{4}[-]?\d{2}[-]?\d{2}|\d{8}) |
    (?P<iso_week>\d{4}[-]?W\d{2}) |
    (?P<iso_week_day>\d{4}[-]?W\d{2}[-]?\d)
)
(?P<separator>[^0-9W-])?  # The separator is a single non-date character
(?P<time>
    (?P<hour>\d{2})
    (?:[:.]?  # decimal or colon separator?
        (?P<minute>\d{2})
        (?:[:.]?  # for seconds?
            (?P<second>\d{2}(?:\.\d{1,6})?)?
        )?
    )?
)?
(?P<timezone>
    [Zz] |
    (?P<offset_sign>[-+])
    (?P<offset_hour>\d{2})
    (?:[:]? (?P<offset_minute>\d{2}))?
)?
$
"""

Wait, this is very rough. The regex would have to account for all the possible date formats, then the separator, then time, then timezone.

This seems quite complex, but perhaps manageable.

Alternatively, perhaps the code can first split the string into date and time parts using a regex that matches the entire date portion.

Once the date portion is parsed, the remaining part can be parsed for time and timezone.

Let me try to code this step by step.

First, parsing the date part.

The code can start by checking the possible date formats:

date_str = dt_str.split(sep, 1)[0] if there is a separator, but how to find the separator?

Alternatively, the code can split the string at the first occurrence of a character that is not part of the date's allowed characters. For example, the date part can only contain digits, hyphens, 'W', or letters? Wait, the date formats use only digits, hyphens, and 'W'.

So any character not in [0-9W-] could be the separator. So the code can find the first occurrence of a character not in those, then split there.

So:

import re

def isoparse(dt_str):
    # first, split into date and time parts
    separator_pos = None
    for i, c in enumerate(dt_str):
        if c not in '0123456789W-':
            separator_pos = i
            break
    if separator_pos is None:
        # no separator, so it's just a date with no time
        date_part = dt_str
        time_part = ''
        tz_part = ''
    else:
        date_part = dt_str[:separator_pos]
        rest = dt_str[separator_pos+1:]
        # split rest into time and timezone
        # ... more code here

But this might not capture all cases. For example, in "2020W12-3T12:00Z", the 'T' is the separator between date and time. The code would split at the 'T' (since it's not a digit/W/hyphen), so the date_part is "2020W12-3".

Wait, but the hyphen in the ISO week day case (like "W12-3") is allowed. So the code's approach would split at the '-', which is part of the date. That's a problem. Because in "YYYY-Www-D" like "2020-W12-3", the '-' is part of the date format. So the code's approach would split at the first non-allowed character, but in that case, the first such character would be the 'T' in the example, but if there is no time, then the '-' in the date part would be considered as a separator, which is incorrect.

Hmm, so this approach won't work. Because the date part can contain hyphens and W, so the first non-allowed character is the separator between date and time.

Therefore, the only way to find the separator is to parse the date part first, then see where it ends.

Alternatively, perhaps the code can first parse the entire string into possible date parts, then see if there's a time part after.

Alternatively, the code can use a regex to parse the entire string, capturing all the components.

Let me think of a regex that can parse the entire string.

The regex needs to account for all possible date and time formats, plus the separator and timezone.

Let me try to structure it step by step.

First, the date part can be one of:

1. Year only (YYYY)
2. Year-month (YYYY-MM or YYYYMM)
3. Full date (YYYY-MM-DD or YYYYMMDD)
4. ISO week (YYYY-Www or YYYYWww)
5. ISO week and day (YYYY-Www-D or YYYYWwwD)

Each of these can be captured with named groups.

Then, after the date part, there may be a separator (any single character) followed by the time part.

The time part can be:

- hh (e.g., 12)
- hh:mm (12:34)
- hhmm (1234)
- hh:mm:ss (12:34:56)
- hhmmss (123456)
- hh:mm:ss.ssssss (12:34:56.123456) but the caution says fractions are not implemented, so maybe ignore that part.

Midnight can be 00:00 or 24:00.

The time can have a decimal separator (dot or comma), but in the time part, the decimal is only in the seconds component. Wait, the time formats include seconds with fractions. But according to the caution, the code doesn't support fractional components beyond seconds. So perhaps the regex can ignore those.

The timezone part can be:

- Z (UTC)
- ±HH:MM (e.g., +05:00)
- ±HHMM (e.g., -0500)
- ±HH (e.g., +05)

The regex can be structured as follows:

date_part_pattern = r"""
    (?:
        (?P<year_only>\d{4}) |
        (?P<year_month>(?:\d{4}-\d{2}|\d{6})) |
        (?P<full_date>(?:\d{4}-\d{2}-\d{2}|\d{8})) |
        (?P<iso_week>(?:\d{4}-?W\d{2})) |
        (?P<iso_week_day>(?:\d{4}-?W\d{2}-?\d))
    )
"""

time_part_pattern = r"""
    (?:
        (?P<hour>\d{2})
        (?:
            (?:[:.]?  # decimal or colon?
                (?P<minute>\d{2})
                (?:[:.]?
                    (?P<second>\d{2})
                    (?:\.\d{1,6})?  # fractional seconds, but ignored
                )?
            )?
        )?
    )?
"""

timezone_pattern = r"""
    (?:
        [Zz] |
        (?P<offset_sign>[-+])
        (?P<offset_hour>\d{2})
        (?:
            [:-]?  # separator between hour and minute
            (?P<offset_minute>\d{2})
        )?
    )
"""

Putting it all together:

The full regex would be:

r"""
^
(?P<date_part>
    (?:
        (?P<year_only>\d{4}) |
        (?P<year_month>(?:\d{4}-\d{2}|\d{6})) |
        (?P<full_date>(?:\d{4}-\d{2}-\d{2}|\d{8})) |
        (?P<iso_week>(?:\d{4}-?W\d{2})) |
        (?P<iso_week_day>(?:\d{4}-?W\d{2}-?\d))
    )
)
(?P<separator>[^0-9W-])?  # separator between date and time, optional
(?P<time_part>
    (?:
        (?P<hour>\d{2})
        (?:
            (?:[:.]?
                (?P<minute>\d{2})
                (?:
                    [:.]?
                    (?P<second>\d{2})
                    (?:\.\d{1,6})?
                )?
            )?
        )?
    )?
)?
(?P<timezone>
    (?:
        [Zz] |
        (?P<offset_sign>[-+])
        (?P<offset_hour>\d{2})
        (?:
            [:-]?
            (?P<offset_minute>\d{2})
        )?
    )
)?
$
"""

Wait, but this might not capture all cases. For example, the separator is optional, but if there is a time part, there must be a separator. Also, the regex might have overlapping groups.

Alternatively, perhaps the code can use the regex to match the entire string and capture the necessary groups.

But this is getting quite complex. Maybe it's better to split the problem into parts.

First, parse the date part:

Parse the date part into its components (year, month, day, week, day_of_week).

Then, parse the time part (if present), then the timezone.

Once all components are parsed, construct the datetime object.

Let me try to outline the steps in code:

def isoparse(self, dt_str):
    # Split into date_part, time_part, timezone_part
    # using regex or other methods
    # parse date_part into date components
    # parse time_part into time components
    # parse timezone_part into timezone info
    # combine into a datetime with appropriate timezone

    # Let's start with splitting the string.

    # Use a regex to parse the entire string.
    import re

    # Define the regex pattern
    pattern = r"""
    ^(?P<date>
        (?P<year>\d{4})  # 1. YYYY
        (?:-?             # optional hyphen
            (?P<month>\d{2})  # 2. month part
            (?:-?         # optional hyphen
                (?P<day>\d{2})  # 3. day part
            )?
        )?
        |                 # OR
        (?P<year_week>\d{4})-?W
        (?P<week>\d{2})  # 4. ISO week number
        (?:-?             # optional hyphen
            (?P<day_week>\d)  # 5. day of week
        )?
    )
    (?P<separator>[^0-9W-])?  # separator between date and time
    (?P<time>
        (?P<hour>\d{2})
        (?:[:.]?
            (?P<minute>\d{2})
            (?:[:.]?
                (?P<second>\d{2})
                (?:\.\d{1,6})?  # fractional seconds
            )?
        )?
    )?
    (?P<timezone>
        [Zz] |
        (?P<offset_sign>[-+])
        (?P<offset_hour>\d{2})
        (?:[:]? (?P<offset_minute>\d{2}))?
    )?
    $"""

    # Compile the regex with verbose flag
    regex = re.compile(pattern, re.VERBOSE)

    match = regex.match(dt_str)
    if not match:
        raise ValueError("Invalid ISO-8601 datetime string")

    # Extract groups
    groups = match.groupdict()

    # Now parse the date part.

    # Determine which date format was matched.

    # Check if the date was in the first alternative (year, month, day)
    # or the second (ISO week)

    if groups['year'] is not None:
        # Common date format
        year = int(groups['year'])
        month = int(groups['month']) if groups['month'] else 1
        day = int(groups['day']) if groups['day'] else 1
    elif groups['year_week'] is not None:
        # ISO week format
        year = int(groups['year_week'])
        week = int(groups['week'])
        day_week = int(groups['day_week']) if groups['day_week'] else 0
        # Convert ISO week to date components
        # Need to calculate the date corresponding to the ISO week and day
        # The default day is 0 (Sunday?), but according to the docstring, day defaults to 0 for the week format.
        # Wait, the ISO week format's day defaults to 0, but how is that handled?
        # The ISO week starts on Monday (day 1?), but the documentation says that the day defaults to 0 for the week part.
        # Need to use the datetime's isocalendar() method's logic.

        # To find the date from ISO week and day, perhaps use the dateutil.parser.isoparse function's approach, but since we are writing this ourselves...

        # The code can calculate the date for the first day of the week (day 1?), then add the day offset.

        # Let me think: the ISO week starts on Monday (day 1?), but the documentation says that for the YYYY-Www format, day defaults to 0. Wait, the doc says:

        # "Uncommon formats:

        # - YYYY-Www or YYYYWww - ISO week (day defaults to 0)

        # - YYYY-Www-D or YYYYWwwD - ISO week and day"

        # So for the YYYY-Www format, the day is default to 0, which might be Sunday?

        # To calculate the date, perhaps we can use the first day of the week.

        # Alternatively, use the datetime module's isocalendar() method.

        # The approach is to compute the date corresponding to the given year, week, and day.

        # For example, for 2020-W12-3 (year 2020, week 12, day 3):

        # We can start by finding the first day of the year, then find the correct week.

        # Alternatively, use the dateutil module's functions.

        # But since we need to write this without relying on dateutil's parsing (since the function is part of dateutil?), perhaps we need to compute it ourselves.

        # Let's proceed step by step.

        # Let's find the date corresponding to the given year, week, and day.

        # The ISO week starts on Monday (day 1?), so day 0 would be Sunday?

        # The standard says that the first week of the year is the one with at least 4 days in the year.

        # This is a bit complex. Let me look for an algorithm.

        # Here's a method to compute the date from ISO year, week, and day:

        # The algorithm is as follows:

        # 1. The first day of the ISO week (Monday) of week 1 is the day with the date of January 4 minus (day_of_week of January 4).

        # Alternatively, perhaps using