Okay, I need to create a Python function called round_half_to_even that rounds a floating-point number. The description mentions "round half to even", which makes me think of the standard rounding method used in many contexts, like the IEEE 754 round half to even rule. Wait, right, the usual Python round function uses this method when the number is exactly halfway between two integers. So maybe the function is supposed to be similar to the standard round, but perhaps the user wants to implement it manually?

Wait, the function's name is round_half_to_even. The standard round in Python already uses this method. So maybe the task is to implement the same behavior as the built-in round function? Or perhaps there's a specific case here. Let me think again.

The docstring says "Round a floating-point number", but the function's name suggests that it's specifically implementing the half to even rule. But perhaps the user wants a function that rounds to the nearest integer, using that rule. Let me check the standard round function's behavior.

In Python, when you have a number that is exactly halfway between two integers, like 2.5, round rounds to the even integer. For example, round(2.5) is 2, and round(3.5) is 4. So the standard round function already does that. So maybe the function is supposed to just be an alias for round? But that seems too simple. Alternatively, perhaps the user wants to handle rounding to a certain number of decimal places, but the function signature only takes one argument, the number. So maybe the function is supposed to round to the nearest integer using the half-to-even rule, which is exactly what round(n) does when the second argument is 0. Wait, round(n, 0) would give a float, but when you round to the nearest integer, you can just do round(n). For example, round(2.3) is 2, round(2.5) is 2, round(3.5) is 4, etc.

Hmm, maybe the function is supposed to be equivalent to the built-in round function. But then why the name round_half_to_even? Maybe the user wants to implement this behavior manually, perhaps to avoid using the built-in function, or to handle some edge cases differently?

Alternatively, perhaps the user is confused and the function is supposed to round to the nearest integer with the half-to-even rule, but the standard round function already does that, so maybe the function is redundant. But since the problem says to generate code based on the given signature, perhaps the solution is to just return round(n). Let me think again.

Wait, maybe the function is supposed to round to the nearest integer, but when exactly halfway, round to even. That's exactly what the built-in round does. So the code could be as simple as:

def round_half_to_even(n):
    return round(n)

But maybe the user wants to ensure that this is done correctly, so perhaps the unit tests would check that. Let me think about possible test cases.

For example:

Test case 1: 2.5 should round to 2 (since 2 is even)
Test case 2: 3.5 should round to 4 (since 4 is even)
Test case 3: 2.3 rounds to 2
Test case 4: 2.6 rounds to 3
Test case 5: -2.5 rounds to -2 (since -2 is even)
Wait, let's check with the actual Python round function:

Testing in Python:

>>> round(2.5)
2
>>> round(3.5)
4
>>> round(-2.5)
-2
Yes, that's correct.

So the function would indeed work as just returning round(n). 

But perhaps the problem expects more? Maybe the function is supposed to handle more precision, but the function signature only has n as the argument, implying rounding to integer. So the code is straightforward.

However, maybe the user wants to implement it without using the built-in round function, but that seems unnecessary. The problem says to generate code based on the signature and docstring, so perhaps the answer is indeed that simple.

Alternatively, perhaps the function is supposed to handle cases where the number is halfway between two even numbers? Wait, no, the half-to-even rule is when the number is exactly halfway between two integers. The tiebreaker is to choose the even one.

So I think the correct approach here is to write the function as a wrapper around the built-in round function. 

Now, following the test-driven development approach, first write the unit tests. Let's think of some test cases.

Possible test cases:

Test that 2.5 rounds to 2.

Test that 3.5 rounds to 4.

Test that 2.3 rounds to 2.

Test that 2.6 rounds to 3.

Test that 2.0 rounds to 2.

Test that -2.5 rounds to -2 (since -2 is even).

Test that -3.5 rounds to -4 (since -4 is even).

Wait, let's check Python's round(-3.5):

>>> round(-3.5)
-4.0
Yes, so -3.5 rounds to -4, which is even.

Another test case: 4.5 should round to 4 (even).

Hmm, so the unit tests would check these cases. The tests would use the assertEqual or similar to check the output.

So the unit tests would look like:

import unittest

class TestRoundHalfToEven(unittest.TestCase):
    def test_round_half_to_even(self):
        self.assertEqual(round_half_to_even(2.5), 2)
        self.assertEqual(round_half_to_even(3.5), 4)
        self.assertEqual(round_half_to_even(2.3), 2)
        self.assertEqual(round_half_to_even(2.6), 3)
        self.assertEqual(round_half_to_even(2.0), 2)
        self.assertEqual(round_half_to_even(-2.5), -2)
        self.assertEqual(round_half_to_even(-3.5), -4)
        self.assertEqual(round_half_to_even(4.5), 4)
        self.assertEqual(round_half_to_even(-4.5), -4)
        # Edge case where the number is exactly an even integer
        self.assertEqual(round_half_to_even(4.0), 4)
        # What about 0.5? Should round to 0 (even)
        self.assertEqual(round_half_to_even(0.5), 0)
        self.assertEqual(round_half_to_even(-0.5), 0)  # Wait, round(-0.5) is -0.0? Or 0?

Wait, let's check:

>>> round(-0.5)
-0.0, but as an integer, that's 0. So maybe the function would return 0? But in Python, round(-0.5) gives -0.0, but when cast to an integer, it's 0. However, the function's return is a float? Or an integer?

Wait, the function's return type isn't specified. The standard round function returns a float when the second argument (digits) is not zero. But in this case, when rounding to the nearest integer (i.e., digits=0), round(2.5) returns 2.0 as a float. So perhaps the function should return an integer? Or does it return a float? The problem says "round a floating-point number", so maybe the output is an integer. Wait, but the function's return type isn't specified. The code can return the same as round(n), which is a float when using the second argument as 0. But perhaps the user expects an integer. Hmm, perhaps the function should return an integer. Let me see:

Looking at the problem's function signature: it says to return a floating-point number? Or just round it. The docstring says "Round a floating-point number" but doesn't specify the return type. The standard round function returns a float when the second argument is given (like 0), but when no second argument, it returns an integer? Wait no:

Wait, let me check:

In Python:

round(2.5) → 2 (as an integer)
round(2.6) → 3 (as an integer)
But if you do round(2.5, 0), it returns 2.0 (a float).

Ah, right! The first argument is the number, the second is the number of decimals. If the second argument is omitted, the return is an integer. So in the function round_half_to_even(n), the code can just return round(n), which would be an integer. So in the test cases, the function's return should be an integer. For example, round_half_to_even(2.5) should be 2, which matches.

So the test cases need to check integers. So in the test for -0.5, round(-0.5) would return -0, but as an integer, it's 0. So the test should check that it returns 0? Let me check:

>>> round(-0.5)
-0
But in Python, -0 is considered 0 in integers. Wait, actually:

Wait, in Python, the round function when the second argument is not given returns an int. Let me check:

>>> type(round(2.5))
<class 'int'>
Yes. So round(-0.5) returns -0 as an int? Wait, no. Let's see:

Wait, let me run in Python:

>>> round(-0.5)
0

Wait, no. Wait, perhaps I made a mistake here. Let me actually test this.

Wait, I'm confused. Let me check in Python:

>>> round(2.5)
2
>>> round(3.5)
4
>>> round(-2.5)
-2
>>> round(-3.5)
-4
>>> round(-0.5)
0
Wait, so the result is 0, not -0. Because integers in Python don't have a -0 form. So the function returns 0.

So the test for -0.5 should return 0, so that's correct.

Another test case: 1.5 → rounds to 2? No, wait:

Wait, 1.5 is halfway between 1 and 2. The even one is 2. So round(1.5) would be 2? Let me check:

>>> round(1.5)
2

Yes. So the test should include that.

Another test case: 0.5 → 0? No, 0 is even. Wait, 0.5 is halfway between 0 and 1. So the even one is 0. So round(0.5) is 0.

Yes.

So adding these test cases would be good.

Now, the code would be as simple as:

def round_half_to_even(n):
    return round(n)

But I need to make sure that this is correct. So the unit tests would cover all these cases, and the code passes them.

Therefore, the code is straightforward. The user's function is just an alias for the built-in round function, since that's exactly implementing the half-to-even rule.
