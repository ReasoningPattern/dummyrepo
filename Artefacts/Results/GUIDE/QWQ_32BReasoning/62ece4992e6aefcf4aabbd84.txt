Okay, I need to write a Python function called is_ipv4 that checks if a given target is a valid IPv4 address. Let me think about how to approach this.

First, I remember that an IPv4 address is in the format of four numbers separated by dots, like 192.168.1.1. Each part should be between 0 and 255. Also, there should be exactly four parts. So the steps are probably: split the target by dots, check if there are four parts, then each part must be a number between 0-255.

Hmm, but how to handle edge cases? Like leading zeros? Oh right, according to some standards, leading zeros are allowed in IPv4 addresses. For example, 192.168.01.01 is technically valid, but maybe the function should accept it. Wait, the problem says "test if IPv4 address or not". The standard might not consider leading zeros as invalid, so perhaps the function should allow them. But I need to confirm.

Wait, actually, when you split the address into octets, each octet must be a string that can be converted to an integer between 0 and 255. However, leading zeros in the string would be okay as long as the numeric value is correct. For example, "0" is okay, "00" is also okay, but "256" is over, so that's invalid. So the steps are:

1. Split the target into parts by '.'.
2. If the number of parts isn't 4, return False.
3. For each part:
   a. Check if it's a numeric string. So no letters or other characters.
   b. Convert to integer and check if between 0-255.

Wait, but converting to integer would automatically ignore leading zeros. For example, "012" is 12 as an integer, but the problem is whether the string is acceptable. Since the standard allows leading zeros, like 192.168.10.1 is okay, but 192.168.01.1 would also be okay as an address. So the function should accept parts with leading zeros as valid.

Therefore, the steps would be:

- Split into 4 parts. If not, return False.
- Each part must be a string of digits only.
- Each part must convert to an integer between 0 and 255.

So, code steps:

def is_ipv4(target):
    parts = target.split('.')
    if len(parts) !=4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num <0 or num>255:
            return False
    return True

Wait, but what about empty parts? Like if the target ends with a . or has multiple dots. For example, "123..45" would split into [123, '', 45], so the length would be 3, so that's caught by the first check. Also, "192.168.01.02" would split into 4 parts, each part is digits. So leading zeros are okay here.

Wait, but "256.1.1.1" would split into 4 parts, but 256 is over 255, so that would return False. Correct.

Another case: "0.0.0.0" is valid. "255.255.255.255" is okay. "1.2.3.4" is okay. What about "1.2.3.04"? The part "04" is digits, converted to 4, which is okay. So the function would accept that.

What about "123.045.67.89"? The parts 045 is okay as an integer (45), but the leading zero is allowed. So the function would return True here. But is that correct according to IPv4 standards? Hmm, I think that IPv4 addresses allow leading zeros in the octets, but some people might consider them invalid. Wait, actually, the standard allows leading zeros. The problem says "test if IPv4 address or not", so probably the function should accept leading zeros. So the code above is correct.

Now, I need to think about the unit tests first, as per the TDD approach. Let me think of test cases.

Test cases for is_ipv4:

Test valid IPv4 addresses:

- "192.168.1.1" → True
- "0.0.0.0" → True
- "255.255.255.255" → True
- "123.045.67.89" → True (leading zeros allowed)
- "192.168.0.255" → True

Test invalid cases:

- "192.168.1.256" → False (since 256 is over 255)
- "192.168.1.1.1" → False (5 parts)
- "192.168.1" → False (3 parts)
- "abc.def.ghi.jkl" → False (non-numeric parts)
- "2001:0db8:85a3:0000:0000:8a2e:0370:7334" → False (IPv6 address)
- "123.456.78.90" → 456 is over 255 → False
- "01.023.123.255" → leading zeros are okay, but each part is numeric → True? Wait, no, 01 is okay, so the code would return True for that. But is that acceptable? The problem didn't specify that leading zeros are invalid, so according to the function's logic, it would return True. So that's a valid case.

Edge cases:

- Empty string → split into 1 part (since splitting on '.' gives [""] → len 1 → False)
- "0.0.0.0a" → split into 4 parts? Let's see: "0.0.0.0a" splits into ["0", "0", "0", "0a"], the last part has "0a" which is not digits → returns False.

Another test case: "1.2.3" → 3 parts → False.

Now, writing the unit tests. The user wants to generate the code via TDD, so first write the tests, then the code.

But the problem says to output only the code generated. So I can proceed to write the code based on the logic above.

Wait, but wait: the code I wrote earlier may have a problem with empty parts. Like if a part is an empty string, like "192..88.1" would split into parts with an empty string, so is_ipv4 would return False because the part isn't a digit. Also, "123.045.67.89" is okay. 

Another thing: the code checks part.isdigit() which would return True for "0", "045", etc. So that's correct.

Wait, but what about leading zeros? The problem doesn't prohibit them, so that's okay.

So the code seems correct. Now let me write the code as per the function signature.
