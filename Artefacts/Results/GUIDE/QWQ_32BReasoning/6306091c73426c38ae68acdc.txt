Okay, I need to generate Python code for the method validate_from_content based on the given docstring. The function is supposed to validate that the provided YAML content has all the required fields. If something's missing, it should raise an IRValidatorException. Otherwise, return the loaded data as a dictionary.

First, I should think about how to approach this. Since the user mentioned test-driven development, I should start by writing unit tests. But the user wants me to output only the code, so maybe I can just focus on the actual code here. Wait, the problem says to generate the code based on the signature and docstring, so I'll focus on that.

The function is a class method (since it has cls as the first parameter). The parameter spec_content can be None, so maybe it's optional? The method should check if the content has all required fields. But what are the required fields? The docstring doesn't specify, so perhaps they are defined elsewhere in the class, maybe as a class variable like REQUIRED_FIELDS?

Hmm, right, since it's a class method, the required fields might be stored in the class. So the first step is to load the YAML content. Wait, but how do I parse the YAML? I might need to use a YAML parser like PyYAML. The function should load the YAML into a dictionary. Then check if all the required fields are present in that dictionary.

Wait, but the method's return is the dictionary with the data from the spec. So the steps are:

1. Parse the spec_content into a Python dictionary. If there's an error in parsing (like invalid YAML), maybe raise an exception? But the docstring says to raise IRValidatorException when mandatory data is missing, not for parsing errors. So perhaps parsing is handled elsewhere, or maybe the function assumes the content is valid YAML? Or maybe it should first try to parse it, and if that fails, raise an exception? The docstring doesn't mention that, so perhaps it's assumed that the content is valid YAML, and the function's job is just to check required fields.

Alternatively, maybe the function should first parse the YAML, then check the required fields. So first, load the YAML into a dictionary. Then check each required field in that dict. If any are missing, raise the exception.

So, the code outline would be:

@classmethod
def validate_from_content(cls, spec_content=None):
    # parse the YAML content into a dict
    data = load_yaml(spec_content)
    # check required fields
    for field in cls.REQUIRED_FIELDS:
        if field not in data:
            raise IRValidatorException(...)
    return data

But how to load the YAML? The function's parameters take spec_content as a string, so using yaml.safe_load(spec_content). But need to handle possible exceptions from that. Wait, but the docstring says to raise IRValidatorException when mandatory data is missing. So perhaps parsing errors are not handled here, and it's up to the caller to provide valid YAML? Or maybe the method should catch parsing errors and raise something else, but the docstring doesn't mention that. So perhaps the method proceeds under the assumption that the YAML is valid, and only checks for required fields.

Wait, but the function's return is the dictionary from the YAML. So the first step is to parse it. Let's proceed.

So, code steps:

- Load the YAML into a dictionary. If spec_content is None, maybe return an empty dict? Or is that an error? The docstring says the param is the content of the spec file. So if it's None, perhaps the function should raise an exception? Or maybe it's allowed to be optional, but then the required fields check would fail. Hmm, the parameter is optional (default None), so perhaps the function must validate that spec_content is provided. Or maybe the spec_content can be an empty string, but that's unlikely. Maybe the function should first check if spec_content is provided. Like, if spec_content is None or empty, then raise an exception because the content is missing. But that's part of the validation.

Wait, the docstring says to raise when mandatory data is missing in the spec file. So maybe the spec_content itself being None or empty is also an error. So first step: check that spec_content is not None or empty. But how to handle that?

Alternatively, perhaps the function proceeds to parse the YAML, which would throw an error if the content is invalid. But the exception handling for that isn't covered here. The function's responsibility is only to check the required fields once parsed.

Hmm. The code needs to parse the YAML, check required fields, and return the data.

Now, the exception to raise is IRValidatorException. So I need to make sure that class exists. Since the user didn't mention it, perhaps it's part of the existing codebase, so I can just reference it.

Putting this together, the code would be something like:

from yaml import safe_load

class IRValidatorException(Exception):
    pass

class YourClassName:
    REQUIRED_FIELDS = [...]  # the required fields, but the user didn't specify, so maybe in the code example, it's a placeholder?

Wait, but in the given function signature, it's a class method, so the required fields must be defined in the class. For example, the class might have a class variable like REQUIRED_FIELDS = ['field1', 'field2', ...]. Since the user hasn't specified what the required fields are, perhaps the code can just use that variable, assuming it's defined in the class.

So the code for the method:

@classmethod
def validate_from_content(cls, spec_content=None):
    if spec_content is None:
        raise IRValidatorException("Spec content is missing")
    try:
        data = safe_load(spec_content)
    except Exception as e:
        # Not sure, but according to the docstring, maybe this is not part of the validation here. But maybe the function should handle it?
        # The docstring says to raise when mandatory data is missing, not for parsing errors. So perhaps the exception is not caught here, and the caller must handle it?
        # Alternatively, the function could raise a different exception, but the problem says to raise IRValidatorException for missing data.
        # So perhaps the parsing is left as is, and the function proceeds with the data.
        # So proceed under the assumption that data is loaded correctly.
    # Wait, maybe the data could be None if the YAML is empty? Like if spec_content is an empty string. Then data would be None. Then checking required fields would fail.

    # So first, ensure data is a dict.
    if not isinstance(data, dict):
        raise IRValidatorException("Spec content must be a valid YAML dictionary")

    for field in cls.REQUIRED_FIELDS:
        if field not in data:
            raise IRValidatorException(f"Mandatory field '{field}' is missing")

    return data

Wait, but the data could be None if the YAML is empty. So adding a check for that. Also, the data should be a dictionary, so maybe check that.

Hmm, but maybe the code should first load the data, then check if it's a dict. Also, in the case where the YAML is invalid, like if it's a list instead of a dict, then the parsing would still work, but the data is a list, which is not a dict, so that would trigger the exception.

So that covers some cases.

Putting this all together, here's the code:

Wait, but the function is a class method, so it's part of a class. Let me structure the code properly.

Also, the function is supposed to return the data, so after checking all required fields are present, return data.

So the code would look like this:

from yaml import safe_load

class IRValidatorException(Exception):
    pass

class YourClassName:
    REQUIRED_FIELDS = []  # This should be defined with the actual required fields.

    @classmethod
    def validate_from_content(cls, spec_content=None):
        """
        validates that spec (YAML) content has all required fields

        :param spec_content: content of spec file
        :raise IRValidatorException: when mandatory data is missing in spec file
        :return: Dictionary with data loaded from a spec (YAML) file
        """
        if spec_content is None:
            raise IRValidatorException("Spec content is missing")

        try:
            data = safe_load(spec_content)
        except Exception as e:
            raise IRValidatorException(f"Error parsing YAML: {e}")

        if not isinstance(data, dict):
            raise IRValidatorException("Spec content must be a valid YAML dictionary")

        for field in cls.REQUIRED_FIELDS:
            if field not in data:
                raise IRValidatorException(f"Mandatory field '{field}' is missing")

        return data

Wait, but the original docstring says to raise when mandatory data is missing. The parsing error is not covered by that, so perhaps the exception for parsing should not be an IRValidatorException, but maybe let it propagate as a different exception. But the problem says the function should raise IRValidatorException in those cases. Hmm.

Alternatively, maybe the function should only check the required fields after parsing, but not handle parsing errors. So, in that case, the try block isn't needed, and any parsing error would be raised as a normal exception, not caught here.

So, perhaps the code should be:

data = safe_load(spec_content)

But if the YAML is invalid, that would raise a YAMLError, which would not be caught here, and thus the function would not handle that. But according to the docstring's raise condition, it's only for missing mandatory data, not parsing errors. So maybe that's correct.

So adjusting the code accordingly:

def validate_from_content(cls, spec_content=None):
    if spec_content is None:
        raise IRValidatorException("Spec content is required")

    data = safe_load(spec_content)

    if not isinstance(data, dict):
        raise IRValidatorException("Spec must be a valid YAML dictionary")

    for field in cls.REQUIRED_FIELDS:
        if field not in data:
            raise IRValidatorException(f"Missing required field: {field}")

    return data

But what if spec_content is an empty string? Then safe_load returns None, so the isinstance check would fail, raising the appropriate exception.

Okay, this seems better.

Now, the function first checks if spec_content is provided. Then loads the data. Then checks the data is a dict. Then each required field must be present.

The exception messages should be clear, like specifying which field is missing.

Now, the user's code must have the REQUIRED_FIELDS defined in the class. Since that's part of the class, the user would need to define that, but the function uses it.

So the code generated should be as above, assuming the class has the REQUIRED_FIELDS.

Now, the user might have the exception class defined elsewhere, but since the code needs to raise it, we need to have the class defined. So in the code, perhaps we need to import it, but since the problem didn't mention it, maybe we can just define it inline as part of the class's module?

Alternatively, the code might be part of a larger class where the exception is already defined. Since the problem doesn't specify, perhaps it's okay to include the exception definition in the code.

Wait, the function signature uses "IRValidatorException", so the code must have that exception defined. So in the code, I should include the definition of IRValidatorException, unless it's imported from elsewhere. Since the problem doesn't mention that, I'll define it in the code.

Putting it all together, the code would look like this:

from yaml import safe_load

class IRValidatorException(Exception):
    pass

class YourClassName:
    REQUIRED_FIELDS = [...]  # The actual list of required fields

    @classmethod
    def validate_from_content(cls, spec_content=None):
        if spec_content is None:
            raise IRValidatorException("Spec content is required")

        data = safe_load(spec_content)

        if not isinstance(data, dict):
            raise IRValidatorException("Spec must be a valid YAML dictionary")

        for field in cls.REQUIRED_FIELDS:
            if field not in data:
                raise IRValidatorException(f"Missing required field: {field}")

        return data

Wait, but the user's code might have the class name as something else, but since the problem says to output the code, perhaps the class can be named as per the context. Alternatively, maybe the code can be written without the class name, but since it's a class method, the code must be part of a class.

Alternatively, perhaps the function is part of a class like 'SpecValidator', so I can name the class accordingly.

Let me adjust the code with a more appropriate class name, like 'SpecValidator':

class SpecValidator:
    REQUIRED_FIELDS = [...]  # The actual required fields

    @classmethod
    def validate_from_content(cls, spec_content=None):
        ...

So, the final code would include the exception class, the class with the method, and the required fields.

But the problem says to output only the code generated, based on the function signature and docstring. The function is a class method, so the code must be part of a class. The user probably expects the code to include the class definition, the exception, and the method.

Therefore, the complete code would be as above. However, the REQUIRED_FIELDS is left as a placeholder. Since the docstring doesn't specify the required fields, maybe in the code example, it's left as an empty list, or with a comment indicating that it should be defined.

Alternatively, perhaps the code should have the REQUIRED_FIELDS as a class variable, but the user will fill in the actual fields. Since the problem doesn't specify, the code should just include it as a placeholder.

Wait, but in the code, the user might have a different set of required fields. Since the problem says to generate the code based on the signature and docstring, I should not assume the specific fields, so the code can have the REQUIRED_FIELDS as a class variable that the user must define.

So, the code would be:

from yaml import safe_load

class IRValidatorException(Exception):
    pass

class YourClass:
    REQUIRED_FIELDS = []  # Define the required fields here

    @classmethod
    def validate_from_content(cls, spec_content=None):
        """
        validates that spec (YAML) content has all required fields

        :param spec_content: content of spec file
        :raise IRValidatorException: when mandatory data is missing in spec file
        :return: Dictionary with data loaded from a spec (YAML) file
        """
        if spec_content is None:
            raise IRValidatorException("Spec content is required")

        data = safe_load(spec_content)

        if not isinstance(data, dict):
            raise IRValidatorException("Spec must be a valid YAML dictionary")

        for field in cls.REQUIRED_FIELDS:
            if field not in data:
                raise IRValidatorException(f"Missing required field: {field}")

        return data

This should cover the requirements. Let me check the docstring's parameters and return.

The function raises IRValidatorException when mandatory data is missing, which the code does. The return is the data dictionary. The parameters are correctly handled.

Also, the function is a class method, so using cls to access the class's REQUIRED_FIELDS.

I think this should work. The only thing missing is the actual required fields, which the user must define in the class.
