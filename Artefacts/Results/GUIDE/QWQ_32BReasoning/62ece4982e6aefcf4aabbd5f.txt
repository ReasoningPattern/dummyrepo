Okay, I need to write a Python function called paging that takes a response list and a max_results integer, and returns a generator that splits the response into pages of max_results each. Let's see.

First, the function signature is given. The docstring says it returns a generator that splits the WAPI response into pages. So the generator should yield chunks of the response list, each chunk up to max_results in length.

Hmm, how to approach this. Let's think of the steps. The generator needs to iterate over the response list in chunks. For example, if the response has 10 items and max_results is 3, the first chunk is 0-2, next 3-5, then 6-8, and the last chunk is 9. So each yield gives a sublist.

So the plan is: loop from 0 to the length of the response, stepping by max_results each time. For each step, take a slice from i to i+max_results. Then yield that slice.

Wait, but how to handle the loop? Maybe using a loop with a range that goes up in steps of max_results. The start indices would be 0, 3, 6, etc. Then each slice is response[start:start+max]. But the end of the list might be shorter than max, but that's okay because slicing beyond the end just returns what's there.

So the code structure would be something like:

def paging(response, max_results):
    start = 0
    end = len(response)
    while start < end:
        yield response[start:start+max_results]
        start += max_results

Wait, but maybe using a for loop with range? Like for i in range(0, len(response), max_results): yield response[i:i+max_results]

Yes, that's even simpler. So that's the core idea. Let me check edge cases.

What if max_results is 0? Oh, but the function says max_results is an int. Wait, but the problem says "maximum number of objects to be returned in one page". So max_results should be a positive integer. But what if someone passes 0? The code might have a problem. But the function's docstring probably expects that max_results is a positive integer. So maybe we can assume that, but perhaps the code should handle it. Hmm, but according to the problem, the code should just split as per the given parameters. So perhaps the function should not handle invalid inputs, like if max_results is zero or negative. So the code can proceed under the assumption that max_results is a positive integer.

Another case: empty response. If response is empty, the generator should yield nothing. Which the code would handle.

Another case: max_results is larger than the response length. Then the entire list is yielded once.

So the code using a for loop over the range with step size max_results would work. Let's test with some examples.

Suppose response is [1,2,3,4,5], max is 2. The slices would be [1,2], [3,4], [5]. So the generator yields those three lists. That's correct.

So the code can be written as:

def paging(response, max_results):
    for i in range(0, len(response), max_results):
        yield response[i:i+max_results]

Wait, that's it? That seems correct. Let me think again. The for loop runs i from 0, stepping by max each time. Each iteration takes the slice from i to i+max. So yes, that's exactly what's needed.

Now, the unit tests. Since the user mentioned to use test-driven development, first write the tests before the code. But the problem says to output only the code, so perhaps I can think of the tests to ensure the code is correct.

Let me think of test cases.

Test 1: empty list. Should return nothing. So when converted to a list, it's empty.

Test 2: list with 5 elements, max 2. The generator should produce 3 pages: [0-1], [2-3], [4].

Test 3: max larger than list length. So one page with all elements.

Test 4: max 1. So each element is a separate page.

Test 5: max 0? But perhaps the function expects max to be positive. So maybe the code can raise an error? But according to the problem's docstring, it just says max_results is an int, so perhaps it's allowed. Wait, but dividing into pages with 0 elements per page would be impossible, so maybe the code should check for that. Oh, right! If max_results is zero, then the code would loop infinitely? Let's see.

Wait, in the code I proposed, if max_results is 0, then the step in the range is zero. So range(0, 5, 0) would throw an error because the step must be positive. So in that case, the code would raise a ValueError. So perhaps the function should validate that max_results is a positive integer. But according to the problem's function description, the args are response (list) and max_results (int). The code may need to handle that. But perhaps the problem expects that the function will just proceed, so maybe the user is supposed to handle that in their code. Since the problem didn't mention any error handling, perhaps the code can proceed as is, assuming that max_results is positive.

In the generated code, we can proceed with the code I have. So the code is correct.

Therefore, the code is as simple as the for loop with the yield.
