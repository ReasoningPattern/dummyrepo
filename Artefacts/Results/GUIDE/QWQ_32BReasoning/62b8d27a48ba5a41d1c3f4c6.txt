Okay, I need to create a Python decorator called cached that uses a cache object. The decorator should take parameters like cache, key, and lock. Let me think about how decorators with parameters work. The outer function (cached) returns the actual decorator that wraps the target function.

First, the key function is probably used to generate a unique key for the cache. The default is hashkey, which I assume is a function that can take arguments and return a hash. But wait, the user hasn't provided what hashkey is. Maybe I should assume that hashkey is a function that the user is supposed to have, or maybe I need to create it? Hmm, the problem says to generate the code based on the given signature and docstring. The docstring mentions that the decorator saves results in the cache. So the key function must generate a key based on the function's arguments.

The lock parameter is optional, which suggests that if provided, it should be used to synchronize access to the cache to prevent race conditions. So when multiple threads are trying to compute the same key, the lock would ensure only one does the actual computation.

Let me outline the steps:

1. The cached decorator will return a wrapper function. The wrapper will check if the key exists in the cache. If it does, return it. If not, compute the result, store it in the cache, and return it.

2. The key is generated by the key function, which probably takes the function's args and kwargs. Wait, but how does the key function have access to the function's arguments? Oh right, the key function is passed to the decorator, so the wrapper function can call key with the function's arguments when it's called.

Wait, the parameters for the cached decorator are cache (the cache object), key (a function to generate the key, defaulting to hashkey), and lock (optional). So the key function must take the same arguments as the decorated function. Or does the key function need to be a function that can take the function's arguments? For example, when the user decorates a function with @cached(...), the key function is called with the function's *args and **kwargs to generate the key. That makes sense.

So the steps for the wrapper:

- When the decorated function is called, first compute the key by calling key(*args, **kwargs).

- Check if the key is in the cache. If yes, return the value.

- If not, acquire the lock if provided (to prevent multiple threads from computing the same thing).

- Then call the original function with the arguments, get the result.

- Store the result in the cache with the key.

- Release the lock if used.

- Return the result.

But how to handle the lock? The lock is an object with acquire and release methods. So in code:

def cached(cache, key=hashkey, lock=None):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(*args, **kwargs)
            if k in cache:
                return cache[k]
            if lock is not None:
                lock.acquire()
            try:
                # Check again in case another thread added it while waiting for the lock
                if k in cache:
                    result = cache[k]
                else:
                    result = func(*args, **kwargs)
                    cache[k] = result
                return result
            finally:
                if lock is not None:
                    lock.release()
        return wrapper
    return decorator

Wait, but in the case where the lock is used, after acquiring the lock, we check again because another thread might have already computed it. That's the double-checking step. That's important to avoid race conditions.

Also, need to use try/finally to make sure the lock is released even if an exception occurs.

But wait, the key function's signature must accept the same parameters as the decorated function. So the key function is passed the same *args and **kwargs as the original function. So the user must provide a key function that can generate a unique key based on the function's arguments.

Now, the problem is that the user might not have the hashkey function. But the problem's signature shows that the default is hashkey, so perhaps that's a predefined function. But since I'm writing the code, maybe I should include that? Wait, the problem says to generate the code based on the given signature and docstring. So the code for the cached decorator must be written, but the hashkey function isn't part of it. So perhaps the user is supposed to have that function, so we can just use it as the default.

Wait, but in the code above, the default is key=hashkey, so the code needs to have hashkey defined. But in the problem, the user hasn't provided that. So maybe the hashkey is part of the parameters, but the default is a function that the user is supposed to have. Hmm, perhaps I need to include a placeholder or assume that hashkey is in the scope. Alternatively, maybe the hashkey is a parameter that the user must provide. But according to the problem's function signature, the default is hashkey. So the code must have that variable in scope. Wait, but that might be an error unless I define it. So maybe I should include a dummy hashkey function? Or perhaps the problem expects that the key function is passed, and the default is just a placeholder. Wait, perhaps the actual code for the decorator does not need to define hashkey, since the problem's code expects that the user provides it. But in the generated code, the decorator's default is hashkey, so that must be a variable in the same scope. Therefore, perhaps in the code I need to define hashkey as a function that can generate a key from the arguments. Alternatively, maybe the problem expects that the key function is responsible for generating the key, and the default is a function that does so. Hmm, perhaps the problem's code expects that the user is to provide the key function, but the default is a function named hashkey that's defined elsewhere. Since the problem doesn't mention that, maybe in the code, the hashkey is a function that the user must have. But in the code I'm writing, perhaps I can just leave it as is, since the problem's signature includes it as the default. 

Alternatively, maybe the hashkey is a function that takes the function's arguments and returns a hash. But in the code, since the problem's code is being written, perhaps the hashkey is a parameter that the user must pass. Wait, no, because the default is hashkey. So the code must have that variable. Therefore, maybe the code should define a default hashkey function. Let me think. Since the problem says to generate the code based on the signature and docstring, perhaps the hashkey is a function that's supposed to be in the same module. Therefore, perhaps I should include a default hashkey function in the code. 

Wait, but in the problem's function signature, the key parameter has a default of hashkey, so that must be a variable in the current scope. So I need to define hashkey somewhere. Let's see. Let me think of the code structure. The code would start with:

def cached(...):
    ...

But the hashkey is needed as the default. So perhaps the code should include a helper function. So maybe I should add a hashkey function that takes the function's args and kwargs and returns a tuple of the arguments, which can be hashed. Wait, but the key must be hashable, so for example, for a function with positional and keyword arguments, the key function could create a tuple of the args and the sorted kwargs items. Alternatively, perhaps the hashkey function is a default that just uses the args and kwargs to generate a unique key. So maybe the code should include that.

Alternatively, perhaps the problem expects that the user is to provide the key function, and the default is just a placeholder. So in the code, the decorator uses the key function as passed, and the default is a function named hashkey which may be defined elsewhere. Since the problem's code is supposed to be the decorator, perhaps the hashkey is not part of the code here, and the user is supposed to have it. But in that case, the code would have an undefined variable. Hmm, that's a problem. So perhaps the hashkey is a function that the user must pass, and the default is just a name, but the code must have that function. Wait, maybe I should include a simple hashkey function in the code.

Alternatively, perhaps the hashkey is a function that takes *args and **kwargs and returns a tuple of the arguments, which can be used as a key. So let's define that. So adding a helper function:

def hashkey(*args, **kwargs):
    return (args, tuple(sorted(kwargs.items())))

Then, the default key is this function. So that's probably necessary. Otherwise, the code would have an undefined name error. So I need to include that.

Wait, but the problem says to generate the code based on the given signature and docstring. The signature includes the default as hashkey, so perhaps the code should include the hashkey function. So I'll add that.

Putting it all together, the code would be something like:

import functools

def hashkey(*args, **kwargs):
    return (args, tuple(sorted(kwargs.items())))

def cached(cache, key=hashkey, lock=None):
    """
    Returns a decorator function that saves the results in the cache
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(*args, **kwargs)
            if k in cache:
                return cache[k]
            if lock is not None:
                lock.acquire()
            try:
                # Double-check after acquiring the lock
                if k in cache:
                    result = cache[k]
                else:
                    result = func(*args, **kwargs)
                    cache[k] = result
                return result
            finally:
                if lock is not None:
                    lock.release()
        return wrapper
    return decorator

Wait, but in the case where the lock is not used, we just proceed. Also, the double-check is important because another thread might have added the key while we were waiting to acquire the lock.

Wait, in the code above, when the lock is not present, there's a possibility that two threads could compute the same result. But that's the trade-off for not using a lock. So the user can choose whether to provide a lock for synchronization.

Another thing: the key function's return must be hashable. The default hashkey returns a tuple of the args and sorted kwargs, which is hashable if the individual elements are hashable. So that's okay.

Now, the unit tests. The problem says to use a test-driven approach, first generating comprehensive unit tests before writing the code. So I need to think about how to test this.

Testing the decorator would involve:

- Testing that the function's result is stored in the cache.

- Testing that subsequent calls with the same arguments return the cached value.

- Testing with and without a lock.

- Testing that the key function is called correctly.

But how to test that? For example, using a mock cache, and checking that the cache is accessed with the correct key.

Possible test cases:

Test 1: Basic usage. The function is called once, the result is stored in the cache. Subsequent calls return the cached value.

Test 2: The key function is used to generate the key. So we can mock the key function and check it's called with the correct arguments.

Test 3: Using a lock. Simulate a multi-threaded scenario where two threads call the function with the same arguments. Only one computes the result, others get it from cache.

But testing multi-threading can be tricky, but maybe using a mock lock that tracks acquisition and release.

Test 4: Check that the wrapper preserves the function's name and docstring (using functools.wraps).

Hmm, but the problem says to output only the code generated, in Python markdown format, so I need to focus on writing the code, but first the tests.

Wait, the problem says to generate the code based on the given signature and docstring, and to use TDD by first writing tests, then code. But the user wants the code, so I have to write the code, but the process would involve writing tests first. However, the user's instruction is to output only the code, not the tests. So maybe the tests are not part of the answer here. Wait, the problem says "Generate Python code based on the function signature and docstring. Output ONLY the code generated, in python markdown format." So the tests are part of the TDD process but the code to be generated is the actual function, not the tests. So I can proceed with writing the code as per above.

Wait, but in the code I wrote earlier, the hashkey function is defined inside the same file. So the code should include that.

Another thing: the cache is an object that must support __contains__, __getitem__, and __setitem__. So the user is responsible for providing a suitable cache, like a dictionary. The decorator doesn't enforce that.

Now, checking for possible errors in the code:

In the wrapper function, when the key is not in the cache, and no lock is used, the code proceeds to call the function, store the result, and return it. That's correct.

When the lock is present:

- acquire the lock.

- check again in case another thread added the result while waiting.

- if not present, compute, store, then return.

Yes, that's correct.

Another point: the 'try' block includes the code after acquiring the lock, and the finally releases the lock. So even if an exception occurs during the function call, the lock is released.

Yes, that's important.

So the code seems okay.

Wait, in the case where the key is not in the cache even after acquiring the lock, the function is called, the result stored. But what if the function call raises an exception? Then the exception is propagated, but the lock is released in the finally clause. That's correct.

Now, I think the code is correct. So I'll write it as above, including the hashkey function.
