Okay, I need to write a Python function called parse_frequency that takes a frequency string and returns a timedelta. Let's see the requirements again. The function should return None if the input is None or "always". Otherwise, it should parse the string into a number and a time unit, then create a timedelta with that. If it can't parse, it raises a ValueError.

Hmm, first, the input is a string like "3 days" or "5 hours". Wait, the example says "3 timeunit" returns timedelta(timeunit=3). Oh right, so the time unit has to be a valid keyword for timedelta's constructor. Let me recall, timedelta can take days, seconds, microseconds, milliseconds, weeks. Oh right, so the units must be one of those. So the possible time units are 'days', 'seconds', 'microseconds', 'milliseconds', 'weeks'. Wait, but maybe the input could have other units like 'hours'? Wait, but the example shows "timeunit" as a variable. But according to the actual timedelta parameters, the valid keywords are days, seconds, microseconds, milliseconds, weeks. So the function can only accept those units. So if the input's unit is 'hours', that's not a valid keyword. Wait, but how would that be handled? Because the user might input "3 hours", but the function can't use that directly. Because timedelta doesn't have an hours parameter. So perhaps the function needs to convert the unit to one of the valid keywords. Like hours would need to be converted to seconds. Hmm, but according to the problem's example, the function should return a timedelta with the timeunit as given. Wait the example says "given '3 timeunit', return timedelta(timeunit=3)", so the unit must be a valid keyword for the timedelta constructor. Therefore, the valid units are the ones that timedelta accepts. So the function must check that the unit is one of those.

So first, the steps:

1. Check if frequency is None or "always" (case-insensitive?), return None.

2. Split the frequency string into number and unit. The input is in the format "number timeunit", like "5 days". So split on whitespace, expecting two parts. If the split doesn't give exactly two parts, error.

3. Parse the number part into an integer. If it's not a valid integer, error.

4. Check the unit is one of the valid units for timedelta. The valid units are 'days', 'seconds', 'microseconds', 'milliseconds', 'weeks'. So if the unit is not in that list, raise error.

5. Then create a timedelta with that unit set to the number. So for example, if unit is 'days', then timedelta(days=number).

Wait, but the example shows "timeunit=3", so the unit is passed as the keyword argument. So yes, that's how it's done.

Now, edge cases: what if the input is "3 Days" (with capital letters)? The function should probably be case-sensitive. Because 'Days' is not a valid keyword. So the unit must be lowercase. So the code should check for exact matches, so the unit must be in the list of valid units as lowercase strings. So the input's unit part must exactly match one of the valid units. So "days" is okay, "Days" is not. So the code must compare case-sensitively.

Now, steps for code:

First, handle the None or "always" case. So:

if frequency is None or frequency.lower() == 'always':
    return None

Wait, but what if the input is "ALWAYS" in uppercase? The problem says if the frequency is "always", but maybe case-insensitive. The problem says "if the frequency is None or 'always'", so maybe it's case-sensitive. Hmm, the problem's description says "if the frequency is None or 'always', return None". So the exact string "always", case-sensitive. So perhaps the code should check for exactly "always" (case-sensitive). Wait, but maybe the user might pass "Always" with a capital A. The problem's wording is ambiguous here. Let me check the problem statement again. The problem says, "if the frequency is None or 'always', return None". So the input must exactly be "always" (lowercase) or None. So the code should compare exactly. So in code:

if frequency is None or frequency == 'always':
    return None

But perhaps better to make it case-insensitive? Because maybe the user might input "Always" or "ALWAYS". But according to the problem's wording, it's only when the string is exactly "always". Hmm, but maybe the problem expects that. Let's stick to the problem's exact wording. So only if it's exactly "always" (lowercase) or None, return None.

So first, check that.

Next, split the input into parts. Split on whitespace. So parts = frequency.split(). If len(parts) != 2: raise ValueError.

Then, try to parse the first part as integer. number = parts[0], so try:

try:
    number = int(parts[0])
except ValueError:
    raise ValueError("Invalid number")

Then check the unit is in the allowed list. allowed_units = {'days', 'seconds', 'microseconds', 'milliseconds', 'weeks'}

if parts[1] not in allowed_units:
    raise ValueError(f"Invalid unit: {parts[1]}")

Then, create the timedelta. So, the unit is parts[1], and the value is number. So how to pass that as a keyword argument?

We can use the ** operator with a dictionary. Like:

kwargs = {parts[1]: number}
timedelta(**kwargs)

So putting it all together.

Wait, but what about the case where the unit is 'weeks'? That's allowed. So yes.

Now, possible test cases:

Test case 1: "3 days" → timedelta(days=3)

Test case 2: "5 seconds" → timedelta(seconds=5)

Test case 3: "invalid" → split into parts? like "invalid" would split into a list of ["invalid"], which is length 1 → error.

Test case 4: "3 hours" → unit 'hours' is not in allowed_units → error.

Test case 5: "3Days" → split into ["3Days"], which is only one part → error.

Test case 6: "5 milliseconds" → okay.

Test case for "always" → returns None.

Test for None input → returns None.

Test for "0 days" → returns timedelta(days=0) which is zero.

Edge case where the number is zero? The problem doesn't say to handle that specially, so just return the timedelta.

Now, for the unit tests. Since the user mentioned to use TDD, first write the tests.

So, in the tests, we need to cover all these cases.

But the code must come after the tests. Wait, but the user wants me to generate the code, so I have to think through the code structure.

Wait, the problem says to output only the code generated in Python markdown format. So the code should be the function plus the necessary imports.

Wait, the function needs to import datetime. So the code will start with:

import datetime

def parse_frequency(frequency):
    ... the code as above ...

Now, possible code outline.

Now, let me think about possible mistakes. What if the unit is 'days' but the user inputs 'day'? Then it would be invalid. So yes.

Another thing: the input must be in the form "number timeunit" with a space. So "5days" would split into ["5days"], so len(parts) is 1 → error.

Now, code steps:

def parse_frequency(frequency):
    if frequency is None or frequency == 'always':
        return None

    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Frequency must be in the form 'number timeunit'")

    try:
        number = int(parts[0])
    except ValueError:
        raise ValueError(f"Invalid number: {parts[0]}")

    unit = parts[1]
    allowed_units = {'days', 'seconds', 'microseconds', 'milliseconds', 'weeks'}

    if unit not in allowed_units:
        raise ValueError(f"Invalid unit: {unit}")

    return datetime.timedelta(**{unit: number})

Wait, but the return statement uses the unit as the keyword. That should work.

Wait, the ** operator with a dictionary. For example, { 'days': 3 } becomes days=3 in the function call.

Yes, that should work.

Now, test cases. Let me think of the unit tests:

Test that "3 days" returns timedelta(days=3).

Test that "5 seconds" returns the right thing.

Test that "0 weeks" returns timedelta(weeks=0).

Test that "3 hours" raises ValueError.

Test that "5Days" (split into two parts?) no, "5Days" would split into ["5Days"], so len(parts) is 1 → error.

Test for "always" returns None.

Test for None returns None.

Test for invalid number like "three days" → parts[0] is 'three', which can't be converted to int → error.

Now, the code seems to handle all these cases.

Another possible edge case: leading or trailing whitespace? Like "  3   days  " → split would still be ["3", "days"], since split() by default splits on any whitespace.

So that's okay.

Now, the problem says to return a datetime.timedelta instance, which the code does.

The return type in the docstring says @return str, but that must be a mistake. The actual return is a timedelta or None. The user probably made a typo. But the code should return the correct type.

So the code should be okay.

Wait, looking back at the docstring:

"@return str, the corresponding datetime" — that's probably a mistake. The function is supposed to return a timedelta. So the code is correct, and the docstring has an error, but the user's instructions are based on the function's description. So the code should return the timedelta.

Therefore, the code is correct as written.

Now, let me code this, including the imports and the function.
