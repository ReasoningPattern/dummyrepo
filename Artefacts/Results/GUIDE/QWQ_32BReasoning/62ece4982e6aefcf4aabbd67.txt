Okay, I need to write a Python function called vertex3tuple that takes a list of vertices and returns a list of tuples. Each tuple should contain a vertex and the two adjacent vertices. If the index is out of bounds, like for the first or last elements, I should wrap around using modulo to get the correct indices.

First, let's think about the problem. The function needs to process each vertex in the input list. For each vertex at index i, the tuple should be (vertices[i-1], vertices[i], vertices[i+1]). But when i is 0, i-1 would be -1, which in Python gives the last element. Wait, but the problem says if the subscript is out of bounds, take the index as 0? Wait, no, the problem says "if the subscript is out of bounds, take the value of index as 0". Wait, maybe I misread that. Let me check the problem again.

The problem says: "If the subscript is out of bounds, take the value of index as 0". Hmm, maybe that's a translation error. Maybe it means that when the index is out of bounds, we use modulo the length of the list to get the correct index. Like, for a circular list. For example, if the vertices are [A,B,C], then for the first element A, the previous would be the last element C (index 2), and the next is B (index 1). For the last element C (index 2), the next would be A (index 0). So the correct way is to use modulo len(vertices) to handle the indices.

Wait, the problem says "if the subscript is out of bounds, take the value of index as 0". Wait, maybe that's a mistranslation. Like, perhaps when the index is out of bounds, we use the modulo to cycle. Let me think. For example, if the vertices list has length n, then for any index i, we can compute (i-1) mod n, i, and (i+1) mod n. That way, it wraps around. But maybe the problem's instruction is that when the index is out of bounds, you take the 0 index? Wait that might not make sense. Let me read the problem statement again:

"If the subscript is out of bounds, take the value of index as 0". Oh, maybe when the index is out of bounds, like for the first element, the previous index would be 0? Wait, that's conflicting. Let me think of an example.

Suppose the vertices list is [v0, v1, v2]. For each vertex:

For v0 (index 0), the previous would be index -1 (which in Python is the last element, but according to the problem's instruction, when out of bounds, use index 0?), so maybe that's not right. Wait, maybe the problem's instruction is that when the index is out of bounds, you use 0 as the index? That would mean for the first element, the previous element would be vertices[0], and the next is vertices[1]. But that would not be correct for a polygon, which is a closed shape. So perhaps there's a mistake in the problem statement. Alternatively, maybe the problem means that when the index is out of bounds, you take the value at 0 (i.e., the first element) as the adjacent point. Hmm.

Alternatively, maybe the problem is that when accessing vertices[i-1] and vertices[i+1], if i-1 or i+1 is out of the list's indices, then you take the element at index 0 (the first element). Wait, but that might not make sense for a polygon. For example, if the list is [A,B,C], then for the first element (index 0), the previous would be index -1 (which in Python is the last element, but according to the problem's instruction, when out of bounds, the index is 0?), so perhaps the previous is vertices[0], and the next is vertices[1]. But that would make the tuple (A, A, B). Which doesn't seem right. Hmm, perhaps I need to re-express the problem's requirement.

Alternatively, perhaps the problem says that when the index is out of bounds, you should take the value at index 0. Wait, maybe the problem is that when the index is out of bounds, you use the first element (index 0) as the adjacent point. For example, for the first element (index 0), the previous would be index -1, which is out of bounds, so we take vertices[0], and the next is vertices[1]. So the tuple would be (vertices[0], vertices[0], vertices[1]). That doesn't sound right. Maybe the problem's wording is a bit off. Alternatively, perhaps the intended approach is to treat the list as circular, so that indices wrap around. In that case, using modulo len(vertices) would be the way to go. Let's proceed with that approach, assuming that the problem wants a circular list where indices wrap around.

So the steps for each i in 0 to len(vertices)-1:

prev_index = (i - 1) % len(vertices)
current = vertices[i]
next_index = (i + 1) % len(vertices)

So the tuple would be (vertices[prev_index], vertices[i], vertices[next_index])

That makes sense for a polygon. So the function needs to create a list of such tuples for each vertex.

Now, let's think about possible test cases.

Test case 1: vertices = [A, B, C]

The result for each vertex:

For A (i=0):

prev is 2 (C), current A, next 1 (B) → (C, A, B)

For B (i=1):

prev A, current B, next C → (A,B,C)

For C (i=2):

prev B (i=1), current C, next 0 (A) → (B, C, A)

So the output would be [(C,A,B), (A,B,C), (B,C,A)]

Another test case: empty list? Well, the problem says vertices is a list. If it's empty, the function should return an empty list.

Another test case with two elements: vertices = [X, Y]

For X (i=0):

prev is (0-1) mod 2 = 1 → Y. next is (0+1) mod2 →1 → Y? Wait, no, (0+1) is 1 mod2 is 1, so next is Y. So tuple is (Y, X, Y).

Wait, for two elements, each vertex has the previous and next as the other element. So for X, the tuple would be (Y, X, Y). For Y, the previous is (1-1)=0 → X, next is (1+1) mod2 is 0 → X. So (X, Y, X). So the output would be [(Y,X,Y), (X,Y,X)].

Another test case: single element. vertices = [Z]. Then for i=0:

prev is (0-1) mod1 → -1 mod1 is 0. next is (0+1) mod1 →1 mod1 is 0. So the tuple is (Z, Z, Z). So the output list would be [(Z,Z,Z)].

Okay, so the function should handle these cases.

Now, the function's signature is def vertex3tuple(vertices):, and returns a list of tuples. The input is a list, the output is a list of 3-tuples.

Now, let's think about how to code this.

First, get the length of the vertices list. Let n = len(vertices). If n is 0, return empty list. Otherwise, loop over each index i in range(n). For each i, compute prev and next indices as (i-1) % n and (i+1) % n, respectively. Then create the tuple (vertices[prev], vertices[i], vertices[next]). Collect all these tuples into a list and return it.

Now, the code:

def vertex3tuple(vertices):
    n = len(vertices)
    result = []
    for i in range(n):
        prev = (i - 1) % n
        current = i
        next_ = (i + 1) % n
        triplet = (vertices[prev], vertices[current], vertices[next_])
        result.append(triplet)
    return result

Wait, but in Python, modulo of negative numbers gives a positive remainder. So (i-1) mod n is correct.

Testing this code with the test cases.

Test case 1: [A,B,C]. Let's say the elements are 0,1,2 for simplicity.

i=0:

prev: (0-1) mod3 = 2 → vertices[2] is 2.

current is 0 (0), next (0+1) mod3 is 1 → 1.

So triplet is (2,0,1).

Wait, but in the example I thought of earlier, the elements were A,B,C. So the first triplet would be (C, A, B). Which matches.

Yes, so code is correct.

Another test case with two elements: [X,Y]

i=0: prev is ( -1) mod2 →1. next is 1 mod2 →1. So triplet (Y, X, Y).

i=1: prev (0) mod2 →0. next (2 mod2 →0). So (X,Y,X). Correct.

Test case with one element [Z]:

i=0: prev ( -1 mod1 →0. next (1 mod1 →0. So (Z,Z,Z). Correct.

Edge case empty list: returns empty. Correct.

Now, the problem's docstring says: "If the subscript is out of bounds, take the value of index as 0". Wait, but in our code, we are using modulo, so maybe the problem's instruction is actually equivalent to that. So our code should be correct.

Now, the user mentioned to first write unit tests, then the code. Let me think of the unit tests first.

Unit tests:

Test case 1: vertices = [0,1,2]

Expected output:

[(2,0,1), (1,1,2), (2,2,0)]? Wait wait, wait, no. Wait, let me re-calculate.

Wait for vertices [0,1,2], the tuples for each index:

i=0:

prev is 2 → vertices[2] is 2. current is 0, next is 1 → vertices[1] is 1. So triplet (2,0,1).

i=1: prev is 0 →0, current 1, next 2 →2 → (0,1,2).

i=2: prev (1) →1, current 2, next (3 mod3 →0 →0 → vertices[0] is 0. So triplet (1,2,0).

So the output should be [(2,0,1), (0,1,2), (1,2,0)].

Wait, so the code produces that, which is correct.

Another test case with two elements:

vertices = ['A', 'B']

Expected output:

[('B', 'A', 'B'), ('A', 'B', 'A')]

Another test case with one element: ['Z'] → [('Z','Z','Z')]

Test with empty list → returns empty.

Now, writing the unit tests using pytest.

The test function would be something like:

import pytest

def test_vertex3tuple_empty():
    assert vertex3tuple([]) == []

def test_vertex3tuple_single():
    assert vertex3tuple(['Z']) == [('Z', 'Z', 'Z')]

def test_vertex3tuple_two():
    result = vertex3tuple(['A', 'B'])
    expected = [('B', 'A', 'B'), ('A', 'B', 'A')]
    assert result == expected

def test_vertex3tuple_three():
    vertices = [0, 1, 2]
    expected = [(2, 0, 1), (1, 1, 2), (1, 2, 0)]  # Wait wait, wait. Let me recheck.

Wait, in the three-element case:

vertices = [0,1,2]

for i=0:

prev is 2 → vertices[2] =2, current is 0, next is 1 →1 → so (2,0,1).

i=1:

prev is 0 →0, current 1, next is 2 →2 → (0,1,2).

i=2:

prev is 1 →1, current is 2, next is (2+1)=3 mod3 →0 → vertices[0] is 0 → triplet (1,2,0).

So the expected list is [(2,0,1), (0,1,2), (1,2,0)].

So the test case for three elements:

def test_vertex3tuple_three():
    vertices = [0, 1, 2]
    expected = [
        (2, 0, 1),
        (0, 1, 2),
        (1, 2, 0)
    ]
    assert vertex3tuple(vertices) == expected

Another test case with a mix of types, like strings and numbers? Maybe not necessary, but the code should handle any type as long as they can be in a list and tuples.

So the tests should cover these cases. The code should be correct.

Now, the user wants me to output the code only, in Python markdown format. So the code is as I wrote above.
