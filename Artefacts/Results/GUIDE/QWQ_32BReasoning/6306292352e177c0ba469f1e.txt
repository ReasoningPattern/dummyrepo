Okay, I need to write a Python function called process_text_links that processes links in some text. The docstring says it should add some attributes and linkify textual links. Hmm, not entirely sure what "adding some attributes" means here. Maybe it's adding HTML attributes like target="_blank" or rel="nofollow" to existing links? And linkify means turning plain text URLs into actual hyperlinks?

First, I should think about how to approach this. Since the user mentioned test-driven development, I should start by writing unit tests before the actual code. Let me outline what the function might do.

For the linkifying part, maybe the function scans the text for URLs that aren't already wrapped in <a> tags and turns them into links. For example, "Check out http://example.com" would become "Check out <a href="http://example.com">http://example.com</a>".

Adding attributes could mean that existing links in the text (those already in <a> tags) get extra attributes. Like adding target="_blank" so links open in a new tab, or a rel attribute like "noopener nofollow".

So the steps the function might take are:

1. Find all existing links in the text (using regex to find <a> tags).
2. Modify those links by adding the desired attributes.
3. Find any plain text URLs not already linked and turn them into links with the attributes.

Wait, but how to distinguish between existing links and new ones? Maybe first process existing links, then process the rest of the text for URLs.

Alternatively, process the text in two passes: first, find and modify existing links, then look for URLs in the remaining text to linkify.

Alternatively, maybe the function uses a regex to find all URLs, then wraps them in <a> tags with the necessary attributes. But existing links need to have their attributes updated.

Hmm, this is a bit ambiguous. Let me think of possible test cases to clarify.

Test cases:

Test 1: An existing link with some attributes. The function should add the new attributes without duplicating existing ones.

For example, input: "<a href='http://example.com'>link</a>"
Output: "<a href='http://example.com' target='_blank' rel='nofollow'>link</a>"

Test 2: A plain URL in text. It should be converted to a link with the attributes.

Input: "Visit http://example.com"
Output: "Visit <a href='http://example.com' target='_blank' rel='nofollow'>http://example.com</a>"

Test 3: A mix of existing and new links. Existing links get the new attributes, new ones get converted.

Input: "Existing: <a href='http://old.com'>old</a>. New: https://new.com"
Output: "Existing: <a href='http://old.com' target='_blank' rel='nofollow'>old</a>. New: <a href='https://new.com' target='_blank' rel='nofollow'>https://new.com</a>"

Test 4: URLs with different schemes like https, ftp, etc. All should be linkified.

Test 5: URLs with query parameters and such should still be matched.

Now, the actual implementation. How to do this in Python?

First, for existing links, find all <a> tags, extract their href, and then re-insert them with the new attributes. But how to ensure that existing attributes are not overwritten? Like, if there's a target="_self" already, should we replace it? The problem description says "adding some attributes", so perhaps we just add the new ones, not replace existing.

So for existing links, append target and rel attributes.

For linkifying, find any URLs that are not already in an <a> tag and wrap them.

This requires a two-step process: first process existing links, then process the rest of the text for URLs.

Alternatively, use a regex to find all URLs, but differentiate between those already in a link and those not. That might be tricky.

Alternatively, first process existing links to add the attributes, then find all non-linked URLs and wrap them.

To do the first step, perhaps use a regex to find all <a> tags, check if they have the desired attributes, and modify them. Then, for the rest of the text, find URLs.

Hmm, perhaps the approach is:

1. Find all existing <a> tags, modify them by adding the target and rel attributes if not present. Then replace them in the text.

2. Then, in the modified text, find all URLs that are not already within an <a> tag and wrap them with an <a> tag with the required attributes.

Alternatively, maybe split the text into parts that are links and non-links, process each part accordingly.

Alternatively, using a regular expression to first handle existing links.

Wait, maybe the steps are:

First, process existing links:

Use a regex to find all <a> tags. For each match, check if they have the target and rel attributes. If not, add them. Then, replace the original <a> with the modified one.

Then, process the rest of the text to find URLs that are not in any <a> tags and turn them into links with the attributes.

Alternatively, perhaps it's easier to first process the text to find all URLs, then check if they are already links. But that might require a more complex regex.

Alternatively, here's a possible approach:

The function will use two regex substitutions:

First, for existing links:

Find all <a> tags, and modify their attributes.

Second, find any URLs in the text that are not already within an <a> tag and wrap them.

But how to do the second part?

Alternatively, the second step can use a regex to find URLs that are not preceded by <a href=... and then wrap them.

Hmm, that's tricky. Maybe using a negative lookbehind, but regex lookbehinds can be limited in some regex flavors.

Alternatively, split the text into tokens, but that's complicated.

Alternatively, process the text in two passes:

First, process existing links by adding attributes.

Second, process the text again to find URLs not in links and wrap them.

Let me think of the first step.

To modify existing links:

The regex could be something like:

<a\s+[^>]*>

But to capture the attributes. Wait, perhaps:

Use a regex to find all <a> tags, then parse each to check if the attributes are present.

Alternatively, use a regex to replace all <a href="..."> with the href plus the new attributes.

Wait, perhaps the regex can be:

For existing <a> tags:

The pattern would be r'<a ([^>]+)>'

Then, the replacement would be '<a \1 target="_blank" rel="nofollow">'.

But that would add the attributes even if they already exist, leading to duplication like target="_blank" target="_blank".

Hmm, that's a problem. So perhaps need to check if the attributes are already present.

Alternatively, the replacement should append the attributes only if they aren't already there.

This is getting complicated. Maybe better to use a parser for HTML, but that might be overkill.

Alternatively, accept that the code may add duplicate attributes, but perhaps the problem expects that.

Alternatively, the problem expects that existing links are modified to have those attributes regardless of existing ones, so just append them.

Alternatively, the problem's "adding some attributes" could mean that those attributes are added even if they are already present. For example, adding target="_blank" even if the link already has it.

Well, perhaps the problem expects that. Let's proceed under that assumption.

So first step: modify existing links to add target and rel.

Second step: find all URLs not already in a link and turn them into links with those attributes.

So for step 1, the regex substitution for existing links:

The regex pattern would be something like:

<a\s+[^>]*href\s*=\s*(?:"([^"]*)"|'([^']*)'|([^\s>]+))[^>]*>

But this is getting too complex. Maybe a simpler approach.

Alternatively, use a regex to find all <a> tags and then insert the new attributes at the end, regardless of existing ones. So:

The regex would be r'(<a [^>]*>)' and replace with r'\1 target="_blank" rel="nofollow"'

Wait, but that would append the attributes after the existing ones. So for example, if the existing tag is <a href="x" target="_self">, the replacement would become <a href="x" target="_self" target="_blank" rel="nofollow">. Which is not ideal, but maybe acceptable.

Alternatively, perhaps the problem expects that the attributes are added even if they exist. Alternatively, maybe the problem expects that the attributes are added only if they don't exist, but that requires more complex regex.

Alternatively, perhaps the problem's "adding some attributes" is simply adding target="_blank" and rel="nofollow" to all links, existing or new.

So for existing links, we can add those attributes regardless of existing ones, and for new links, they get those attributes.

In that case, the first step is to process existing links by adding the attributes. The second step is to find URLs not in links and turn them into links with those attributes.

So, let's proceed with that.

Now, for the first step:

The regex to find existing <a> tags. Let's use a regex that captures the entire <a> tag, then insert the new attributes.

But to avoid adding duplicates, perhaps the best approach is to use a regex substitution that adds the attributes, but only if they are not present. But that requires a more complex regex.

Alternatively, perhaps the problem doesn't care about duplicates, so just append the attributes.

So for the first substitution:

pattern = r'(<a [^>]*>)'

replacement = r'\1 target="_blank" rel="nofollow"'

Wait, but this would add those attributes to every <a> tag, but the closing tag is still </a>, so the attributes are added even if they exist. For example:

Original: <a href="x" target="_self">
After substitution: <a href="x" target="_self" target="_blank" rel="nofollow">

This might be okay for the problem's requirements. The tests would need to check if existing attributes are preserved or not.

Alternatively, maybe the problem expects that existing attributes are kept, and new ones are added. But in that case, the regex would have to check for the presence of the attributes. That's more complicated.

Hmm, perhaps the problem expects that existing links get those attributes added, even if they already have some. So proceed with that approach.

Now, the second step: find URLs that are not already in an <a> tag and turn them into links.

To do this, we can use a regex to find URLs that are not within <a> tags. This is tricky because regex can't really parse HTML, but perhaps we can assume that the text is not nested with other tags, and that URLs not in <a> tags are in plain text.

The regex for URLs could be something like:

\b(?:(https?|ftp)://[^\s<"']+) 

But this needs to match URLs not already inside an <a> tag. To do that, perhaps use a negative lookbehind, but that's complicated.

Alternatively, split the text into parts that are inside <a> tags and those that are not, process the non-<a> parts.

Alternatively, the regex can match URLs that are not preceded by a < or are not part of an existing <a> tag.

Alternatively, use a regex that matches URLs and then check if they are within an <a> tag.

This might be difficult. Another approach is to first process the existing links, then process the entire text again to find URLs and wrap them, but then the existing links would have been modified already, so they won't be touched again.

Wait, here's a possible approach:

1. First, process the existing links to add the attributes.

2. Then, process the entire text again to find any URLs (using a regex) that are not already within <a> tags, and wrap them.

But how to ensure that those URLs are not inside existing <a> tags?

Hmm, maybe the second step's regex can look for URLs that are not within <a> tags. But how?

Alternatively, the second step can use a regex to find URLs not preceded by <a href=...

But that's not straightforward. Alternatively, the regex can match any URL that is not inside an HTML tag.

Alternatively, perhaps the second step can use a regex to find URLs that are surrounded by whitespace or start/end of string, but that might not capture all cases.

Alternatively, use a regex that matches URLs that are not part of an HTML tag. For example, URLs that are not inside <a> tags.

This is getting complicated, perhaps the best approach is to first find all URLs in the text, then for each URL, check whether it is already inside an <a> tag, and if not, wrap it.

But doing this programmatically would require parsing the text and checking each occurrence, which is tricky with regex.

An alternative idea: use a regex to find all URLs in the text, then replace them with the linked version, but only if they are not already within an <a> tag.

To do this, the regex can look for URLs that are not preceded by a < (indicating an HTML tag start) and not followed by a >, but that's not sufficient.

Alternatively, use a negative lookbehind to check that the URL is not within an <a> tag.

Alternatively, perhaps the regex can be written as:

\b(?:(https?|ftp)://[^\s<"']+) 

and then wrap them with <a> tags with the attributes, but only if they are not already inside an <a> tag.

But how to ensure that?

Maybe the regex can check that the URL is not part of an existing <a> tag. But that's not possible with regex alone.

Hmm, perhaps the simplest way is to first process existing links, then in the remaining text, find all URLs and wrap them, assuming that the existing links have already been processed and thus their URLs are now in <a> tags, so the second pass will not match them.

Wait, that might not work. Let me think:

Suppose the first step modifies existing links. The second step looks for URLs in the entire text. But those URLs that were already in links are now inside <a> tags, so the regex for URLs would not match them because they are part of the HTML.

Wait, the regex for URLs would match the actual URL text, but if it's inside an <a> tag's href attribute, then it's in quotes, so the regex for URLs (like matching http://...) would not match that.

Ah right! So the second step's regex can look for URLs in the text that are not part of an HTML tag. So, for example, in the text "Visit http://example.com", the URL is not in a tag, so it would be matched. But in "Visit <a href='http://example.com'>link</a>", the URL is inside the href attribute, so the regex looking for URLs outside of tags would not match it.

Therefore, the steps would be:

First step: process existing <a> tags to add the attributes. This is done by replacing all existing <a> tags with the same tag plus the new attributes.

Second step: find all URLs in the text that are not within any tags, i.e., are in plain text, and wrap them into <a> tags with the required attributes.

This way, the existing links are modified, and new URLs not in links are turned into links.

So, the regex for the second step would be to find URLs that are not part of an HTML tag. But how?

Maybe the regex for the URLs can be written as:

r'\b(?!(?:https?|ftp)://)(?<!\S)(?:https?|ftp)://[^\s<"\'\]]+'

Wait, perhaps a better approach is to match URLs that are not inside an HTML tag. To do that, the regex can look for URLs that are not preceded by a '<' (start of a tag) and not followed by '>' (end of a tag), but this is an oversimplification.

Alternatively, use a regex that matches URLs that are surrounded by non-HTML characters. For example, using negative lookbehind and lookahead to check that the URL is not within angle brackets.

But regular expressions can't handle nested structures or arbitrary length lookaheads/lookbehinds in some engines. In Python's re module, lookbehind needs to be fixed-width, so that won't work for checking if the URL is inside angle brackets.

Hmm, this is getting too complex. Maybe the second step can proceed by just searching for any URLs in the entire text and wrapping them, assuming that existing links have already been processed and thus their URLs are inside <a> tags. But that would not work because the existing links' URLs are in the href attributes, so they are not in the text as plain URLs. So the second step's regex would only find URLs that are not in any tags.

Wait, yes. For example, in the text "Visit http://example.com", the URL is in plain text. The first step doesn't affect it, so the second step would find it and wrap it. In the case of existing links like "<a href='http://old.com'>old</a>", the URL is inside the href attribute, so the regex for the second step won't match it because the URL is in quotes and part of an HTML tag.

Therefore, the approach is feasible.

So, putting it all together:

First, modify existing <a> tags by adding target and rel attributes.

Second, find all URLs in the text that are not inside any tags (i.e., plain text URLs) and wrap them in <a> tags with those attributes.

Now, to implement this in Python:

First step: replace existing <a> tags.

The regex pattern for existing <a> tags could be r'<a ([^>]+)>' (capturing the attributes between the <a and >).

The replacement would be r'<a \1 target="_blank" rel="nofollow">'.

Wait, but this would add the new attributes to the existing ones, even if they already exist. For example, if an existing tag has target="_self", the new one will have both. But maybe the problem allows that.

Alternatively, to ensure that existing attributes are not duplicated, perhaps use a more complex regex that checks for the presence of the attributes. But that might be overkill.

Proceeding with the simple approach.

Second step: find URLs not in tags.

The regex for URLs could be something like:

\b(?:(https?|ftp)://[^\s<"'\]]+)

But this might need adjustments. For example, matching URLs that are not part of an HTML tag. Since they are in plain text, the regex can just match them normally.

Wait, but in the text, after the first step, any existing links are already wrapped in <a> tags with the new attributes. So the second step's regex will only find URLs that are not yet in any <a> tag.

Thus, the second step's regex can be a standard URL-matching regex.

So, the regex for the second step could be:

r'(https?://[^\s<]+)'

But need to capture the URL and wrap it in <a> tags with the attributes.

Wait, perhaps:

r'(?<!href=["\'])\b(https?|ftp)://[^\s<"\'\]]+'

This is getting complicated. Maybe better to just use a simple regex and assume that any URL found in the text (not part of an existing <a> tag) is to be wrapped.

The regex for the second step can be:

r'(?<!href=["\'])\b(https?|ftp)://[^\s<"\'\]]+'

But perhaps the simplest way is to use a regex that matches URLs that are not inside quotes or tags. Alternatively, just match any URL that is not part of an existing <a> tag's href attribute.

Alternatively, use a regex that matches URLs that are not inside an HTML tag. Since HTML tags are enclosed in <...>, perhaps the regex can look for URLs that are not preceded by a < and not followed by a >, but that's not accurate.

Alternatively, use a regex that matches URLs that are followed by a space or punctuation, but that's not reliable.

Hmm, perhaps the second step's regex can be as simple as:

r'(https?://[^\s<]+)'

This matches URLs that are not followed by a space or a < (start of a tag), so it would match plain URLs but not those inside tags.

Wait, but if the URL is inside a tag, like the href attribute, then the URL is in quotes, so the regex would not match it because the URL is inside quotes and preceded by 'href="'.

So, this might work.

Thus, the replacement for the second step would be:

r'<a href="\1" target="_blank" rel="nofollow">\1</a>'

Putting this all together:

The code would be:

def process_text_links(text):
    # Step 1: Modify existing <a> tags to add target and rel attributes
    text = re.sub(r'(<a [^>]*>)', r'\1 target="_blank" rel="nofollow"', text)
    # Step 2: Linkify plain text URLs
    text = re.sub(r'(https?://[^\s<]+)', r'<a href="\1" target="_blank" rel="nofollow">\1</a>', text)
    return text

Wait, but in step 1, the regex is replacing any <a ...> with the same plus the new attributes. This will add the attributes even if they already exist, leading to duplicates. But maybe the problem allows that.

Testing the first test case:

Input: <a href='http://example.com'>link</a>

After step 1: <a href='http://example.com' target="_blank" rel="nofollow">link</a> → which is correct.

Another case where existing attributes are present:

Input: <a href='http://old.com' target='_self'>old</a>

After step 1: <a href='http://old.com' target='_self' target="_blank" rel="nofollow">old</a>

Which has duplicate target attributes, but browsers usually ignore the first one. The problem might not care as long as the attributes are added.

Now the second step's regex: For a URL not in a tag, like "Visit http://new.com", it would be turned into a link with the attributes.

Now for the test case 3:

Input: "Existing: <a href='http://old.com'>old</a>. New: https://new.com"

After step1:

Existing: <a href='http://old.com' target="_blank" rel="nofollow">old</a>. New: https://new.com

Then step 2 processes the "https://new.com" part, wrapping it.

So the final output would be correct.

Now, what about URLs with spaces or other characters? The regex may need to be adjusted. For example, URLs ending with punctuation like a period:

"http://example.com."

The regex currently matches up to non-space and non-<, so the period is allowed since it's not a space or <. But the replacement would include the period in the link. Hmm, perhaps the regex should exclude punctuation before the end. Maybe better to adjust the regex to be more precise.

Alternatively, maybe the regex should be:

r'(https?://[^\s<]+)'

Which includes any characters except whitespace or <, so even if it's followed by a period, it's captured. The replacement would include the period in the link's text. That might not be desired, but perhaps the problem allows it.

Alternatively, adjust the regex to exclude certain characters. But perhaps it's beyond the scope here. For simplicity, proceed.

Now, the code uses re.sub with the two steps.

Now, writing the tests first, as per TDD.

First, the tests.

The user said to generate the code based on the function signature and docstring, but to first generate comprehensive unit tests. So, the tests should be written first.

The tests would use the pytest framework, perhaps.

Sample tests:

Test 1: existing link with no attributes → should add target and rel.

test_existing_link:

def test_existing_link():
    input_text = '<a href="http://example.com">Example</a>'
    expected = '<a href="http://example.com" target="_blank" rel="nofollow">Example</a>'
    assert process_text_links(input_text) == expected

Test 2: existing link with some attributes → adds new ones.

def test_existing_link_with_attributes():
    input_text = '<a href="http://example.com" target="_self">Example</a>'
    expected = '<a href="http://example.com" target="_self" target="_blank" rel="nofollow">Example</a>'
    assert process_text_links(input_text) == expected

Test 3: plain URL → becomes a link with attributes.

def test_plain_url():
    input_text = 'Check out http://example.com'
    expected = 'Check out <a href="http://example.com" target="_blank" rel="nofollow">http://example.com</a>'
    assert process_text_links(input_text) == expected

Test 4: mix of existing and new links → both processed.

def test_mixed_links():
    input_text = 'Existing: <a href="http://old.com">old</a>. New: https://new.com'
    expected = 'Existing: <a href="http://old.com" target="_blank" rel="nofollow">old</a>. New: <a href="https://new.com" target="_blank" rel="nofollow">https://new.com</a>'
    assert process_text_links(input_text) == expected

Test 5: URL with query parameters.

def test_url_with_query():
    input_text = 'Visit http://example.com/path?query=1'
    expected = 'Visit <a href="http://example.com/path?query=1" target="_blank" rel="nofollow">http://example.com/path?query=1</a>'
    assert process_text_links(input_text) == expected

Test 6: URL with 'ftp' protocol.

def test_ftp_url():
    input_text = 'Download via ftp://ftp.example.com/file.txt'
    expected = 'Download via <a href="ftp://ftp.example.com/file.txt" target="_blank" rel="nofollow">ftp://ftp.example.com/file.txt</a>'
    assert process_text_links(input_text) == expected

Test 7: URL inside quotes (should not be linked).

def test_url_in_quotes():
    input_text = 'The URL is "http://example.com"'
    expected = 'The URL is "http://example.com"'
    # Wait, no, the quotes are part of the text, so the URL inside quotes would still be matched by the second regex. Hmm.

Wait, in this case, the input is 'The URL is "http://example.com"', the regex for step 2 would match 'http://example.com' because it's not inside an HTML tag. But the quotes are part of the text, so the URL is in plain text. So the code would linkify it.

Wait, but that's correct. The quotes are just part of the text, so the URL inside the quotes is still a plain URL and should be linked. So the expected output would be:

'The URL is "<a href="http://example.com" target="_blank" rel="nofollow">http://example.com</a>"'

Hmm, but the original input has the URL inside quotes. The code would process it, which is correct. So the test case would have to account for that.

Alternatively, perhaps the user expects that URLs inside quotes are not linkified, but that's unclear. The problem says "textual links", which might mean URLs in plain text, not inside quotes. But the problem's description isn't clear.

Alternatively, perhaps the test case should check that URLs inside quotes are not linked. But that would require a more complex regex.

Alternatively, the current code would linkify them, so the test must reflect that.

Alternatively, perhaps the test should be written as:

input_text = 'The URL is "http://example.com"'
expected = 'The URL is "<a href="http://example.com" target="_blank" rel="nofollow">http://example.com</a>"'

So the test would pass.

Another test case: a URL followed by punctuation.

def test_url_with_punctuation():
    input_text = 'Website: https://example.com.'
    expected = 'Website: <a href="https://example.com." target="_blank" rel="nofollow">https://example.com.</a>'
    # The period is included in the URL. Maybe the regex should exclude it, but the current code includes it. So the test expects that.

Hmm, but perhaps the URL is actually 'https://example.com' and the period is outside. The regex would capture up to the period because the regex's [^\s<]+ includes any character except whitespace or <. So the period is allowed, so it's part of the URL. The user might consider that incorrect, but according to the current code, it's correct.

Alternatively, the regex could be adjusted to stop at punctuation, but that's beyond the current problem's scope.

Now, the code:

The function uses re.sub with the two steps.

Potential edge cases:

- URLs with uppercase protocols (HTTP://example.com). The regex uses lowercase, but the re.IGNORECASE flag could be added.

Wait, in the regex, the protocol is (https?|ftp), but the ? makes the 's' optional. Wait, the first group is (https?|ftp), but actually, the regex for the second step's first group is (https?|ftp), but in the regex, it's written as:

r'(https?://[^\s<]+)'

Wait, no, the second step's regex is written as:

r'(https?://[^\s<]+)'

This matches http:// or https:// or any other? Wait, no, the 's' is optional in the first part. Wait, the regex is:

The first part is https? which means 'http' followed by an optional 's', so it matches 'http' or 'https'. But the ?: is part of the group? Wait, no, in the regex for the second step, the code uses:

r'(https?://[^\s<]+)'

Wait, that's the entire regex. So the protocol part is 'https?://' → meaning that it's looking for 'http' followed by an optional 's', then '://'.

Wait, that's incorrect. Because that would match 'http://' or 'https://' but not 'http' without the colon. Wait, no, the regex is 'https?://' → the s is optional between http and the colon. Wait, no:

Breaking down 'https?://' :

- 'http' followed by an optional 's' (due to the ?), then '://' → so it can be 'http://' or 'https://', but not 'http' without the colon.

Wait, but the protocol is 'http' or 'https', so the regex is okay for that.

But for 'http' without the colon, that's not a valid URL. So the regex is okay.

Alternatively, perhaps the regex should be written as (https?|ftp):// to capture the protocol, but in the current code's second step's regex, it's written as 'https?://' which is part of the first group?

Wait, the regex for the second step is written as:

r'(https?://[^\s<]+)'

The parentheses are around the entire URL, not just the protocol. So the first group captures the entire URL.

So the regex will match any URL starting with http://, https://, or ftp:// (wait, no, because the regex is 'https?://' which only covers http and https, but not ftp).

Ah, there's a problem here. The first step's regex for existing links was handling ftp, but in the second step's regex, the protocol part is only http(s).

So the second step's regex doesn't handle ftp URLs. So the test for ftp would fail.

In test_ftp_url:

The input is 'ftp://ftp.example.com/file.txt', which should be matched by the second step's regex. But the current regex starts with 'https?://' which doesn't include ftp.

Ah, so the second step's regex is incorrect. The first step's regex for existing links included ftp, but the second step's doesn't.

So the second step's regex should be updated to include ftp.

So the correct regex for the second step would be:

r'(https?|ftp)://[^\s<]+'

Wait, but to form a proper regex, it would be:

r'((?:https?|ftp)://[^\s<]+)'

Wait, to capture the entire URL.

Wait, the regex should be:

r'((?:https?|ftp)://[^\s<]+)'

So the group is everything from the protocol onwards.

Thus, the second step's regex should be adjusted to include ftp.

So, correcting that:

Second step's regex:

r'(https?|ftp)://[^\s<]+'

Wait, but to make it a capturing group, it should be:

r'((?:https?|ftp)://[^\s<]+)'

So the regex becomes:

r'((?:https?|ftp)://[^\s<]+)'

So the replacement would use \1.

Thus, the second step's regex and replacement are:

text = re.sub(r'((?:https?|ftp)://[^\s<]+)', r'<a href="\1" target="_blank" rel="nofollow">\1</a>', text)

This way, ftp URLs are also captured.

So the code needs to be adjusted for that.

So the corrected code would be:

def process_text_links(text):
    import re
    # Step 1: Modify existing <a> tags
    text = re.sub(r'(<a [^>]*>)', r'\1 target="_blank" rel="nofollow"', text)
    # Step 2: Linkify URLs not in tags
    text = re.sub(r'((?:https?|ftp)://[^\s<]+)', r'<a href="\1" target="_blank" rel="nofollow">\1</a>', text)
    return text

Now, the test for ftp would pass.

Another test case: a URL with a trailing slash and other characters.

Also, need to ensure that the regex doesn't capture URLs inside existing tags.

Another test case: a URL inside an existing <a> tag.

def test_url_inside_a_tag():
    input_text = '<a href="http://existing.com">existing</a>'
    expected = '<a href="http://existing.com" target="_blank" rel="nofollow">existing</a>'
    assert process_text_links(input_text) == expected

Now, putting all together, the code should work.

Now, the final code includes the two regex substitutions, with the corrected regex for the second step.

Now, the user's problem says to output only the code in Python markdown format. So I need to write the code, including the imports, and the function.

Wait, the function uses 're', so need to import that.

Thus, the code would be:

import re

def process_text_links(text):
    """
    Process links in text, adding some attributes and linkifying textual links.
    """
    # Step 1: Add attributes to existing <a> tags
    text = re.sub(r'(<a [^>]*>)', r'\1 target="_blank" rel="nofollow"', text)
    # Step 2: Linkify plain text URLs
    text = re.sub(r'((?:https?|ftp)://[^\s<]+)', r'<a href="\1" target="_blank" rel="nofollow">\1</a>', text)
    return text

Wait, but the first regex may add duplicate attributes. For example, if the existing tag already has target="_blank", it will add another one. But according to the problem's requirements, that's acceptable.

Another thing: the first regex may not handle cases where the <a> tag has other attributes in different orders, but since the regex captures everything between <a and >, it should work.

Testing with the first test case:

Input: <a href='http://example.com'>link</a>

After step 1: the first regex matches <a href='http://example.com'> and appends the new attributes, resulting in <a href='http://example.com' target="_blank" rel="nofollow">.

The closing tag remains, so the link is correct.

Another case with existing attributes:

Input: <a target="_self" href="http://old.com">old</a>

The regex will match the entire <a ...> part, so the replacement becomes <a target="_self" href="http://old.com" target="_blank" rel="nofollow">, which is acceptable.

Thus, the code should work.

Now, I'll write the code as per the user's request, in Python markdown format, with only the code.
