Okay, I need to write the Python function update_last_applied_manifest_dict_from_resp based on the given docstring and tips. Let me start by understanding the problem.

The function's purpose is to update a partial last_applied_manifest using an observer_schema and a response from Kubernetes. The key points from the docstring are:

- It works with dictionaries (since the function handles dicts).
- It should go through all observed fields in the observer_schema. For each field, if the field is present in the response, and if it's not already in the last_applied_manifest, we should set its value from the response.
- If an observed field is not present in the response, it should raise a KeyError.

Hmm, so the observer_schema probably defines which fields are to be observed. The function needs to check each key in the observer_schema. Wait, maybe the observer_schema is a schema that tells which fields to track. So for each key in observer_schema, if that key is in the response, then we need to make sure it's in the last_applied_manifest. If it's not present in the response, then we raise an error?

Wait the doc says: "Raises KeyError: If the observed field is not present in the Kubernetes response". So every observed field must be present in the response. So for each key in the observer_schema, we check if it exists in the response. If not, raise KeyError.

Wait, maybe the observer_schema is a dictionary where the keys are the fields that should be observed. So for each key in observer_schema:

- If the key is in the response, then we check if it's present in the last_applied_manifest. If not, we set it from the response.

Wait, but the function's job is to initialize the last_applied_manifest's values for observed fields if they are not present yet. So perhaps the observed fields are the keys in the observer_schema. So for each such key:

- Check if the key is present in the response. If not, raise KeyError.
- Then, if the key is not in last_applied_manifest, set its value from the response's key.

Wait, but the function's description says "initialized their value in last_applied_manifest if they are not yet present". So for each observed field (from observer_schema's keys?), if the response has that field, then we set it in last_applied_manifest if it's not already there. But also, if the field is not in the response, then we must raise KeyError.

Wait the wording is a bit tricky. Let me re-read the docstring's note:

"This function go through all observed fields, and initialized their value in last_applied_manifest if they are not yet present. Raises KeyError if the observed field is not present in the response."

Ah, so for each observed field (the keys in the observer_schema?), we check if it's present in the response. If it's not present in the response, we raise KeyError. Then, if the field is not present in last_applied_manifest, we set it to the value from the response's field.

Wait, but the order is: first check presence in response. If not present, raise. Then, if not present in last_applied, set it from response.

So the steps are:

For each key in the observer_schema:

1. Check if the key is in the response. If not, raise KeyError.

2. Then, check if the key is in last_applied_manifest. If not, set last_applied_manifest[key] = response[key].

Wait but maybe the observer_schema is a dictionary that also has some structure, perhaps indicating the type of the field (like if it's a list or another dict, hence needing to call the list function recursively). But the current function is for dicts, so perhaps the observer_schema here is a part that corresponds to a dict structure. However, the problem here is to write this function for the dict case, and the other function (the list one) is a separate concern. Since the current function is called when dealing with a dict, we can proceed under the assumption that the keys in the observer_schema are the fields to check.

So the steps for each key in observer_schema:

- If key not in response, raise KeyError.

- If key not in last_applied_manifest, set it to response[key].

Wait, but what if the observer_schema's value is another schema? Like, for nested structures. For example, if the field is a sub-dictionary, then perhaps we need to recurse into that. But the current function's name suggests that it's for when the last_applied_manifest and response are dicts. So maybe the observer_schema here is a dictionary where each key is an observed field, and their values might be schemas for nested structures. But in this function, perhaps we only handle the top-level keys here, and for nested structures, we call this function recursively again? Wait the problem mentions that these functions are called recursively. But in this function's case, since it's for dicts, perhaps when a key in the observer_schema has a value that is a schema (like another dict), we need to process that. But the problem says that the function is part of a recursive process with the list function. So maybe for each key in the observer_schema, if the corresponding value in the observer_schema is a dict (indicating a nested structure), then we need to recurse into that. But the current function's parameters are all for the current level's dicts. Hmm, perhaps this is getting too complex, but given the current problem, perhaps I can proceed with the basic case first.

Let me outline the code structure:

def update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):
    for key in observer_schema:
        if key not in response:
            raise KeyError(f"Observed field '{key}' not found in response")
        if key not in last_applied_manifest:
            last_applied_manifest[key] = response[key]

Wait but that's a very simple approach. However, perhaps the observer_schema might have nested structures. For example, if the schema includes a key whose value is another schema (like a dict), then we might need to recurse into that. The problem mentions that the functions are called recursively. So perhaps in the case where the value in the observer_schema for a key is a dict, then we need to check if the key exists in the response, then check if it's a dict in both the last_applied and response, and then call this function again on the nested dicts. But in the current problem, the function's parameters are for when the current part is a dict, so perhaps that's part of the process.

Wait the function's name is for when the last_applied and response are dicts. So perhaps for each key in the observer schema, if the key's value in the observer schema is a dict (indicating a nested structure), then we need to process that. For example:

Suppose the observer_schema has a key 'spec' whose value is another schema (a dict). Then, the 'spec' key's value in the response and last_applied would be a dict. So in this case, we need to first ensure that 'spec' exists in the response. Then, if 'spec' is not in last_applied, we set it from the response. But if 'spec' is already present, then we need to recurse into the 'spec' part using the nested schema. Wait, but the function's parameters are for the current level's dicts. So maybe the code should handle that.

Hmm, the problem's docstring says that this function is called recursively with the list function. So perhaps the recursion is when a key in the observer schema has a list as a value, and then we call the list function. Alternatively, perhaps the observer schema's value indicates the type, so for example, if a key in the observer schema has a value that is a list, then perhaps that key's value in the response is a list and we need to call the list function.

Wait, but the current function is for dicts. So perhaps the observer schema's structure determines whether we need to recurse into another function. For example, for each key in the observer schema:

- Check if the key is in the response. If not, raise KeyError.

- Then, if the key's value in the observer schema is a dict (indicating a nested structure), then we need to check if the key's value in the response is a dict, and then call this function again on the nested parts.

Wait, but the code in the function would have to handle that. Let's think of an example:

Suppose observer_schema has a key 'metadata' with a value that is another schema (a dict). So the 'metadata' field in the response is a dict. The last_applied's 'metadata' may or may not exist. So in this case:

- Check that 'metadata' exists in response. If not, raise KeyError.

- If 'metadata' is not in last_applied, set it to the response's metadata dict.

- If it is present, then we need to recurse into the 'metadata' part, using the nested schema. So call update_last_applied_manifest_dict_from_resp again with last_applied['metadata'], the nested schema, and response['metadata'].

Therefore, in the code, for each key in observer_schema:

if the key's value in the observer schema is a dict (i.e., it's a nested schema), then after ensuring the key exists in response and setting it in last_applied if needed, we need to check if the current value in last_applied is a dict (since it could be a list, but that's handled by the list function?), and then recurse.

Wait, but how do we know whether to recurse into a dict or a list? The observer schema's structure probably indicates that. For example, if the value in the observer schema is a dict, then the corresponding data is a dict and we need to recurse into this function again. If it's a list, then we need to call the other function.

So, in code:

for key in observer_schema:
    if key not in response:
        raise KeyError(...)
    if key not in last_applied:
        last_applied[key] = response[key]
    else:
        # Now, check if the value in observer_schema[key] is a dict (schema)
        # and the current value is a dict, then recurse.
        # Or perhaps, check the type of the value in the observer schema.
        # Let's assume that if the observer_schema's value is a dict, then it's a nested dict.
        # So:
        if isinstance(observer_schema[key], dict):
            # Then, check if the value in last_applied and response are dicts.
            # If so, recurse.
            # But need to make sure that last_applied's value is a dict.
            # Wait, perhaps the response's value is a dict here, so:
            # So call this function recursively with the nested parts.
            update_last_applied_manifest_dict_from_resp(
                last_applied[key],
                observer_schema[key],
                response[key]
            )
        elif isinstance(observer_schema[key], list):
            # Then, call the list function here.
            # But the list function is the other function mentioned.
            # So, in that case, we would call update_last_applied_manifest_list_from_resp(...)
            # But since this is part of the current function's code, but the problem's function is only the dict one, perhaps the code here would need to handle that.
            # However, the problem's function is supposed to be written here, so perhaps the list part is handled in the other function, which we are not writing here.
            # So, in this code, perhaps we can ignore that for now, as the current function is for dicts and the list function is separate.
            # So, for the current function, we only handle the case where the observer schema's value is a dict, hence the need to recurse here.
            pass  # but this would need to be handled.

Hmm, this complicates the code. The problem's function's docstring mentions that it's called recursively with the list function. So in this function, for each key in the observer schema, after ensuring it's present in response and setting in last_applied if needed, we need to check if the key's value in the observer schema is a dict (so that we can recurse into this function again on the nested dicts), or a list (so call the list function).

Therefore, the code must include that logic.

So putting it all together:

def update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):
    for key in observer_schema:
        if key not in response:
            raise KeyError(f"Observed field '{key}' not present in the Kubernetes response")
        # Check if the key is present in last_applied_manifest. If not, set it from response
        if key not in last_applied_manifest:
            last_applied_manifest[key] = response[key]
        else:
            # Now, check if the observer_schema's value is a dict (indicating a nested structure)
            # and if so, recurse into this function for that key's value.
            if isinstance(observer_schema[key], dict):
                # Ensure that the current value in last_applied is a dict (since we set it earlier)
                # and the response's value is also a dict.
                # Then, call this function recursively on the nested parts.
                update_last_applied_manifest_dict_from_resp(
                    last_applied_manifest[key],
                    observer_schema[key],
                    response[key]
                )
            # else if it's a list, call the other function. But since we are in the dict function, perhaps that's handled elsewhere.

Wait but what if the observer_schema's value is a list? Then we would need to call the list function. But since this function is for dicts, perhaps the list case is handled by the other function. So in this code, we can only handle the dict case. So in the code above, the check for whether the observer_schema's key is a dict, then recurse. Otherwise, maybe ignore? Or perhaps the observer schema's value is a list, indicating that the corresponding value is a list, and so we need to call the list function here.

Wait, but the problem's function is part of a pair, so for each key in the observer schema, we have to decide which function to call based on the type of the observer schema's value. For example, if the observer schema's value is a dict, then we need to process the nested dict, so call this function again. If it's a list, then call the list function.

Therefore, in the code, for each key in observer_schema:

after ensuring key exists in response and setting in last_applied if needed:

if the observer_schema's value is a dict, then recurse into this function on the nested dicts.

if it's a list, then call the other function (update_last_applied_manifest_list_from_resp) on the nested lists.

But since we don't have access to the list function's code here, but the problem says that this function is part of a pair called recursively, so we must include that logic here.

But the problem is only asking for the code for this dict function, so perhaps the list case is handled in the other function, and here in the dict function, we only handle the dict case.

Therefore, the code should include the recursive call when the observer schema's value is a dict.

So putting this together:

The code would loop through each key in observer_schema:

Check if the key is in response. If not, raise KeyError.

Check if the key is in last_applied. If not, set it from response.

Then, if the observer_schema's key's value is a dict, then recurse on the nested structure.

Wait, but what if the value in last_applied is not a dict? Like, if the response's key is a dict, but the last_applied's key was a list (but that shouldn't happen, since we set it from response if it wasn't present). Wait, when we set last_applied[key] = response[key], then the type would be the same as response's value. So if the observer_schema expects a dict, then response's value should be a dict. So the recursion is safe.

Therefore, the code would look like this:

Now, also, what about the case where the observer_schema's value is not a dict or list? Like a primitive type? Then, we don't need to recurse, since that key is a primitive and there's nothing more to do.

Therefore, the code would need to check for that.

So, putting all that into code:

def update_last_applied_manifest_dict_from_resp(last_applied_manifest, observer_schema, response):
    for key in observer_schema:
        if key not in response:
            raise KeyError(f"Observed field '{key}' not present in the Kubernetes response")
        if key not in last_applied_manifest:
            last_applied_manifest[key] = response[key]
        else:
            # Check if the value in observer_schema is a dict, indicating nested structure
            if isinstance(observer_schema[key], dict):
                # Recurse into the nested dict
                update_last_applied_manifest_dict_from_resp(
                    last_applied_manifest[key],
                    observer_schema[key],
                    response[key]
                )
            # else, if it's a list, call the list function. But since we can't do that here, perhaps the list function is called in its own context.
            # For the scope of this function, we only handle the dict case.

Wait, but the problem's function's docstring says that together with the list function, they are called recursively. So in the code, whenever we encounter a list in the observer schema's value, we need to call the list function. However, since we don't have access to that function here, but in the code for this function, we can only handle the dict case, so the list case would be handled elsewhere.

Therefore, in the code above, the recursive call is made only when the observer schema's value is a dict.

That should handle the nested dictionaries.

Now, let's think about the unit tests first, as per the test-driven development approach mentioned in the tips.

The user wants the code to be generated following TDD, so first write the tests, then the code. But the problem says to output only the code. So perhaps I can think through the test cases to ensure the code is correct.

Test Case 1: Basic case where all keys are present, and some keys are missing in last_applied.

Suppose:

last_applied = {}
observer_schema = {'a': {}, 'b': {}}
response = {'a': 1, 'b': 2}

After the function, last_applied should have a and b set to 1 and 2.

Test Case 2: A key is missing in the response. Should raise KeyError.

last_applied = {}
observer_schema = {'a': {}}
response = {}  # no 'a'

Should raise KeyError for 'a'.

Test Case 3: Nested structure.

last_applied = {'metadata': {}}
observer_schema = {'metadata': {'name': {}}}
response = {'metadata': {'name': 'test'}}

After processing, the last_applied's 'metadata' should have 'name' set to 'test'.

Because:

- 'metadata' is in observer_schema. Check response has it. It does.

- 'metadata' is in last_applied (as a dict). So then, check the observer_schema's 'metadata' value is a dict. So recurse into:

update_last_applied_manifest_dict_from_resp(last_applied['metadata'], observer_schema['metadata'], response['metadata'])

In that recursive call:

- key 'name' in observer_schema's nested schema.

- response's 'metadata' has 'name', so proceed.

- last_applied's 'metadata' is empty initially (since last_applied was {'metadata': {}} before the function call). Wait, no: the initial last_applied's 'metadata' is empty. So in the recursive call:

The last_applied's 'metadata' is the inner dict. The observer_schema's nested schema is {'name': {}}.

The response's 'metadata' has 'name' as 'test'.

So in the recursive call:

For key 'name':

- check if in response's 'metadata'? Yes.

- check if in last_applied's inner dict (which is empty). So set it to 'test'.

Thus after the recursion, the last_applied's 'metadata' will have 'name' set.

Another test case where a nested field is missing in response.

observer_schema has 'metadata' with a nested field 'name', but the response's 'metadata' lacks 'name'. Then, the function should raise KeyError for 'name' in the nested call.

But the error message would need to include the full path, but according to the docstring, the error message just says the field name. Hmm, but perhaps the KeyError's message is just the key, not the path. So in the nested case, the KeyError would be raised with the key 'name'.

Thus, the code should handle that.

Now, back to writing the code.

Wait, in the code, the for loop iterates over all keys in observer_schema. So in the nested case, the observer_schema's keys include the top-level keys and the nested keys via recursion.

So the code should work as intended.

Now, possible edge cases:

- What if the observer_schema has a key that is present in response but not in last_applied, but it's a list? Well, the code would set it in last_applied, but then since the observer_schema's value is a list, the code would not recurse (since it's checking for isinstance(observer_schema[key], dict)), so it would leave it as a list. The list would need to be handled by the list function, but since this is the dict function, that's okay.

Another case: observer_schema has a key that's a dict, but the response's value for that key is not a dict. That would be a problem, but perhaps the code doesn't check that. Since the function's job is to initialize the last_applied's keys from the response, but the type is not checked here. The user may have to ensure that the response's structure matches the observer_schema's types. But that's beyond the scope of this function's responsibility as per the docstring.

Thus, the code seems correct.

Now, writing the code:

def update_last_applied_manifest_dict_from_resp(
    last_applied_manifest, observer_schema, response
):
    """
    Together with :func:``update_last_applied_manifest_list_from_resp``, this
    function is called recursively to update a partial ``last_applied_manifest``
    from a partial Kubernetes response

    Args:
        last_applied_manifest (dict): partial ``last_applied_manifest`` being
            updated
        observer_schema (dict): partial ``observer_schema``
        response (dict): partial response from the Kubernetes API.

    Raises:
        KeyError: If the observed field is not present in the Kubernetes response

    This function goes through all observed fields, and initializes their value in
    last_applied_manifest if they are not yet present
    """
    for key in observer_schema:
        if key not in response:
            raise KeyError(f"Observed field '{key}' not present in the Kubernetes response")
        if key not in last_applied_manifest:
            last_applied_manifest[key] = response[key]
        else:
            # Check if the value in observer_schema is a dict, indicating a nested structure
            if isinstance(observer_schema[key], dict):
                # Recurse into the nested dict
                update_last_applied_manifest_dict_from_resp(
                    last_applied_manifest[key],
                    observer_schema[key],
                    response[key]
                )

Wait, but in the else clause, even if the key is present in last_applied, we need to check if the observer_schema's value is a dict, and then recurse.

This should handle the nested cases.

Testing this code with the examples above:

Test case 3:

last_applied = {'metadata': {}}
observer_schema = {'metadata': {'name': {}}}
response = {'metadata': {'name': 'test'}}

After the first loop iteration (key 'metadata'):

- 'metadata' is in response, yes.

- 'metadata' is in last_applied (as a key with an empty dict). So enter else.

- observer_schema['metadata'] is a dict, so recurse.

In the recursive call:

last_applied's 'metadata' is the empty dict. The observer_schema is {'name': {}} and response's 'metadata' is the dict with 'name'.

In the recursive loop over keys in {'name': {}}:

key is 'name'.

Check if 'name' is in response's 'metadata'? Yes (response['metadata'] has 'name').

Check if 'name' is in last_applied's 'metadata' (which was empty before). So set it to 'test'.

No further recursion because the observer_schema's 'name' is a dict (but empty?), so the next check is if observer_schema['name'] is a dict (it is, but since it's empty, no further keys to process. So the recursive call ends.

Thus, the code works.

Another test case where a nested key is missing in response:

last_applied = {'metadata': {}}
observer_schema = {'metadata': {'name': {}}}
response = {'metadata': {}}  # missing 'name'

Then, in the recursive call for 'metadata':

Processing 'name' key in the nested observer schema.

response's 'metadata' has 'name'? No, because response['metadata'] is empty. So raises KeyError('name').

Which is correct.

Another test case where the key is present but the value is not a dict when expected:

Suppose observer_schema has 'metadata' as a dict, but response's 'metadata' is a string. Then, when recursing, the code will proceed to check the keys in observer_schema['metadata'] (which is a dict), but response['metadata'] is a string, so when trying to access response[key] (like 'name'), it would throw an error. But that's an invalid response structure, which is not the function's responsibility to handle.

Thus, the code seems correct.
