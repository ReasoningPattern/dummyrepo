Okay, I need to write a Python function called remove_ending_os_sep that takes a list of strings and returns a new list where each string has its trailing OS separator removed if applicable. Let me think through this step by step.

First, the function's docstring says that if the input is None, we should return an empty list. So I need to check if input_list is None. If it is, return [].

Next, for each string in the input list, I have to check two conditions: whether the string's length is greater than one, and if the last character is the OS's path separator. Wait, the doc says "trailing os seperator characters" but the example probably means the last character. Oh right, the pathname separator. In Python, the os.path.sep is the correct way to get that, but since the function might not be using the os module, maybe I should just use '/' or '\' depending on the OS? Wait no, the function should use the os module's sep. But since the problem might not require importing anything, perhaps the user expects just to check for '/' or '\' as the trailing characters. Hmm, the problem says "pathname separator", so I think it's better to use os.path.sep. But in the code, I need to import os? Wait, the function's code must include that? Because otherwise, how can it know the separator. So the code will have to import os.

Wait, the user's function's docstring mentions "pathname seperator", so I should use os.path.sep. So the code will need to import os. Let me note that.

So for each string in the input list:

- If the string is empty (length 0) or length 1, then check if the single character is a separator? Wait the condition is "if its length is greater than one and if the last character is the pathname separator". Wait the wording says "length is greater than one" — so if the string is exactly one character, which is a separator, do we remove it? The condition says that only when the string is longer than one character, check the last character. So for a single-character string that is a separator, we leave it as is. Because the condition requires both length >1 and last character is sep. So for example, if the string is '/', since length 1, we leave it as is.

So the steps for each string:

Check if the string ends with os.path.sep. But also, the string must have length >1. Wait, no, the condition says "if its length is greater than one and if the last character is the pathname separator". So the two conditions are:

if len(s) > 1 and s[-1] == os.sep:

Wait, but maybe even if the string is longer than one, but the last character is a separator, then we need to remove it. But also, maybe even if the string is exactly one character (like s is '/'), then we don't remove it. So the logic is: only if the string is longer than one, and ends with the separator, then we strip the last character. Otherwise, leave as is.

Wait, the wording is "Each string is tested if its length is greater than one and if the last character is the pathname separator." So the check is: both conditions must be true. So if the length is >1 and the last character is a separator, then we remove the last character. Otherwise, leave it as is.

So for each string in the input list, process it as follows:

if len(s) > 1 and s.endswith(os.sep):

then new_s = s[:-1]

else:

new_s = s

Wait, but using endswith might be better than checking the last character directly. Because for multi-character separators? Wait, the os.path.sep is either '/' or '\', which are single characters. So endswith is okay.

Wait, but in some cases, like on Windows, the path separator is '\', but when you have a string like 'C:\\', then the last character is '\', so we need to remove it. So yes, the logic holds.

So putting this together:

Now, the steps for the function:

Check if input_list is None: return empty list.

Else, iterate over each string in input_list, process each as per above, collect into a new list.

Now, the code structure would be:

import os

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    result = []
    sep = os.path.sep
    for s in input_list:
        if len(s) > 1 and s.endswith(sep):
            s = s[:-1]
        result.append(s)
    return result

Wait, but what about strings that are exactly two characters long, like 'a/' on a Unix system? Then, yes, we remove the slash, resulting in 'a'.

Another test case: if the string is just '/' (length 1), then we leave it as is. Similarly for a backslash.

Now, for unit tests, since the user mentioned test-driven development, I need to first write the tests before the code. Let me think of possible test cases.

Test case 1: input is None → returns empty list.

Test case 2: empty list → returns empty list.

Test case 3: list with a string ending with sep and length >1 → stripped.

Test case 4: string with exactly the separator (length 1) → remains.

Test case 5: string with no ending sep → remains as is.

Test case 6: mix of these cases.

Now, writing the tests using pytest:

First, the tests would look like this:

import pytest
from your_module import remove_ending_os_sep  # assuming the function is in this module

def test_remove_ending_os_sep_none():
    assert remove_ending_os_sep(None) == []

def test_remove_ending_os_sep_empty_list():
    assert remove_ending_os_sep([]) == []

def test_remove_ending_os_sep_single_element_with_trailing_sep():
    # assuming os.sep is '/', but maybe need to use actual sep in tests.
    sep = os.path.sep
    input_list = [f"path{sep}"]
    expected = ["path"]
    assert remove_ending_os_sep(input_list) == expected

def test_trailing_sep_single_char():
    # like '/', which is length 1
    sep = os.path.sep
    input_list = [sep]
    expected = [sep]
    assert remove_ending_os_sep(input_list) == expected

def test_no_trailing_sep():
    input_list = ["hello", "world"]
    assert remove_ending_os_sep(input_list) == input_list  # no change

def test_mixed_cases():
    sep = os.path.sep
    input_list = [
        f"path{sep}",  # should be stripped
        sep,           # remains
        "root",        # stays
        f"dir{sep}file",  # no trailing sep (ends with 'e'), so stays
        f"dir2{sep}{sep}"  # ends with two sep, but since len is >1, only last is stripped, so becomes "dir2/" (on Unix)
    ]
    expected = [
        "path",
        sep,
        "root",
        "dir/file",
        f"dir2{sep}"
    ]
    # Wait, in the last example, the input is "dir2//", stripping the last / gives "dir2/".
    # So the expected for the last element is "dir2/" ?

    # So the expected list would be:

    # For the fifth element: "dir2/". So the expected for the fifth element is "dir2" + sep?

    # Let me see:

    input_list[4] is "dir2//", which is length 5 (assuming sep is '/'). So len is 5>1. The last character is '/', so we remove it, resulting in "dir2/" (since the original was "dir2//", stripping one gives "dir2/").

    So the expected fifth element is "dir2/".

    So in the test case, the expected fifth element is f"dir2{sep}" ?

    Yes, because the input was f"dir2{sep}{sep}" → stripping the last sep gives "dir2/".

    So the expected fifth element is "dir2/" (on Unix), which is exactly "dir2" + sep.

    So the expected list would be as written.

    So that test case should pass.

Now, the code needs to handle all these cases.

Wait, but in the code, when the string ends with the separator and the length is >1, we remove the last character, which is the separator. So even if there are multiple separators at the end, like "path//", we only remove the last one, so becomes "path/".

Hmm, but the problem says to remove trailing os sep characters. Wait, does that mean all trailing separators? Or just the last one?

The doc says "remove trailing os seperator characters". The wording "characters" plural, so maybe all trailing? But the code's current approach only removes one. That's a problem.

Wait, the original problem says:

"Each string is tested if its length is greater than one and if the last character is the pathname separator."

Ah, so the check is only for the last character. So even if there are multiple trailing separators, like "a//", then the last character is '/', so we remove it, resulting in "a/". But the trailing separators are not all removed, only the last one. So the code as written is correct according to the problem's wording.

Hmm, but the problem's wording might be ambiguous here. But the doc says to check if the last character is a separator. So the code is correct.

Thus, the code is okay.

Another test case: a string with multiple trailing separators. Like "a//", after processing becomes "a/".

Another test case: "a///" → becomes "a//", because the last character was '/', so we remove it. But the new last character is '/', but since the new length is 3 (original length was 3, so after removal it's 2). So the next check would not be done in that pass. Wait, no, because each string is processed once. So the code only removes the last character if it's a separator and the length was >1. So "a///" → length is 3 (so >1), last char is / → remove it → becomes "a//", which is length 2. The next time (if in another iteration?), but in this function, each string is processed once. So the function only removes the last occurrence. So the code is correct as per the problem's instructions.

Okay, so the code seems correct.

Now, the code needs to import os, right? Because we're using os.path.sep. So the code should start with import os.

Wait, in the function, I have to make sure that the code is properly written. Let me write the code again.

The function:

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    sep = os.path.sep
    result = []
    for s in input_list:
        if len(s) > 1 and s.endswith(sep):
            s = s[:-1]
        result.append(s)
    return result

Wait, but I need to import os. So the code should have:

import os

before the function.

So the complete code would be:

import os

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    sep = os.path.sep
    result = []
    for s in input_list:
        if len(s) > 1 and s.endswith(sep):
            s = s[:-1]
        result.append(s)
    return result

That's the code. Let me check edge cases again.

Test case where the string is exactly two characters and ends with sep, like "a/" (Unix). Then, len is 2>1, so it becomes "a".

Another case: "a" → no change. Because the length is 1. Wait, no, "a" is length 1, so even if it ends with a separator (but it doesn't), it won't be stripped.

Another case: "a/" → stripped to "a".

Another case: "a/b/" → stripped to "a/b".

Another case: the input is empty string: "" → length 0, so no change. So the function leaves it as "".

Wait the doc says "Each string is tested if its length is greater than one..." so strings of length 0 or 1 are not stripped. So empty string remains empty.

Okay, so the code is correct.

Now, the user wants the code in a Python markdown format, but only the code. So I should present the code with the import and function.
