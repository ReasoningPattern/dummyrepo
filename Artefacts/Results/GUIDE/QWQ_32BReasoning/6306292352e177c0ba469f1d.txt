Okay, I need to write the Python function find_tags based on the given signature and docstring. Let me start by understanding what the function is supposed to do. 

The function takes a string 'text' and an optional 'replacer' function. It should find all the tags in the text, ignoring those inside code blocks. Then, if a replacer is provided, it should replace the tags in the text using that function. The output is a set of tags and the modified (or original) text.

First, I need to figure out how to identify tags and exclude those within code blocks. Tags are probably words starting with a '#' maybe? Or perhaps some specific pattern. The problem doesn't specify, so I might have to assume a common tag format, like words starting with a '#' like in social media. Alternatively, maybe any word between certain characters. Hmm, the problem isn't explicit here. Wait, the docstring says "tags" but doesn't define the format. Maybe the user expects tags to be words starting with a '#'?

Alternatively, maybe the tags are words enclosed in certain symbols, but since the problem doesn't specify, perhaps the standard is to consider tags as sequences of characters starting with a '#' and followed by alphanumeric or underscores, similar to Twitter hashtags. Let me assume that tags are words starting with '#' followed by word characters. 

Next, the code blocks. How to detect code blocks in the text? Maybe code blocks are defined as sections enclosed in triple backticks like in markdown? Or perhaps any text between ``` and ```? Wait, the problem says "ignore tags inside code blocks" so the code needs to parse the text to find code blocks and exclude tags within them.

So the steps would be:

1. Parse the text to find all the code blocks. Split the text into regions outside code blocks and inside code blocks. For each region outside code blocks, extract the tags. For regions inside code blocks, ignore any tags there.

2. To do that, we can split the text into segments separated by the code block delimiters. The code blocks start with ``` and end with ```, but need to account for possible nested code blocks? Probably not, since in markdown, code blocks are usually denoted by triple backticks and not nested. So perhaps split the text into parts, tracking whether we're inside a code block.

The approach could be:

- Iterate through the text, tracking when a code block starts and ends. When not in a code block, look for tags. When in a code block, skip.

Alternatively, split the text into parts between code block delimiters. The code blocks themselves can be stored, and the non-code parts are processed for tags.

So first, split the text into tokens where code blocks are identified. Let's think of splitting on the triple backtick sequences. But need to be careful with overlapping matches. Let's use a regular expression to find all the code blocks and the non-code parts.

Hmm, perhaps using a regex to split the text into segments that are either code blocks or non-code parts. The regex could be something like:

pattern = r'(```.*?```)'s, using a non-greedy match. But this might have issues with the exact syntax. Alternatively, use a regular expression to find all occurrences of code blocks, and split the text into parts before and after each code block.

Alternatively, using the re.split function with a pattern that captures the code blocks, so that the split includes both the separators (code blocks) and the other parts. Wait, re.split can return the split parts and the matched patterns. For example:

parts = re.split(r'(.*?)```(.*?)```(.*?)', text), but this might get complicated. Alternatively, perhaps a better approach is to iterate through the text, tracking the state (in or out of code block).

Let me outline the steps again:

- The function needs to parse the text, skipping any regions within code blocks (defined by ``` ... ```), and collect all tags from the non-code regions.

So first, process the text to extract all the tags outside of code blocks.

Once the tags are collected, then, if a replacer is provided, replace each tag in the original text (except those inside code blocks) with the result of replacer(tag). But how to do that without affecting the code block parts?

Alternatively, the replacement should only be done in the non-code parts. So perhaps:

- Split the text into code and non-code parts.

- For each non-code part, process to find the tags, collect them into the set, and also perform the replacement (if replacer is present) on those parts.

- Then, recombine all the parts (code and modified non-code parts) back into the final text.

This seems a better approach.

So the plan is:

1. Split the text into a list of parts, where each part is either a code block (starting and ending with ```) or a non-code segment.

2. For each non-code segment, find all the tags (using regex?), collect them into the set.

3. If a replacer is provided, process each non-code segment to replace the tags with replacer(tag), leaving the code blocks untouched.

4. Combine all parts (code and modified non-code) back into the final text.

Now, implementing step 1: splitting into code and non-code parts.

The code blocks are sequences starting with ``` and ending with ```, but they can span multiple lines. The code block content can include any characters except the closing ```.

So to split the text into these parts, perhaps using a regex to find all occurrences of code blocks and the non-code parts between them.

The regex could be something like:

pattern = r'(```.*?```)|(.*)'

But perhaps better to use a non-greedy match between the code delimiters.

Alternatively, using a regex with a pattern that captures both code blocks and non-code parts:

parts = re.split(r'(.*?)```(.*?)```', text), but this might not be straightforward.

Alternatively, here's an approach using a loop:

Initialize variables:

current_position = 0

parts = []

in_code = False

Then, iterate over the text, looking for the start and end of code blocks.

Alternatively, using the re.finditer method to find all code block sections.

Let me think: the code blocks start with ``` and end with ```. The code block can be of any length, and the closing must be on its own line perhaps? Or maybe not. The problem says "inside code blocks" but the exact delimiters are unclear. Assuming that code blocks are enclosed in triple backticks, and that the closing must be three backticks not part of a longer sequence.

So, to find the code blocks, we can use a regex like:

r'```.*?```' with the re.DOTALL flag, so that the dot matches newlines.

But this might not be precise because the closing ``` must not be preceded by a backtick? Hmm, perhaps better to use a regex that matches the code block as starting with ``` followed by any characters (including newlines) until the next ``` sequence.

So, the code block regex is r'```([^`]*)```'? No, that won't work because the code can contain backticks as long as they are not part of a triple. Alternatively, the regex can be r'```(.*?)(?=```)' but that might not be right.

Alternatively, the correct regex would be to match the code block as ``` followed by non-code content until the next ``` which is not part of a longer sequence. Maybe:

The code blocks are sequences starting with ``` and ending with ```, with any characters in between except the closing ``` should not be preceded by a backtick? Hmm, perhaps better to use a non-greedy match between triple backticks.

So, the regex to find code blocks would be r'```(.*?)```', with re.DOTALL.

However, this would match from the first ``` to the next ```, even if there's another ``` in between. But in markdown, code blocks are typically closed by the next occurrence of ```, so this should be okay.

So, using this regex, we can find all code blocks and their positions.

Alternatively, split the text into code and non-code parts as follows:

First, find all the positions of the code blocks. Then, split the text into segments between the code blocks, and the code blocks themselves.

Let me try to outline code for this:

import re

def find_tags(text, replacer=None):

    code_pattern = re.compile(r'```.*?```', re.DOTALL)

    # Split into code and non-code parts

    parts = code_pattern.split(text)

    # The split will alternate between non-code parts and code parts.

    # Because split with a pattern that matches the code blocks, so the non-code parts are the even indices?

    # Let me see: split on code_pattern would give a list where even indices are non-code, odd indices are code parts?

    # Wait, the split function returns the parts of the string not matched by the regex, and the matched parts.

    # The result is like: [non-code before first code, code_block, non-code between codes, code_block, ... etc]

    # So the code parts are the ones at odd indices (starting from 1).

    # So to process each part:

    all_tags = set()

    new_parts = []

    for i, part in enumerate(parts):

        if i % 2 == 0:  # non-code part

            # process this part for tags

            # find all tags in this part, add to all_tags

            # also, if replacer is given, replace the tags in this part

            # how to find tags?

            # assuming tags are words starting with # followed by word characters

            # regex for tags: r'\B#\w+' ?

            # but need to ensure that it's a word starting with #. Maybe \b#\w+

            tag_pattern = re.compile(r'\B#\w+|\b#\w+', re.IGNORECASE)

            # Wait, perhaps the regex is r'\b#[A-Za-z0-9_]+\b' ?

            # Hmm, perhaps the exact regex needs to be defined.

            # Let's assume that a tag is any sequence starting with # followed by letters, numbers, or underscores, and possibly other characters, but for simplicity, let's use \#\w+

            # So the regex is r'#\w+'

            # but need to match the whole tag as a word.

            # Let me define the tag pattern as r'\#\w+' but with word boundaries?

            # Maybe r'\b#\w+\b' but that would require a word boundary before the #, which may not be present if the # is at the start.

            # Alternatively, perhaps any occurrence of # followed by word characters, and the entire match is the tag.

            # So the regex is r'#\w+', but then we can capture all such instances.

            # Let's proceed with that for now.

            # find all tags in this part.

            matches = tag_pattern.findall(part)

            tags_in_part = set(matches)

            all_tags.update(tags_in_part)

            # Now, if replacer is provided, replace each tag in the part with replacer(tag)

            if replacer:

                # Replace each occurrence of a tag in the part

                def replace_func(match):

                    tag = match.group()

                    return replacer(tag)

                replaced_part = tag_pattern.sub(replace_func, part)

                new_parts.append(replaced_part)

            else:

                new_parts.append(part)

        else:  # code part, so just add to new_parts without processing

            new_parts.append(part)

    # Now, recombine all the parts (code and non-code parts, either original or replaced)

    # The split was such that code parts and non-code parts alternate, so combining them in order:

    # The parts list after processing is [non-code1, code1, non-code2, code2, ...], but after processing each part is in new_parts in order.

    # So just concatenate all new_parts?

    # Wait, no. The original split by code_pattern returns parts in the order: non-code before first code, then code, then non-code between codes, etc.

    # So when we loop through parts, the new_parts list will have the same order, but each part has been processed (non-code parts possibly replaced, code parts kept as is).

    # Therefore, the new_parts list is already in the correct order to be joined.

    new_text = ''.join(new_parts)

    return (all_tags, new_text)

Wait, but the code_pattern split may have the code parts as the odd indices. Let me test with an example.

Suppose the text is "some text #tag1 ```code #tag2``` more #tag3".

Split using the regex ```.*?``` would split into parts:

["some text #tag1 ", "```code #tag2```", " more #tag3"].

So parts[0] is non-code, parts[1] is code, parts[2] is non-code again.

So in the loop, for i=0 (non-code), process tags, then i=1 (code) just add as is, then i=2 (non-code again), process tags.

So the code above would work.

Now, the tag pattern. Let's assume that tags are sequences starting with # followed by word characters (letters, numbers, underscores). The regex would be r'#\w+', but this would also match things like #123, which might be acceptable.

But the \w includes underscores, but maybe that's okay.

Wait, the problem says "tags", but without specifics, so maybe the regex is okay.

Now, the problem says "ignore tags inside code blocks". So in code parts (the ones between ```), any tags there are not added to the all_tags set, which is correct.

Now, when replacing, only the non-code parts are processed for replacement.

Now, the function returns a set of all the tags found (excluding those in code blocks), and the new text with replacements done only in non-code regions.

Now, the code needs to handle the replacer function. The replacer is called with the tag as an argument, and the replacement is the return value.

The code uses re.sub with a function, which should work.

Now, I need to think about possible edge cases:

- What if there are no code blocks? Then all parts are non-code, and all tags are collected and replaced.

- What if a code block is empty? Like "``` ```". The code would split into parts before, the empty code block, then the part after.

- What if the text starts or ends with a code block?

- What about multiple consecutive code blocks? The split should handle them.

Another possible issue: the code_pattern uses ```.*?``` which might include the closing ``` but not account for cases where there's a single ` or other characters. But the problem states to ignore tags inside code blocks, so as long as code blocks are correctly identified, it's okay.

Now, the code might have a problem with overlapping code blocks. For example, "```code```more code```" would be split into parts:

The first code block is "```code```", then the next part is "more code", but then there's another ``` which is part of the next code block. Hmm, perhaps the regex would match "```code```" as the first code block, then the next part is "more code", then the next code block is "```", but that's only three backticks, but the closing needs to be three as well.

Wait, the regex is ```.*?``` so the closing must have three backticks. So in the example "```code```more ```", the first code block is "```code```", then the next part is "more ", then the next code block is "```" (but that's three backticks, so it's a zero-length code block? Or the regex would capture the next ``` as the start and end? Not sure.

Hmm, perhaps the regex should be adjusted to ensure that the closing ``` is not part of a longer sequence. Alternatively, maybe it's okay for the code block to have zero-length content. The problem says "code blocks", so perhaps that's acceptable.

Another possible issue: the code uses re.split, which may return empty strings. For example, if the text starts with a code block, then the first part is empty, then the code block is next.

But in the loop, when i is 0 (even), part is empty. Processing that part (non-code) would have no tags, so no problem.

Now, the test-driven approach. The user wants me to first generate comprehensive unit tests before writing the code. But since I'm to output only the code, I need to ensure that the code works as per the tests I would have written.

Wait, the user's instruction says to generate the code based on the function signature and docstring, and to follow TDD by first writing tests, but the output is only the code. So I should write the code that would pass those tests.

Now, let me think of some test cases.

Test 1: No code blocks, simple tags.

Input text: "Hello #world, this is a #test. #hashtag"

Expected tags: {'#world', '#test', '#hashtag'}, and the replaced text would depend on the replacer.

Test 2: With code blocks.

Text: "Check #tag1 here. ```code with #tag2``` and #tag3 outside."

Tags should be #tag1 and #tag3 (since #tag2 is inside code block). The replaced text should replace #tag1 and #tag3 if replacer is used.

Test 3: Replacer function.

Suppose replacer(tag) returns tag.upper(). Then, in the example above, the replaced text would have #TAG1, and #TAG3 replaced, but the code block remains as is.

Test 4: Edge case with no tags.

Text: "No tags here." → returns empty set and same text.

Test 5: Tags at the start or end of a non-code part.

Text: "#start #middle #end" → all three tags.

Test 6: Code block with a tag, and another tag outside.

Text: "Outside #out ```#in```" → tags are {'#out'}, and replaced text would replace #out but leave #in in code.

Now, the code as I outlined earlier should handle these cases.

Wait, but in the code, the regex for tags is r'#\w+', so it would match #start, #middle, #end, etc. What about a tag like #123? That would be matched as well, which is okay.

Another possible issue: the regex might include the # followed by non-word characters, but the current regex only matches word characters. For example, a tag like #hello-world would be split into #hello and then -world, but the regex would only capture #hello. So maybe the regex should be more permissive, like r'#\w+', but that might not be correct.

Alternatively, perhaps the tag is any sequence of characters starting with # followed by any characters until whitespace or punctuation. Hmm, but that complicates the regex.

The problem statement doesn't specify, so perhaps the initial approach is acceptable. Let's proceed.

Another possible problem in the code: the code_pattern uses re.DOTALL, so the .*? can include newlines. That's correct for multi-line code blocks.

Now, the code uses the tag_pattern as re.compile(r'#\w+', re.IGNORECASE). Wait, the re.IGNORECASE is for case-insensitive matching? No, the flag is set, but the pattern is just matching the # followed by any word characters (letters, digits, underscores). The case-insensitive flag might not be needed here unless tags are case-insensitive, but the problem doesn't specify. So perhaps removing the flag.

Wait, in the current code, the tag_pattern is written as:

tag_pattern = re.compile(r'#\w+')

without flags. Because the re.IGNORECASE is not needed unless the problem requires case-insensitive matching of the tag content, but the problem doesn't say that. So that's okay.

Wait, in the code I wrote earlier, I had:

tag_pattern = re.compile(r'\B#\w+|\b#\w+', re.IGNORECASE)

Wait, no, in my earlier code outline, I wrote:

Wait, looking back, in the code outline I wrote:

# Let's proceed with that for now.

# find all tags in this part.

matches = tag_pattern.findall(part)

Wait, but in my initial code draft, I had:

# assuming tags are words starting with # followed by word characters

# regex for tags: r'\B#\w+|\b#\w+', but perhaps better to just use r'#\w+'

Wait, perhaps the correct regex is r'#\w+', which matches any # followed by one or more word characters (letters, digits, underscores). This would capture hashtags like #hello, #123, but not #_ (if that's a valid tag). But the problem's requirements are unclear.

Alternatively, maybe the tag is any sequence of characters starting with a # and followed by any characters until whitespace or punctuation. But without more info, I'll stick with the simple regex.

Now, let me write the code properly, incorporating all these steps.

Wait, in the code outline, I used:

parts = code_pattern.split(text)

But code_pattern is re.compile(r'```.*?```', re.DOTALL). So split on that pattern.

Then, looping through each part, and checking if the index is even (non-code) or odd (code).

Wait, in the split, the first element is the part before the first code block. The next is the first code block, then the part after, etc.

So for the loop, for each part in parts:

if i % 2 ==0 → non-code.

Else → code.

Yes.

Now, the code for collecting the tags and replacing:

For each non-code part, find all tags using the regex, add to all_tags.

If replacer is provided, replace each tag in the part using sub.

Wait, the replacement code uses:

replaced_part = tag_pattern.sub(replace_func, part)

The replace_func takes the match and returns replacer(tag).

Yes.

Now, the code's return is (all_tags, new_text).

Wait, but all_tags is a set of the strings found. So for example, in the first test case, the tags are stored as strings like '#world', etc.

Now, let's see if this code works.

Another possible issue: in the regex for tags, the # is matched, but if there's a # inside a code block, it's ignored. So that's correct.

Now, let's code this.

Wait, also, the code uses:

from typing import Set, Tuple

So the imports must be included.

Now, putting it all together.

Wait, the code_pattern is re.compile(r'```.*?```', re.DOTALL). But this may include the triple backticks themselves in the code parts. So when split, the code parts are the actual code blocks, including the triple backticks. So when reassembling, they are kept as is.

Yes.

Now, the code:

import re
from typing import Set, Tuple, Callable

def find_tags(text: str, replacer: Callable[[str], str] = None) -> Tuple[Set[str], str]:
    code_pattern = re.compile(r'```.*?```', re.DOTALL)
    parts = code_pattern.split(text)
    all_tags = set()
    new_parts = []
    tag_pattern = re.compile(r'#\w+')
    
    for i, part in enumerate(parts):
        if i % 2 == 0:  # non-code part
            # find tags
            matches = tag_pattern.findall(part)
            all_tags.update(matches)
            # replace if needed
            if replacer:
                def replace_func(match):
                    return replacer(match.group())
                replaced_part = tag_pattern.sub(replace_func, part)
                new_parts.append(replaced_part)
            else:
                new_parts.append(part)
        else:  # code part, leave as is
            new_parts.append(part)
    new_text = ''.join(new_parts)
    return (all_tags, new_text)

Wait, but the replacer is a function that takes a tag (string) and returns a replacement string. So in replace_func, the match.group() gives the matched tag (e.g., "#world"), and replacer is called with that.

Yes.

Now, testing this code with some examples.

Test 1:

text = "Hello #world, this is a #test. #hashtag"

replacer = lambda x: x.upper()

all_tags should be {'#world', '#test', '#hashtag'}, new text should be "Hello #WORLD, this is a #TEST. #HASHTAG"

Yes.

Test 2:

text = "Check #tag1 here. ```code with #tag2``` and #tag3 outside."

The code parts are the ```...``` part.

The non-code parts are before and after.

Tags are #tag1 and #tag3.

The replaced text would replace those if replacer is used.

Another test: code block with no tags.

text = "Some text #tag. ```code block``` #another"

Tags are #tag and #another.

Yes.

Now, what about a tag that's not followed by word characters?

Suppose text = "This is #123 and #abc123 and #a-b-c".

The regex r'#\w+' would match '#123' (since digits are \w), '#abc123', but not '#a-b-c' because the hyphen is not a word character. So the tag '#a-b-c' would not be captured. But according to the regex, it's not matched. So if the problem requires that hyphens are allowed in tags, the regex needs to be adjusted. But without more info, the current code may have this limitation.

The problem's docstring says "Find tags in text." without specifying the format, so perhaps the user expects the hashtag style, and the code is okay.

Another possible issue: the regex matches # followed by any word characters, so a tag like #_abc would be matched (since _ is \w). That's okay.

Now, the code seems correct.

Wait, in the code, the tag_pattern is r'#\w+', which requires at least one word character after the #. So a tag like # (just a # with nothing after) would not be captured. That's probably correct.

Thus, the code should work as required.
