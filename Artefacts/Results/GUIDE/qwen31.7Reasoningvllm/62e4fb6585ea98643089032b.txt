
Okay, I need to write a Python function called parse_version that takes a string and returns a tuple of integers. The string is concatenated with dots, like "1.2.3". So the function needs to split the string on dots and convert each part to an integer.

First, I should split the input string. The split method with a dot as the separator would split it into parts. For example, "1.2.3" becomes ["1", "2", "3"]. Then, I need to convert each of those parts to integers. So each element in the list should be converted to an int.

Wait, but what if the string is empty or has no dots? Well, the problem probably assumes that the input is a valid version string, so maybe we don't need to handle those cases. But the function should probably return an empty tuple in those cases. But the docstring doesn't mention handling invalid inputs, so maybe the function is supposed to assume that the input is valid.

So the steps are: split the string into parts using '.', then map each part to an integer, then return them as a tuple.

So the code would be something like:

def parse_version(s: str) -> tuple[int, ...]:
    parts = s.split('.')
    return tuple(map(int, parts))

Wait, but in Python, the split method with a string as the separator splits on each occurrence. So for example, "1.2.3" becomes ["1", "2", "3"], which is correct. Then mapping each to int, and converting to a tuple.

Yes, that should work. Let me test some examples. If the input is "1.2.3", the parts are ["1", "2", "3"], converted to 1, 2, 3, tuple is (1, 2, 3). If the input is "0.0.0", it returns (0, 0, 0). If the input is empty string, split would return [""], then mapping to int would be 0, but the tuple would be (0,). But the function's docstring doesn't mention handling that, so maybe that's acceptable.

So the code is straightforward. The function splits the string, converts each part to integer, and returns as a tuple. That's all.
