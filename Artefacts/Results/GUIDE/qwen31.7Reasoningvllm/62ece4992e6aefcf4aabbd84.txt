
Okay, I need to write a Python function called is_ipv4 that checks if a given target is an IPv4 address. Let me think about how to approach this.

First, I remember that an IPv4 address is a 32-bit number divided into four octets, each ranging from 0 to 255. So the format is something like 192.168.1.1. But there are some edge cases, like leading zeros, or numbers with dots, or even numbers that are more than 255.

Wait, the function needs to return True if the target is a valid IPv4 address. So the steps would be:

1. Check if the input is a string. If it's not a string, return False.
2. Split the string into four parts using the dot as a delimiter. If there are not exactly four parts, return False.
3. For each part, check if it's a valid integer between 0 and 255 inclusive.
4. Also, ensure that each part is a non-negative integer. If any part is negative, return False.
5. Also, check that each part is a valid integer. For example, if a part is "123.", that's invalid.

Wait, but how to split the string? For example, "192.168.0.1" splits into four parts. But what about "192.168.0.1."? That would have five parts, so it's invalid.

So the steps are:

- Check if the input is a string. If not, return False.
- Split the string into parts. If the split results in less than four or more than four parts, return False.
- For each part, check if it's a valid integer. Also, check that each part is between 0 and 255.

But how to handle leading zeros? Like "0001" is valid as an integer, but as a string, it's "0001" which would be 1. So the code should handle that.

Wait, but when you split the string into parts, each part is a string. So for example, "192.168.0.1" would split into ["192", "168", "0", "1"], which are all valid. But if a part is "0", that's okay. If a part is "255", that's okay. If a part is "256", that's invalid.

So the code needs to process each part as a string, convert it to an integer, and check if it's between 0 and 255.

But also, the entire string must be a valid IPv4 address. So for example, "192.168.0.1" is valid, but "192.168.0.1." is invalid because of the trailing dot.

So the steps:

Check if the input is a string. If not, return False.

Split the string into parts. If the split has not exactly four parts, return False.

For each part in the parts list:

- Check if it's a valid integer. How? Well, try converting it to an integer. If it's not possible, return False.

- Then check if the integer is between 0 and 255 inclusive.

But also, check that each part is a non-negative integer. For example, if a part is "-1", that's invalid.

So, code steps:

def is_ipv4(target):

    if not isinstance(target, str):
        return False

    parts = target.split('.')
    if len(parts) != 4:
        return False

    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False

    return True

Wait, but what about leading zeros? Like "0001" is allowed as an integer, but when converted to int, it's 1. So that's okay. The code would handle that.

But what about cases where the part is something like "123.456.789.0"? The code would split into four parts, each converted to int. But 789 is greater than 255, so it would return False.

But wait, what about "255.255.255.255"? That's valid. So the code would return True.

But what about "256.0.0.0"? The code would check if 256 is between 0 and 255, which it's not, so returns False.

But what about "192.168.0.1" which is valid. So the code returns True.

But there's a problem here. The code checks if each part is a digit. For example, if the part is "123.", then part.isdigit() would return False, because the string ends with a dot. So the code would return False, which is correct.

But what about "192.168.0.1."? The split would be ["192", "168", "0", "1", ""], which is five parts. So len(parts) is 5, so returns False.

But what about "192.168.0.1.2"? Similarly, len(parts) is 5, so returns False.

So the code seems to handle that.

But there's another edge case: what if the target is "255.255.255.255"? That's valid. So the code returns True.

Another case: "0.0.0.0" is valid. So code returns True.

But what about "0.0.0.255"? That's valid.

But what about "123.45.67.89"? All parts are digits, and each is between 0 and 255. So returns True.

But what about "123.45.67.890"? The last part is 890, which is over 255. So returns False.

So the code seems to handle that.

But wait, what about a part that is "000"? That's allowed as an integer 0. So the code would return True.

But what about a part that is "0001"? It's converted to 1, which is okay.

So the code seems to handle that.

But there's another thing: the code checks if each part is a digit. But what about parts that have leading zeros but are valid integers? Like "0001" is allowed. But the code would check if part.isdigit(), which for "0001" is True. So that's okay.

But what about parts that are not digits? Like "a.b.c.d" would split into ["a", "b", "c", "d"], and part.isdigit() would return False for each, so returns False.

So the code seems to handle that.

But what about a part that is "123.45.67.89"? The code would split into four parts, each is a digit, so it's okay.

But what about a part that is "123.45.67.890"? The last part is 890, which is over 255, so returns False.

So the code seems to handle that.

But there's another edge case: what if the target is "255.255.255.255"? That's valid. So code returns True.

Another case: "255.255.255.256" would have the last part as 256, which is over 255, so returns False.

But what about "255.255.255.255"? That's valid.

So the code seems to handle all these cases.

But wait, what about the case where the target is "192.168.0.1" but the parts are split into four parts. So the code would process each part.

But what about if the target is "192.168.0.1.2"? Then len(parts) is 5, so returns False.

So the code seems to handle that.

But there's another thing: the code checks if each part is a digit. But what about parts that are not digits but have leading zeros? Like "0001" is allowed, but part.isdigit() returns True.

Yes, because "0001" is a string of digits. So the code would process it.

So the code seems to handle that.

But there's another edge case: what if the target is "192.168.0.1" but the parts are split into four parts. So the code would process each part.

But what about if the target is "192.168.0.1" but the parts are split into four parts. So the code would process each part.

So the code seems to handle that.

But what about the case where the target is "192.168.0.1.2"? The split would have 5 parts, so returns False.

So the code seems to handle that.

But there's another thing: the code checks if each part is a digit. But what about parts that are not digits but have leading zeros? Like "0001" is allowed, but part.isdigit() returns True.

Yes, because "0001" is a string of digits.

So the code seems to handle that.

But what about a part that is "0"? That's allowed. So the code would return True.

So the code seems to handle all the cases.

But wait, what about the case where the target is "123.45.67.89" (four parts, all digits, but each is between 0 and 255). So the code returns True.

Yes.

But what about a part that is "255"? That's allowed.

So the code seems to handle that.

So the code seems to be correct.

But wait, there's another thing: the code checks if each part is a digit. But what about parts that are like "123."? For example, if the target is "123.45.67.89.", then the split would be ["123", "45", "67", "89", ""], which has 5 parts. So len(parts) is 5, returns False.

So the code handles that.

So the code seems to be correct.

But there's another edge case: what if the target is "255.255.255.255"? That's valid. So code returns True.

Another case: "0.0.0.0" is valid. So code returns True.

Another case: "1.2.3.4" is valid.

So the code seems to handle all these cases.

But what about the case where the target is "192.168.0.1" but the parts are split into four parts. So the code would process each part.

So the code seems to be correct.

Therefore, the code would be:

def is_ipv4(target):
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True

Wait, but what about parts that are not digits but have leading zeros? Like "0001" is allowed. But part.isdigit() returns True, so it's okay.

Yes.

But what about parts that are empty strings? For example, if the target is "192.168.0.1.", then the split would be ["192", "168", "0", "1", ""], which has 5 parts. So len(parts) is 5, returns False.

So the code handles that.

Another case: target is "192.168.0.1" (valid), returns True.

Another case: target is "192.168.0.1a" (split into 4 parts, but the last part is "1a", which is not a digit. So returns False.

Yes.

So the code seems to handle all cases.

But wait, what about a part that is "123.45.67.890"? The last part is 890, which is over 255, so returns False.

Yes.

So the code seems to be correct.

But wait, what about a part that is "123.45.67.89"? All parts are digits, and each is between 0 and 255. So returns True.

Yes.

So the code is correct.

But there's another edge case: what if the target is "255.255.255.255"? That's valid. So returns True.

Another case: "255.255.255.256" returns False.

Yes.

So the code seems to handle all cases.

Therefore, the code is correct.
