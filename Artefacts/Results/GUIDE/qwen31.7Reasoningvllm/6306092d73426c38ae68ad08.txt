
Okay, I need to generate Python code for the _get_conditionally_required_args function based on the given docstring. Let me start by understanding the problem.

The function is supposed to return a list of argument names that are required when a certain condition is met. The parameters are command_name, options_spec, and args. The docstring says that the function lists arguments with required_when condition matched.

First, I need to figure out how the required_when condition works. The options_spec is a list of command spec options. Each option might have a required_when attribute. So, for each argument in args, I need to check if any of the options in options_spec have a required_when that matches the argument's condition.

Wait, but how are the arguments structured? The args parameter is a list of arguments. Each argument is probably a dictionary with name and value. But the function's parameters don't specify that. Hmm, maybe the args are a list of dictionaries, each with 'name' and 'value' keys. Or maybe they are just the names of the arguments. But the function's docstring doesn't specify, so I need to make an assumption here.

Wait, the function's parameters are command_name, options_spec, and args. The return is a list of argument names that are required when the condition is met. So, the args are the received input arguments, and each argument has a name. The options_spec is a list of command spec options, each possibly having a required_when attribute.

So, the approach would be:

1. Iterate over each argument in args.
2. For each argument, check if any of the options in options_spec have a required_when that matches the argument's condition.
3. If so, add the argument's name to the result list.

But how to determine the condition? The required_when is probably a key in the option's spec. For example, an option might have required_when='some_condition'.

Wait, the function's parameters are options_spec, which is a list of command spec options. Each option in options_spec might have a required_when attribute. So, for each option in options_spec, we check if the argument's name is required when that option is present.

Wait, but the function's docstring says "List arguments with required_when condition matched." So, the required_when is a condition that depends on the option's spec. So, for each argument, if there's an option in options_spec that has a required_when that is met when the argument is provided.

But how to determine if the condition is met? Maybe the required_when is a boolean value, or a condition that depends on the argument's value.

This is a bit unclear. Maybe the required_when is a string that indicates a condition, like 'required' or 'optional', and the argument is required when that condition is met.

Alternatively, perhaps the required_when is a key in the option's spec, and the argument is required when that key is present.

But without more information, I need to make assumptions. Let's assume that each option in options_spec is a dictionary with a 'required_when' key. For example, an option might be {'required_when': 'some_condition'}, and the argument is required when that condition is met.

But how to check if the condition is met? Maybe the condition is a string that the argument's value must satisfy. For example, if the required_when is 'value_exists', then the argument must have a value.

Alternatively, maybe the required_when is a boolean, like True or False, indicating whether the argument is required.

But the function's parameters don't specify how the required_when is structured. This is a problem.

Wait, the function's docstring says that the return is a list of argument names with matched required_when condition. So, the function is supposed to check for each argument if the required_when condition is met based on the options_spec.

Perhaps the options_spec is a list of dictionaries, each with a 'required_when' key. For each argument in args, check if any of the options in options_spec have a required_when that is True, and the argument is present.

Wait, but the function's parameters are command_name, options_spec, and args. The args are the received input arguments. So, maybe the args are a list of dictionaries, each with 'name' and 'value' keys. For example, args could be [{'name': 'option1', 'value': 'value'}, ...].

So, the steps would be:

For each argument in args:

- Check if any of the options in options_spec have a required_when that is True, and the argument's name is present.

But how to determine if the required_when is met. Maybe the required_when is a condition that the argument must be present. For example, if the required_when is 'required', then the argument must be present.

Alternatively, maybe the required_when is a key in the option's spec, and the argument is required when that key is present.

But without knowing the exact structure, it's challenging. However, the function's docstring doesn't provide enough details, so I need to make an assumption.

Let me think of a possible implementation. Suppose that each option in options_spec is a dictionary with a 'required_when' key, which is a string indicating the condition. For example, 'required', 'optional', etc. The argument is required when the option's required_when is met.

But how to check if the condition is met. For example, if the required_when is 'required', then the argument must be present. If it's 'optional', then the argument is not required.

But the function's return is a list of argument names that are required when the condition is met. So, perhaps the function is supposed to return the arguments that are required when any of the options in options_spec have a required_when that is True.

But this is getting too vague. Maybe the function is supposed to check for each argument if there's an option in options_spec that has a required_when that is True, and the argument is present.

Alternatively, maybe the required_when is a condition that the argument must be present. For example, if the required_when is 'required', then the argument must be present.

But without more info, I need to proceed with the best possible assumption.

Let me proceed with the following approach:

- Iterate through each argument in args.
- For each argument, check if there's any option in options_spec that has a required_when that is True, and the argument is present.

But how to check if the argument is present. If the args are a list of dictionaries with 'name' and 'value', then the argument is present if 'name' is in the args.

But the function's parameters don't specify the structure of args. So, perhaps args is a list of strings, each being the name of an argument. Then, the function would check if any of the options in options_spec have a required_when that is True, and the argument is present in args.

But this is still unclear. However, given the lack of information, I need to proceed.

Let me assume that args is a list of strings, each being the name of an argument. The options_spec is a list of dictionaries, each with a 'required_when' key. The function returns the list of arguments (names) that are required when any of the options in options_spec have a required_when that is True.

So, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    result = []
    for arg in args:
        for option in options_spec:
            if option['required_when'] is not None and option['required_when']:
                result.append(arg)
                break
    return result

But this is a very simplistic approach. However, given the lack of information, this is the best I can do.

Alternatively, maybe the required_when is a condition that the argument must be present. For example, if the required_when is 'required', then the argument must be present.

But again, without knowing the exact structure, it's hard to say.

Another possibility is that the required_when is a string that indicates the condition, and the argument is required when that condition is met. For example, if the required_when is 'required', then the argument must be present.

But again, without knowing how the required_when is structured, it's hard to code.

Given the ambiguity, the code would need to handle the possible cases. However, the problem says to generate code based on the function signature and docstring. So, the code must be written in a way that matches the parameters and returns the correct list.

Another approach: the function is supposed to return the list of arguments that are required when the condition is met. The condition is determined by the options_spec. So, for each argument, check if any of the options in options_spec have a required_when that is True, and the argument is present.

So, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for arg in args:
        # Check if any option in options_spec has required_when True
        for option in options_spec:
            if option.get('required_when') and option['required_when']:
                required_args.append(arg)
                break
    return list(set(required_args))  # To avoid duplicates

But this is assuming that the required_when is a boolean value in the options_spec. However, the docstring doesn't specify this. But given the parameters, this is the best possible approach.

Alternatively, maybe the required_when is a string, and the argument is required when that string is present. But again, without knowing, it's hard.

In conclusion, the code would need to check each argument against the options_spec for any option that has a required_when that is True, and collect those arguments. The code would look something like the above.

Now, I need to write the code in Python, following the function signature and docstring. The function is part of a class, but the code is to be generated as a standalone function. However, the user says to output only the code generated, in Python markdown format. So, the code would be a function with the given parameters.

So, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    """
    List arguments with ``required_when`` condition matched.

    :param command_name: the command name.
    :param options_spec:  the list of command spec options.
    :param args: the received input arguments
    :return: list, list of argument names with matched ``required_when`` condition
    """
    result = []
    for arg in args:
        for option in options_spec:
            if option.get('required_when') and option['required_when']:
                result.append(arg)
                break
    return result

But wait, the function is part of a class, but the code is to be generated as a standalone function. However, the user says to output only the code generated, so the function is written as is.

But the function is supposed to be part of a class. However, the user hasn't provided the class definition, so the code is to be written as a standalone function. But the problem says to generate code based on the function signature and docstring. So, the code is the function as written.

So, the final code would be as above. However, the function is supposed to return a list of argument names. The code checks each argument in args, and if any option in options_spec has required_when True, adds the argument to the result.

But the code may have issues if args is not a list of strings, but given the parameters, this is the best possible approach.
