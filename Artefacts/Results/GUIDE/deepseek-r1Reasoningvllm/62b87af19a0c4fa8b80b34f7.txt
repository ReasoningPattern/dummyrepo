Okay, so I need to write a Python function called difference that takes two dictionaries, d1 and d2, and an optional level parameter. The function should return a dictionary containing items from d1 that are not present in d2. Hmm, let's think about how to approach this.

First, I should understand what the function needs to do. The basic idea is to compare the items in d1 and d2. For each key-value pair in d1, I need to check if that key exists in d2. If it doesn't, I include it in the result. But wait, what about the case when the values are nested dictionaries? Oh right, the level parameter comes into play. So if level is greater than 0, I need to go deeper into the nested dictionaries and compare the values at that level.

Let me outline the steps. The function should handle both the top level (level=0) and deeper levels. For each key in d1, I'll check if the corresponding value in d2 exists at the specified level. If it doesn't, I add it to the result.

Wait, but how do I handle nested structures? Maybe I should write a helper function that recursively checks each level. That helper function can take the current level as an argument. If the level is 0, it just checks if the key exists in d2. If the level is higher, it checks if the value in d2 is a dictionary and then proceeds to the next level.

But wait, what if d2 doesn't have the key at the current level? Then we should include the key-value pair from d1 in the result. So the helper function should return True if the key exists at the current level in d2, otherwise False. Then, for each key in d1, if the helper function returns False, we include it in the result.

Let me structure this. The helper function, let's call it is_in, will take the current dictionary, the key, and the current level. It will return True if the key is present in the dictionary at the specified level.

So, in the helper function:
- If level is 0, check if key is in the current dictionary.
- Else, check if the current dictionary's value for the key is a dict. If not, then the key isn't present at this level, so return False.
- If it is a dict, then recursively call is_in on that value with level-1.

Wait, but what if the current dictionary isn't a dict? Like, if it's another type, then it can't have a key, so return False. So in the helper, the first check is whether the current value is a dict. If not, return False.

Putting it all together, the helper function will recursively check each level. Now, in the main function, I'll iterate over each key-value pair in d1. For each key, I'll call the helper function with d2, the key, and the given level. If the helper returns False, meaning the key isn't present in d2 at that level, I add the key-value pair to the result.

Now, about testing. The user mentioned using a test-driven approach. So I should think about various test cases to ensure the function works correctly.

Test case 1: level=-1. According to the docstring, this should return items from d1 not in d2. Wait, but how does level=-1 work? The default is -1, which probably means compare the top-level keys. So in this case, the helper function would check if the key exists in d2 at level 0. If not, include it.

Test case 2: level=0. Same as level=-1, perhaps. Or maybe level=-1 is a special case for all levels. Wait, the default is level=-1, so perhaps the helper function treats level=-1 as 0. Or maybe the function should handle negative levels differently, but the user didn't specify. Hmm, maybe I should treat level=-1 as 0, meaning compare the top level.

Another test case: nested structures. For example, d1 has a key 'a' whose value is a dict with another key 'b'. d2 has a key 'a' whose value is a dict, but at level 1, 'b' is missing. Then, the function should include 'a' in the result if level is 1.

Wait, but how does the helper function handle different levels? Let me think. If level is 1, it will check if d2's 'a' is a dict, then check if 'b' is present at level 0 in that dict. If 'b' is missing, then it's included.

So, the helper function should correctly handle these cases.

Another edge case: if d1 and d2 are both empty. Then the result should be empty.

What if d1 has a key that's not in d2, but at a deeper level? For example, d1 has key 'x' with value {'y': 1}, and d2 has key 'x' with value {'y': 2, 'z':3}. If level is 1, then 'y' is present, but 'z' is not. Wait, no, the helper function would check if the value in d2 is a dict. So for key 'x' in d1, the helper function would check if d2's 'x' is a dict (yes), then check if 'y' is present at level 0 (yes), then check if 'z' is present at level 1? Wait, no, the helper function is designed to check each level step by step.

Wait, maybe I should adjust the helper function. For example, for each level, it checks if the current value is a dict. If it is, it proceeds to the next level. If not, it returns False, meaning the key isn't present at this level.

Wait, no. Let me clarify. The helper function is_in takes d, key, level. It checks if d is a dict. If not, return False. Else, if level is 0, check if key is in d. Else, check if the value at d[key] is a dict, and call is_in on that value with level-1.

Wait, no. That would go too deep. For example, if d is a dict, and the value is a dict, and we're at level 1, we check if the value is a dict, then proceed to level 0 of that value. So for level=1, it's checking if the key exists in the value dict at level 0.

Yes, that makes sense.

So, putting it all together, the helper function is_in is defined as:

def is_in(d, key, level):
    if not isinstance(d, dict):
        return False
    if level == 0:
        return key in d
    else:
        current_value = d.get(key)
        if isinstance(current_value, dict):
            return is_in(current_value, key, level - 1)
        else:
            return False

Wait, but what if the key isn't in d? Then d.get(key) returns None, which is not a dict, so returns False. That's correct because if the key isn't present, it's not in the dictionary at that level.

So, in the main function, for each key in d1, we call is_in(d2, key, level). If it returns False, meaning the key isn't in d2 at that level, then we include it in the result.

Wait, but the function is called difference(d1, d2, level=-1). So, the helper function is_in is checking if the key is present in d2 at the given level. If it's not present, then the item from d1 is included.

So, in the main function, the result is built by iterating over d1.items(), and for each key-value pair, if is_in(d2, key, level) is False, then add it to the result.

Now, considering the default level=-1. How should that be handled? Maybe in the helper function, level=-1 is treated as 0. Or perhaps the helper function should have a condition that if level is negative, it's treated as 0. Or maybe the function difference should handle level=-1 as comparing the top level, and level=0 as also top level. Wait, but the user's docstring says level=-1, so perhaps that's a special case.

Wait, the docstring says, "Return a dictionary with items from d1 not contained in d2." So, for level=-1, perhaps it's comparing the top level keys, ignoring the values. So, if a key is present in d2 at the top level, the item from d1 is excluded, regardless of the value.

But wait, in the helper function, if level is -1, how is that handled? Because in the helper function, level is passed as is. So maybe I should adjust the helper function to treat level=-1 as 0.

Alternatively, in the main function, if level is -1, we treat it as 0. So, in the main function, before calling is_in, we can set level = max(level, 0) or something. Or perhaps in the helper function, if level is negative, it's treated as 0.

Hmm, perhaps in the helper function, if level is less than 0, set it to 0. Because level=-1 would be treated as 0, meaning compare the top level.

So, in the helper function, the first line could be:

if level < 0:
    level = 0

That way, level=-1 is treated as 0.

Alternatively, in the main function, when calling is_in, we can adjust the level.

I think that's a good approach. So, in the helper function, handle level as non-negative.

Now, let's outline the code.

First, the helper function is_in:

def is_in(d, key, level):
    if level < 0:
        level = 0
    if not isinstance(d, dict):
        return False
    if level == 0:
        return key in d
    else:
        current_value = d.get(key)
        if isinstance(current_value, dict):
            return is_in(current_value, key, level - 1)
        else:
            return False

Wait, but in the else part, if current_value is not a dict, return False. So, if the key is present in d but not a dict, it's not considered as present at this level.

Yes, that's correct.

Now, the main function difference:

def difference(d1, d2, level=-1):
    result = {}
    for key, value in d1.items():
        if not is_in(d2, key, level):
            result[key] = value
    return result

Wait, but what about the case where d2 doesn't have the key at all? Then is_in returns False, so the item is added. That's correct.

Testing this function:

Test case 1: level=-1.

d1 = {'a': 1, 'b': 2}
d2 = {'a': 3, 'c':4}
difference(d1, d2) should return {'b':2}.

Test case 2: level=0.

Same as above, since level=-1 is treated as 0.

Test case 3: level=1.

d1 = {'a': {'x': 1}, 'b': {'y': 2}}
d2 = {'a': {'x': 3, 'z':4}, 'c': {'y':5}}
difference(d1, d2, level=1) should return {'b': {'y':2}} because 'y' is present in d2 at level 1.

Wait, no. Because in d2, 'a' has {'x':3, 'z':4}, so 'x' is present at level 0, but 'y' is not in 'a' at level 0. Wait, no, 'a' in d2 has 'x' and 'z', but 'y' is in 'c' at level 0. So, for 'a' in d1, the value is {'x':1}, which is a dict. So, in d2, 'a' is a dict, so we check level 0. 'x' is present, so 'a' in d1 is not included. For 'b' in d1, the value is {'y':2}, which is a dict. In d2, 'b' is not a key, so when checking level 1, since d2 doesn't have 'b', is_in returns False, so 'b' is included.

Wait, no. Let's see: in d2, 'a' is a dict, but 'b' is not a key in d2. So, when checking for 'b' in d1 at level 1, is_in will check if d2 has 'b' at level 1. Since d2 doesn't have 'b' at level 0, and since d2's value for 'b' is not present, is_in returns False, so 'b' is included.

Yes, that's correct.

Another test case: d1 has a key whose value is a dict, and that dict has a key that's not in d2 at the given level.

d1 = {'a': {'x': 1}}
d2 = {'a': {'x': 2, 'y':3}}
difference(d1, d2, level=1) should return {'a': {'x':1}} because 'x' is present in d2 at level 1.

Wait, no. Because in d2, 'a' is a dict, so at level 1, we check if 'x' is present in d2's 'a' dict. It is, so 'a' in d1 is not included.

Wait, no. Let me clarify: in d2, 'a' is {'x':2, 'y':3}, so at level 0, 'a' is present. At level 1, we check if 'x' is present in d2's 'a' dict. It is, so is_in returns True, so 'a' is not included in the result.

Yes, correct.

Another test case: d1 has a key whose value is a non-dict. For example, d1 = {'a': 5}, d2 = {'a': {'x':1}}. Then, at level=0, is_in checks if 'a' is in d2. Since d2's 'a' is a dict, level=0 would return False because d2's 'a' is a dict, not a key. Wait, no. Let me think: in the helper function, for level=0, it checks if key is in d. So, in d2, 'a' is a dict, so key 'a' is in d2, so is_in returns True. So, in this case, 'a' is present in d2, so it's not included in the result.

Wait, no. Because in d2, 'a' is a dict, so when checking level=0, the helper function returns True if 'a' is in d2. But 'a' is a dict, not a key. So, in d2, 'a' is a key whose value is a dict. So, when level=0, the helper function is_in(d2, 'a', 0) would check if 'a' is in d2. Yes, it is, so returns True. Therefore, 'a' is present in d2, so not included in the result.

Wait, but in d1, 'a' is 5, which is not a dict. So, when level=0, is_in checks if 'a' is in d2. Yes, it is, so 'a' is present, so not included.

But wait, if d1 is {'a':5}, and d2 is {'a':5}, then difference(d1, d2) would return an empty dict. That's correct.

Another case: d1 has a key 'a' with value {'b': {'c':1}}, d2 has 'a' with value {'b': {'c':2, 'd':3}}, level=2. Then, 'c' is present at level 2 in d2, so 'a' is not included. But if 'd' is not present, then 'a' would be included.

Yes, that makes sense.

Now, about the code. I think the helper function and the main function are correctly structured.

But wait, in the helper function, if the current_value is not a dict, return False. So, if d2 has a key that's not a dict, then it's treated as not present.

So, for example, d2 = {'a': 5}, and d1 = {'a': {'b':1}}, level=1. Then, is_in(d2, 'a', 1) would check if d2['a'] is a dict. It's not, so returns False. So, 'a' in d1 is included in the result.

Yes, that's correct because 'a' in d2 is not a dict, so at level 1, it's not considered present.

Another edge case: d2 doesn't have the key at any level. Then, all items in d1 are included.

For example, d1 = {'a': {'b':1}}, d2 = {'c':2}, level=1. Then, 'a' in d1 is included.

Yes.

Now, considering all these test cases, the code should handle them correctly.

So, putting it all together, the code would be:

Implement the helper function inside the difference function, or as a nested function.

Wait, in Python, it's better to define the helper function inside the main function to avoid global namespace pollution, especially if this function is part of a larger codebase.

So, perhaps the helper function is defined inside the difference function.

Alternatively, since the helper function is only used within difference, it can be nested.

So, the code would look like this:

def difference(d1, d2, level=-1):
    def is_in(d, key, level):
        if level < 0:
            level = 0
        if not isinstance(d, dict):
            return False
        if level == 0:
            return key in d
        else:
            current_value = d.get(key)
            if isinstance(current_value, dict):
                return is_in(current_value, key, level - 1)
            else:
                return False

    result = {}
    for key, value in d1.items():
        if not is_in(d2, key, level):
            result[key] = value
    return result

Yes, that looks correct.

Now, testing this code with various test cases should cover the scenarios.

Another test case: level=2.

d1 = {'a': {'b': {'c':1}}}
d2 = {'a': {'b': {'c':2, 'd':3}}}
difference(d1, d2, level=2) should return {'a': {'b': {'c':1}}} because 'c' is present in d2 at level 2.

Yes, because in d2, 'a' is a dict, 'b' is a dict, and 'c' is present. So, is_in returns True, so 'a' is not included.

But if 'c' is not present in d2 at level 2, then 'a' is included.

Yes.

I think this should handle all cases correctly.
