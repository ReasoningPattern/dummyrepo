Okay, I need to write a Python function called fetch_content_type that takes a URL string and returns an optional string. The docstring says it's setting the head of the request through the URL and USER_AGENT. Hmm, so I think this function is related to setting headers for a web request, maybe for a fetch request in a browser or something similar.

First, I should figure out what the function needs to do. It probably needs to set the Content-Type header based on the URL. So, the idea is that depending on the URL, the function determines the appropriate content type.

I remember that sometimes URLs can indicate the MIME type of the content. For example, images might have .png, .jpg extensions, and the content type would be image/png or image/jpeg. Similarly, PDFs might have .pdf extensions, and maybe text/plain for plain text files.

So, the plan is to parse the URL to extract the file extension and then map that to a content type. But wait, URLs can be more complex than just filenames. For instance, a URL might point to a webpage, a file, or an API endpoint. So, the function needs to handle different cases.

Let me think about the steps:

1. Extract the filename extension from the URL. But wait, the URL might not have a filename. For example, it could be a URL to a webpage or a server. So, maybe the function can't always determine the content type accurately, but it can try based on the path or the query parameters.

2. If the URL doesn't have a filename extension, perhaps it's a multipart form or a different type of request. In that case, maybe default content types like application/x-www-form-urlencoded or application/json could be used.

3. Alternatively, maybe the function should use the user agent to determine the content type, but the docstring suggests using the URL and USER_AGENT. So, perhaps the function is part of a browser extension or similar that needs to set headers based on the user's agent and the URL being requested.

Wait, maybe the function is intended to set the Content-Type header automatically when making a request to a given URL using a specific user agent. So, the function fetches the appropriate content type based on the URL and sets it in the headers.

So, how do I extract the content type from the URL? Let's see, perhaps the URL has a query parameter that specifies the content type, like in some APIs where you can specify the format. For example, http://example.com/api?format=json.

If that's the case, the function should check the URL parameters for common content types and set them accordingly. If not, it can default to something like application/json or text/html.

Alternatively, if the URL has a path that ends with a known MIME type, like images or PDFs, it can use that. But URLs can be tricky because the same filename can have different MIME types based on the context.

Another approach is to use a list of known MIME type mappings. For example, if the URL ends with .pdf, set the content type to application/pdf. If it's .html, set to text/html, etc.

But wait, the function's name is fetch_content_type, which makes me think it's fetching the content type based on the URL. So, perhaps it's intended to mimic how some web frameworks automatically determine the content type when a request is made.

I should also consider that the function might not always be accurate, especially for dynamic content or server-side URLs which don't have a file extension. In such cases, the function might default to a common content type like text/html or application/octet-stream.

So, putting it all together, the function should:

- Check if the URL has a query parameter that specifies the content type.
- If not, check the URL's path or filename extension to determine the content type.
- If still unsure, default to a common content type.

But how to implement this in Python? Let's outline the steps in code:

1. Parse the URL to extract the path and query parameters.
2. Check the query parameters for common content types like 'application/json', 'text/plain', etc.
3. If a query parameter is found, use its value as the content type.
4. If not, check the URL's path or filename for known MIME types.
5. If still not found, default to a sensible content type like 'text/html'.

Wait, but the function is supposed to set the head of the request through the URL and USER_AGENT. So, maybe the function is part of a larger code that constructs the headers. So, perhaps the function returns the content type string, which is then added to the headers.

But in the code example, the function is supposed to return Optional[str], so it can return None if it can't determine the content type.

So, the code structure would involve:

- Importing necessary modules like urllib.parse for URL parsing.
- Using urllib.parse.urlsplit to get the path and query.
- Checking the query parameters for known content types.
- If not found, extract the path and check for known extensions.
- If still not found, return a default content type or None.

Wait, but MIME types can be determined from the path as well. For example, if the path is /images/logo.png, the MIME type could be image/png. But this is more complex because it's not just the filename but the context.

Alternatively, perhaps the function is simpler and only looks at the query parameters or the filename extension.

Let me think of some examples:

- URL: http://example.com/logo.png → content type could be image/png.
- URL: http://example.com?param=value&format=json → content type is json.
- URL: http://example.com/api → no format specified, maybe default to application/json or text/html.

So, the function needs to handle these cases.

Now, considering the code:

I'll need to parse the URL into its components. Using urllib.parse.urlsplit, I can get the path and query.

Then, extract the query parameters. If there are any, check for known content types like 'application/json', 'text/plain', etc.

If no query parameters, then look at the path. For example, if the path ends with .html, .php, .asp, etc., set the content type accordingly.

Alternatively, check if the path contains certain keywords that indicate the MIME type, like 'image', 'pdf', etc. But this might be too simplistic.

Another approach is to use a dictionary that maps known filename extensions to MIME types. For example:

filename_extensions = {
    '.pdf': 'application/pdf',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.gif': 'image/gif',
    '.txt': 'text/plain',
    '.log': 'text/plain',
    # and so on
}

Then, if the URL's path or filename has an extension in this dictionary, use the corresponding MIME type.

But this approach has limitations. For instance, a URL like http://example.com/reports might have a filename 'reports.html' but the MIME type would be text/html, not application/x-reports.

Hmm, maybe a better approach is to use a list of possible MIME types and their corresponding filename extensions, and check for the presence of those extensions.

But this could get complicated. Alternatively, perhaps using a library like mimetypes could help, but I'm not sure if that's allowed or if it's overkill.

Wait, the function is supposed to be written without external libraries, so I should implement it manually.

So, perhaps the function will:

1. Parse the URL to get the path and query.
2. If there's a query, check for known content types.
3. If not, check the path for known extensions.
4. If still not found, return None or a default.

Let me outline the code step by step.

First, import the necessary modules:

import urllib.parse

Then, define the function:

def fetch_content_type(url: str) -> Optional[str]:
    # code here

Inside the function:

1. Parse the URL:

parsed_url = urllib.parse.urlsplit(url)

2. Extract the path and query.

path = parsed_url.path
query = parsed_url.query

3. Check the query parameters for known content types.

content_type = None
if query:
    params = urllib.parse.parse_qs(query)
    # Check for common content types
    if 'json' in params:
        content_type = 'application/json'
    elif 'html' in params:
        content_type = 'text/html'
    elif 'txt' in params:
        content_type = 'text/plain'
    # Add more checks as needed

4. If content_type is not set yet, check the path for extensions.

if not content_type:
    # Check for filename extensions
    filename_ext = None
    if path:
        # Split the path into components to get the last segment
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
    
    # Define known extensions and their MIME types
    content_type_extensions = {
        '.pdf': 'application/pdf',
        '.png': 'image/png',
        '.jpg': 'image/jpeg',
        '.gif': 'image/gif',
        '.txt': 'text/plain',
        '.log': 'text/plain',
        '.doc': 'application/msword',
        '.docx': 'application/vnd.openxmlformats-officedocument.wordprocess BabaX',
        # Add more as needed
    }
    
    if filename_ext in content_type_extensions:
        content_type = content_type_extensions[filename_ext]

5. If still not set, default to None or a sensible type.

if not content_type:
    content_type = 'text/html'  # or None

6. Return the content_type.

return content_type

Wait, but this approach might not cover all cases. For example, a URL like http://example.com?param=pdf would have the query param 'pdf', but if the content type is not specified, it might default to text/plain, which is incorrect. So, perhaps the function should prioritize query parameters over the path.

Also, the MIME type for .docx is actually 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', but that's a long string. Alternatively, using a more generic type like 'application/msword' might be better for simplicity.

Another consideration is that the function should return None if it can't determine the content type, but in the code above, it defaults to 'text/html'. Maybe it's better to return None unless a default can be safely assumed.

Alternatively, the function could return None if it can't determine the content type, allowing the caller to handle it.

So, perhaps adjust the code to return None if content_type remains unset after all checks.

Let me adjust the code:

if not content_type:
    return None

But wait, in the code above, if the path has an extension, it sets content_type. Otherwise, it sets it to 'text/html'. So, perhaps the function should only return None if it couldn't determine the content type through any method.

Hmm, maybe the function should only return a content type if it can determine it, otherwise return None. So, in the code, after all checks, if content_type is still None, return None.

So, in the code:

if not content_type:
    return None

But then, in the case where the path has no extension, it would return None, which might not be ideal. So, perhaps the function should default to a content type if it can't determine it through any means.

Alternatively, the function could set a default content type if no other information is available.

But perhaps the function should be designed to return None only when it can't determine the content type, and return a default otherwise.

Wait, the function's docstring says it's setting the head of the request through the URL and USER_AGENT. So, maybe the function is supposed to set the Content-Type header, and if it can't determine it, perhaps it leaves it as None or sets it to a default.

But the function returns Optional[str], so it can return None.

So, perhaps the function should return None if it can't determine the content type, and otherwise return the determined content type.

But in the code above, if the path has an extension, it sets content_type, otherwise, it sets it to 'text/html' and returns it. So, perhaps the function should only return None if neither the query nor the path have any information.

Wait, maybe the function should check both the query and the path for possible content types. If either provides a content type, use it. Otherwise, default to 'text/html' or None.

Alternatively, the function could prioritize the query over the path.

So, in the code:

if query exists:
    check for content types in the query
elif path exists and has an extension:
    check for content types in the path
else:
    default to 'text/html' or None

But in the code above, if the path has an extension, it sets content_type, otherwise, it sets it to 'text/html'. So, perhaps the function should default to 'text/html' if nothing else is found.

But the user might want the function to return None if it can't determine the content type, so perhaps the function should return None only when both the query and the path don't provide any content type.

Hmm, perhaps the function should first check the query parameters, then the path's extension, and if neither provides a content type, return None.

Wait, but in the code above, if the path has an extension, it sets content_type. So, perhaps the function should default to None only when neither the query nor the path have any content type information.

So, perhaps the code should be adjusted to:

if query:
    check query params
elif path:
    check path extension
else:
    return None

But wait, the path could be something like '/images/logo.png', which has an extension. So, in that case, the function should return 'image/png'.

But if the URL is 'http://example.com', with no query and no path, then return None.

So, perhaps the code should be:

if query:
    check query params
elif path:
    check path extension
else:
    return None

But then, in the case where the path has an extension, it would set content_type and return it, otherwise, return None.

Wait, but in the code above, if the path has an extension, it sets content_type and returns it. So, perhaps the function should return None only when neither the query nor the path have any content type information.

So, the code should be:

if query:
    check query params
elif path:
    check path extension
else:
    return None

So, in the code:

parsed_url = urllib.parse.urlsplit(url)
path = parsed_url.path
query = parsed_url.query

content_type = None

if query:
    params = urllib.parse.parse_qs(query)
    # Check for common content types
    if 'json' in params:
        content_type = 'application/json'
    elif 'html' in params:
        content_type = 'text/html'
    elif 'txt' in params:
        content_type = 'text/plain'
    # Add more checks as needed
elif path:
    # Check for filename extensions
    # ... code to extract filename extension and set content_type ...

if content_type is not None:
    return content_type
else:
    return None

Wait, but in the code above, if the path has an extension, it sets content_type, so the function returns it. If not, it returns None.

But perhaps the function should default to 'text/html' if the path doesn't have an extension but the query doesn't have any content types either.

Hmm, perhaps the function should first check the query, then the path, and if nothing is found, default to 'text/html'.

So, in the code:

if query:
    # process query
elif path:
    # process path
else:
    content_type = 'text/html'

return content_type

But wait, that would mean if the URL has neither a query nor a path with an extension, it defaults to 'text/html'.

But in the code above, if the path has an extension, it sets content_type and returns it. So, perhaps the function should return 'text/html' only if neither the query nor the path have any content type information.

Wait, I'm getting a bit confused. Let me try to structure the code properly.

First, parse the URL.

Then, check the query parameters for known content types.

If found, set content_type and return it.

Else, check the path for extensions.

If found, set content_type and return it.

Else, return None or default.

But the function is supposed to return Optional[str], so returning None is acceptable.

Alternatively, perhaps the function should always return a content type, even if it's a default.

But the problem statement says to return Optional[str], so it can return None.

So, perhaps the function should return None only when it can't determine the content type.

So, in code:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters
    if query:
        params = urllib.parse.parse_qs(query)
        if 'json' in params:
            content_type = 'application/json'
        elif 'html' in params:
            content_type = 'text/html'
        elif 'txt' in params:
            content_type = 'text/plain'
        # Add more checks as needed

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    return content_type if content_type is not None else None

Wait, but in this code, if the path has an extension, it sets content_type and returns it. If not, it returns None.

But perhaps the function should default to 'text/html' if neither the query nor the path have any content type information.

So, perhaps after checking the query and path, if content_type is still None, set it to 'text/html' and return it.

So, adjust the code:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters
    if query:
        params = urllib.parse.parse_qs(query)
        if 'json' in params:
            content_type = 'application/json'
        elif 'html' in params:
            content_type = 'text/html'
        elif 'txt' in params:
            content_type = 'text/plain'
        # Add more checks as needed

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # If still not determined, default to text/html
    if content_type is None:
        content_type = 'text/html'

    return content_type

Wait, but in this case, if the path has no extension, it would return 'text/html', which is better than None.

But perhaps the function should return None only when both the query and path don't provide any content type.

Alternatively, perhaps the function should default to None only when it can't determine the content type through any means.

Hmm, I think the function should return None only when it can't determine the content type, which would be when both the query and the path don't provide any content type information.

So, in the code above, if the query has a content type, it's used. Else, if the path has an extension, it's used. Else, it defaults to 'text/html'.

But perhaps the function should return None only when both are absent.

Wait, perhaps the function should return None only when neither the query nor the path have any content type information.

So, in code:

if query and content_type is None:
    check query
elif path and content_type is None:
    check path
else:
    return None

But in the code above, if the path has an extension, content_type is set, so it returns it.

Hmm, perhaps the function should return None only when both the query and path don't have any content type information.

So, adjusting the code:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters
    if query:
        params = urllib.parse.parse_qs(query)
        if 'json' in params:
            content_type = 'application/json'
        elif 'html' in params:
            content_type = 'text/html'
        elif 'txt' in params:
            content_type = 'text/plain'
        # Add more checks as needed

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # If still not determined, return None
    if content_type is None:
        return None

    return content_type

Yes, this way, if neither the query nor the path provide a content type, the function returns None. Otherwise, it returns the determined content type.

But wait, in the case where the path has no extension, it would return None, which might not be ideal. So, perhaps the function should default to 'text/html' only if the query doesn't provide any content type, but the path doesn't have an extension.

Alternatively, perhaps the function should always return a content type, even if it's a default.

But according to the problem statement, the function should return Optional[str], so returning None is acceptable.

But perhaps the function should default to 'text/html' if nothing is found.

Hmm, perhaps the function should always return a content type, defaulting to 'text/html' if nothing else is found.

So, adjusting the code:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters
    if query:
        params = urllib.parse.parse_qs(query)
        if 'json' in params:
            content_type = 'application/json'
        elif 'html' in params:
            content_type = 'text/html'
        elif 'txt' in params:
            content_type = 'text/plain'
        # Add more checks as needed

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # Default to text/html if still not determined
    if content_type is None:
        content_type = 'text/html'

    return content_type

But this way, if neither the query nor the path provide a content type, it defaults to 'text/html'.

But perhaps the function should return None only when both are absent.

Hmm, I think the function should return None only when it can't determine the content type through any means.

So, perhaps the function should return None if both the query and path don't provide any content type.

In that case, the code should be:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters
    if query:
        params = urllib.parse.parse_qs(query)
        if 'json' in params:
            content_type = 'application/json'
        elif 'html' in params:
            content_type = 'text/html'
        elif 'txt' in params:
            content_type = 'text/plain'
        # Add more checks as needed

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # If still not determined, return None
    return content_type if content_type is not None else None

Yes, this way, if the query provides a content type, it's used. Else, if the path has an extension, it's used. Else, it returns None.

So, the function will return None only when it can't determine the content type through either the query or the path.

But perhaps the function should default to 'text/html' if nothing else is found.

Alternatively, perhaps the function should always return a content type, even if it's a default.

But according to the problem statement, the function should return Optional[str], so returning None is acceptable.

So, the final code would be as above, with the function checking the query, then the path, and if nothing is found, returning None.

But wait, in the case where the URL is 'http://example.com/reports.pdf', the function would detect the .pdf extension and return 'application/pdf'. For a URL like 'http://example.com?param=json', it would return 'application/json'. For a URL like 'http://example.com?param=html', it would return 'text/html'. For a URL like 'http://example.com', it would return None.

But perhaps the function should default to 'text/html' if neither the query nor the path have any content type information.

Hmm, perhaps the function should return None only when both are absent.

So, the code seems correct as written.

Now, to test this function.

Test case 1: URL is 'http://example.com/logo.png'

- Query: None
- Path: '/logo.png'
- Content type: image/png → function returns 'image/png'

Test case 2: URL is 'http://example.com?param=pdf'

- Query: {'param': ['pdf']}
- Content type: None (since 'pdf' is not in the params dict)
Wait, no, in the code, the query params are parsed into a dictionary where the keys are the parameter names and the values are the lists of values. So, 'pdf' being in the query params would not set the content_type unless 'pdf' is one of the keys in the params dict.

Wait, no, in the code, the query is checked for 'json', 'html', 'txt'. So, if the query has 'pdf' as a parameter, it won't set content_type to 'application/pdf' unless 'pdf' is one of the keys.

Wait, that's a mistake. The current code only checks for specific keys in the query parameters, like 'json', 'html', etc. So, if the URL has a query parameter like 'format=json', the code will set content_type to 'application/json', which is correct.

But if the URL has a query parameter like 'format=pdf', the code won't set content_type because 'pdf' is not in the params dict's keys. So, the code would miss this case.

Ah, that's a problem. So, the code needs to check the query parameters for any known content types, not just the specific keys.

So, perhaps the code should check if any of the query parameters are known content type indicators.

For example, if the query has a parameter 'format' with a value of 'json', 'html', etc., the function should set the content_type accordingly.

So, the code should iterate through all the query parameters and check if any of them are known content type indicators.

So, in the code, instead of checking for specific keys, it should check if any of the parameter values match known content types.

So, the code should be modified as follows:

if query:
    params = urllib.parse.parse_qs(query)
    for key, value in params.items():
        if value.lower() in {'json', 'html', 'txt'}:
            content_type = None
            if key.lower() == 'json':
                content_type = 'application/json'
            elif key.lower() == 'html':
                content_type = 'text/html'
            elif key.lower() == 'txt':
                content_type = 'text/plain'
            # Add more checks as needed
            break

Wait, but this approach may not be accurate because the query parameter could be something else, like 'format=json', where the key is 'format' and the value is 'json'.

So, the code should check if any of the parameter values is a known content type.

So, perhaps:

known_content_types = {
    'json', 'html', 'txt', 'application/json', 'text/html', 'text/plain'
}

if query:
    params = urllib.parse.parse_qs(query)
    for key, values in params.items():
        for value in values:
            value = value.lower()
            if value in known_content_types:
                if value == 'json':
                    content_type = 'application/json'
                elif value == 'html':
                    content_type = 'text/html'
                elif value == 'txt':
                    content_type = 'text/plain'
                elif value == 'application/json':
                    content_type = value
                elif value == 'text/html':
                    content_type = value
                elif value == 'text/plain':
                    content_type = value
                break
        if content_type is not None:
            break

This way, it checks all possible values in the query parameters and sets the content_type if any of them match known content types.

But this could be error-prone because a query parameter value could be similar to a content type, but it's probably acceptable for this use case.

So, incorporating this into the code:

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters for known content types
    if query:
        params = urllib.parse.parse_qs(query)
        for key, values in params.items():
            for value in values:
                value = value.lower()
                if value in {'json', 'html', 'txt', 'application/json', 'text/html', 'text/plain'}:
                    if value == 'json':
                        content_type = 'application/json'
                    elif value == 'html':
                        content_type = 'text/html'
                    elif value == 'txt':
                        content_type = 'text/plain'
                    elif value == 'application/json':
                        content_type = value
                    elif value == 'text/html':
                        content_type = value
                    elif value == 'text/plain':
                        content_type = value
                    break
            if content_type is not None:
                break

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # If still not determined, return None
    return content_type

This way, the function first checks the query parameters for any known content types, then the path's extension, and if nothing is found, returns None.

So, for a URL like 'http://example.com?format=json', the function would detect 'json' in the query parameters and set content_type to 'application/json'.

For a URL like 'http://example.com?param=log', since 'log' is not a known content type, it would not set content_type from the query. Then, it would check the path, which may not have an extension, so it would return None.

This should cover more cases.

Another consideration is handling encoded query parameters, like 'key=encoded_value'. But urllib.parse.parse_qs can handle that correctly.

So, the final code incorporates this logic.
