Okay, so I need to write a Python function called string_to_int that takes a string and an alphabet list and converts the string into an integer based on the given alphabet. Hmm, let's think about how to approach this.

First, I should understand what the function is supposed to do. The docstring says it converts a string to a number using the given alphabet. So, each character in the string corresponds to a position in the alphabet, and the function probably calculates a number where each character represents a digit in a base equal to the length of the alphabet.

Wait, but how exactly? Let me think. For example, if the alphabet is ['a', 'b', 'c'], then 'a' is 0, 'b' is 1, 'c' is 2. So the string 'ab' would be 0 * 3^1 + 1 * 3^0 = 1. Or maybe it's 0*3^0 + 1*3^1? Wait, no, that would be 3. Wait, I'm a bit confused about the order.

Wait, in the example I thought of earlier, 'ab' would be 'a' followed by 'b', so the leftmost character is the higher digit. So 'a' is the first character, which is the most significant digit. So 'a' would be 0, 'b' is 1. So 'ab' would be 0*3^1 + 1*3^0 = 1. But sometimes, in numbering systems, the rightmost is the least significant digit. So maybe the function is treating the string as a number where each character is a digit, with the leftmost being the highest place value.

So, for the string 'abc', each character is a digit in base len(alphabet). So the value is a*(base^2) + b*(base^1) + c*(base^0). Wait, but in the example I had, 'ab' would be a*3^1 + b*3^0 = 0*3 +1=1. So that seems correct.

So the steps are:

1. Determine the base, which is the length of the alphabet.
2. For each character in the string, find its index in the alphabet. If the character is not found, maybe it's an error. But the function's parameter says the string consists of letters in the alphabet, so we don't have to handle that.
3. Starting from the left, each character's index is multiplied by base^power, where the power starts at (length of string -1) and decreases by 1 each step.

Wait, let me clarify. For the string 'abc', the first character 'a' is at position 0, but in the number, it's the highest place. So for a string of length n, the first character is multiplied by base^(n-1), the next by base^(n-2), and so on, until the last character is multiplied by base^0.

So for 'ab', which is length 2, 'a' is multiplied by base^1, 'b' by base^0.

So, the algorithm would be:

- base = len(alphabet)
- Initialize result to 0
- For each index, char in enumerate(string):
   - result = result * base + alphabet.index(char)
- Return result

Wait, that's a common way to compute numbers from strings in a given base. For example, for '123' in base 10, you start with 0, then 0*10 +1=1, then 1*10 +2=12, then 12*10 +3=123.

Yes, that makes sense. So the function can be implemented by iterating over each character, and for each, updating the result as result = result * base + index.

So the code would look something like:

def string_to_int(string: str, alphabet: List[str]) -> int:
    base = len(alphabet)
    result = 0
    for char in string:
        index = alphabet.index(char)
        result = result * base + index
    return result

But wait, what if the alphabet has duplicate characters? Oh, but the function's parameter says the string consists of letters in the alphabet, but it doesn't specify that the alphabet is unique. So if the alphabet has duplicates, index will return the first occurrence, which might not be intended. But since the function's docstring says the string consists of letters in the alphabet, perhaps the alphabet is a permutation of the possible letters, so it's unique. So I'll proceed under that assumption.

Now, considering unit tests. Since the user mentioned to follow a test-driven development approach, I should think about what test cases to write.

Test case 1: Empty string. Wait, but the function expects a string, which can be empty. What should it return? Hmm, 0, because an empty string represents zero. Or maybe it's undefined, but in the code, it would return 0.

Test case 2: Single character. For example, string 'a', alphabet ['a'], should return 0.

Test case 3: String longer than 1, with varying characters.

Wait, let me think of some examples.

Example 1:
alphabet = ['a', 'b', 'c']
string = 'a'
result should be 0.

Example 2:
alphabet = ['a', 'b', 'c']
string = 'b'
result should be 1.

Example 3:
alphabet = ['a', 'b', 'c']
string = 'c'
result should be 2.

Example 4:
string = 'ab', alphabet same as above. Then result is 0*3 +1=1.

Example 5:
string = 'ba', same alphabet. 'b' is 1, 'a' is 0. So 1*3 +0=3.

Example 6:
string = 'abc', same alphabet. 'a' is 0, 'b' is 1, 'c' is 2. So 0*9 +1*3 +2= 5.

Wait, no. Wait, base is 3, so 'abc' is 0*3^2 +1*3^1 +2*3^0 = 0 +3 +2=5.

Yes.

So the code should handle these cases correctly.

Another test case: when the alphabet is longer. For example, alphabet = ['a', 'b', 'c', 'd'], string = 'ac', which would be 0*4 +2=2.

So, the code should correctly compute these.

Now, what about when the alphabet is not in order? For example, alphabet = ['c', 'b', 'a'], string = 'c'. Then the index of 'c' is 0, so result is 0. If string is 'b', index is 1, so result is 1. String 'a' is index 2, result is 2. So the base is 3, but the order is reversed. So 'c' is 0, 'b' is 1, 'a' is 2. So the string 'cba' would be 0*9 +1*3 +2= 5.

Wait, no. Let's compute 'cba' with alphabet ['c','b','a'].

Each character:

'c' is index 0.

'b' is index 1.

'a' is index 2.

So the string 'cba' is processed as:

result starts at 0.

First character 'c': 0 *3 +0=0.

Second character 'b': 0 *3 +1=1.

Third character 'a': 1 *3 +2=5.

Yes, so the result is 5.

So the code handles any order of the alphabet.

Another test case: what if the alphabet has more than 26 letters? It shouldn't matter; the code just uses the index.

What about non-alphabetic characters? The function's parameter says the string consists of letters in the alphabet, so it's up to the caller to ensure that.

So, the code seems solid.

I think that's the approach. Now, writing the code accordingly.
