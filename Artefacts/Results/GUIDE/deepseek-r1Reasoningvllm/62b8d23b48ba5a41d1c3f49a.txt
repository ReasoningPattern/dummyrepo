Okay, I need to generate Python code for the mru_cache decorator based on the given function signature and docstring. The user mentioned using a test-driven approach, so I should start by thinking about how to structure unit tests before writing the actual code.

First, I'll outline what the mru_cache decorator does. It's a memoization decorator that uses the MRU algorithm, keeping the most recently used items up to a specified maxsize. Unlike the standard lru_cache, which evicts the least recently used item, MRU evicts the oldest item when adding a new one beyond maxsize.

I should consider the parameters: maxsize defaults to 128, and typed is False. The function is a decorator, so it should wrap another function. The memoized version should return the cached result or compute it if not present.

I'll think about the test cases. Each test should check different aspects: basic functionality, maxsize handling, typed caching, and immutability of the cache. I'll write tests using pytest, which is a popular testing framework in Python.

For the test function, I'll need to import the mru_cache decorator and the necessary modules like unittest.mock for mocking. I'll create a simple function, say square, to serve as the target for caching. Then, I'll create an mru_cache instance with maxsize=2 and see if it caches correctly.

In the test, I'll call square with different arguments and check the number of calls. The first two calls should be actual computations, and subsequent calls should return cached results. I'll also ensure that the cache doesn't grow beyond maxsize by making more calls and checking that some old results are evicted.

Next, I'll test the typed parameter. By setting typed=True, the decorator should memoize based on the types of the arguments, not their identities. I'll create a function with different types and see if it's cached correctly.

Another test is to ensure that the cache doesn't grow indefinitely if maxsize is exceeded. I'll call the function more times than maxsize and check that the number of unique keys in the cache doesn't exceed the maxsize.

Finally, I'll test that the underlying function remains immutable after caching. This ensures that once cached, the function can't be modified, which is a key aspect of memoization.

Putting it all together, I'll structure the code with the mru_cache function, followed by the test function, and then the pytest main call. I'll make sure each test is comprehensive and covers different scenarios to validate the decorator's behavior.
