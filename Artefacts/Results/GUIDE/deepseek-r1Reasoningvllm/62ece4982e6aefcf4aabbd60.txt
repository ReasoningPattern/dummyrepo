Okay, I need to write a Python function called size_to_bytes that converts a human-readable file size string into bytes. The function takes a string argument 'size' and returns an integer. The examples given are like '500K', and I have to handle various units like K, M, G, etc.

First, I should think about the different units and their corresponding multipliers. I know that in computing, 1 kilobyte is 1024 bytes, 1 megabyte is 1024 kilobytes, and so on. So the units can be K, M, G, T, P, and maybe H for exabytes, though those are less common.

I need to parse the input string to extract the numerical part and the unit. For example, if the input is '500M', the number is 500 and the unit is M. Then, I can use a dictionary to map these units to their multipliers. The keys will be the unit characters, and the values will be the corresponding powers of 1024.

Wait, but what about cases where the unit is lowercase, like 'k' or 'm'? The examples given use uppercase, but maybe the function should handle both? The problem statement says the input is a string, so perhaps it's better to make the function case-insensitive. So I'll convert the input to uppercase first to handle any lowercase inputs.

Next, I'll split the string into the numeric part and the unit. Using the 'split' method makes sense here. For example, '500K' becomes ['500', 'K'], which I can process.

Once I have the number and the unit, I'll look up the multiplier in the dictionary. If the unit isn't found, the function should probably raise an error, maybe a ValueError, indicating an invalid unit.

Then, I'll multiply the number by the appropriate power of 1024 to get the byte value. For example, 500K would be 500 * 1024.

I should also consider edge cases. What if the input is just '100' without any unit? According to the problem statement, the input is a human-readable size, so it should include a unit. But maybe the function should handle it by defaulting to bytes. Hmm, but the problem says the function is to convert to bytes, so perhaps the input will always have a unit. Still, it's better to think about it. Maybe adding a default case where if no unit is found, treat it as bytes. But the problem says the function is given a string representing a human-readable size, so maybe that's not necessary.

Another edge case: the number part could have a decimal, like '1.5K' or '100.5M'. So I need to handle floating-point numbers. The split will separate the number and the unit correctly, and converting the numeric part to a float will handle that.

Now, thinking about unit handling. The units and their corresponding exponents are:
- 'K' or 'k' → 1024^1
- 'M' or 'm' → 1024^2
- 'G' or 'g' → 1024^3
- 'T' or 't' → 1024^4
- 'P' or 'p' → 1024^5
- 'E' or 'e' → 1024^6

So the dictionary will map 'K' to 1024, 'M' to 1024**2, and so on.

I should also handle cases where the unit is not recognized. For example, if the input is '500X', which doesn't exist. The function should raise an error in such cases.

Now, writing the code step by step:

1. Create a dictionary to map units to multipliers.
2. Convert the input size to uppercase.
3. Split the string into number and unit.
4. Extract the numeric value and unit.
5. Check if the unit is valid; if not, raise ValueError.
6. Multiply the numeric value by the corresponding multiplier.
7. Return the result as an integer.

Wait, but what about the precision? For example, 100.5M would be 100.5 * 1024^2. Should I return an integer or a float? The problem says to return an int, so I'll cast the result to an integer, but that might lose precision. Alternatively, perhaps the function should return a float. But the problem specifies int, so I'll proceed with that, but maybe the user expects a more precise calculation. Hmm, perhaps using integer arithmetic is better, but in Python, 100.5 * 1024 is a float, so I need to decide whether to return an int or a float. Since the problem says to return an int, I'll proceed with that, but I'm a bit unsure. Maybe it's better to return a float and then cast to int, but that could lead to truncation. Alternatively, perhaps the function should return a float, but the problem says int. I'll proceed as per the problem's requirement.

Now, writing the test cases. The user suggested using TDD, so I should write comprehensive tests before writing the code.

Test cases should cover various units, different number formats, including decimals, and invalid units.

For example:
- '500K' → 500 * 1024 = 524800
- '1.5M' → 1.5 * 1024^2 = 1.5 * 1048576 = 1572864
- '10G' → 10 * 1024^3 = 10 * 1073741824 = 10737418240
- '0.5T' → 0.5 * 1024^4 = 0.5 * 1099511627776 = 549755813888
- '1000' → 1000 bytes (but according to the problem, the input should have a unit, but maybe the function should handle it as 1000 * 1024^0 = 1000)
Wait, but the problem says the input is a human-readable size, so perhaps the function expects a unit. But to be safe, maybe the function should handle it.

Another test case: '100' → 100 bytes.

But wait, that's a bit conflicting. The problem says the input is a string representing a human-readable file size, which usually includes units. So perhaps the function can assume that the input has a unit. But to make it robust, handling without a unit is better.

But in the function, if the unit is not found, it should raise an error. So in the test case, '100' would raise ValueError.

So, the test cases should include:

- Valid units: K, M, G, T, P, E
- Invalid units: B, Z, etc.
- Decimal numbers: 1.5K, 0.5M
- Zero: '0K' → 0
- Large numbers: '1000G' → 1000 * 1024^3

Now, writing the code.

First, the dictionary:

unit_map = {
    'K': 1024**1,
    'M': 1024**2,
    'G': 1024**3,
    'T': 1024**4,
    'P': 1024**5,
    'E': 1024**6,
}

Wait, but in Python, 1024**1 is 1024, which is correct.

Then, the function:

def size_to_bytes(size: str) -> int:
    unit_map = {
        'K': 1024,
        'M': 1024**2,
        'G': 1024**3,
        'T': 1024**4,
        'P': 1024**5,
        'E': 1024**6,
    }
    # Convert to uppercase to handle lowercase inputs
    size_upper = size.upper()
    # Split into number and unit
    parts = size_upper.split()
    if len(parts) != 2:
        raise ValueError("Invalid size format")
    number_str, unit = parts
    # Try converting number to float
    try:
        number = float(number_str)
    except ValueError:
        raise ValueError("Invalid number in size string")
    # Check if unit is valid
    if unit not in unit_map:
        raise ValueError(f"Invalid unit '{unit}'")
    # Calculate bytes
    bytes_size = number * unit_map[unit]
    # Return as integer
    return int(bytes_size)

Wait, but the problem says to return an int, so this should be fine. However, if the number is a float, multiplying by 1024^x could result in a float, so converting to int truncates it. For example, 100.5K becomes 100.5 * 1024 = 102912.0, which is fine, but if it's 100.1K, it becomes 1024 * 100.1 = 102502.4, which when cast to int becomes 102502. That's acceptable, but perhaps the function should return a float. However, the problem specifies int, so I'll proceed.

Testing this function with '500K' should return 524800. Let's see: 500 * 1024 = 524800. Correct.

Another test case: '1.5M' → 1.5 * 1024^2 = 1.5 * 1048576 = 1572864. Correct.

What about '10G'? 10 * 1024^3 = 10 * 1073741824 = 10737418240. Correct.

Now, handling invalid units: '100X' should raise ValueError.

What about '1000' → parts would be ['1000'], len(parts) is 1, so ValueError is raised.

Another test case: '0K' → 0 * 1024 = 0 → returns 0.

What about '1024K'? 1024 * 1024 = 1048576.

Wait, but in the function, the number is a float, so 1024.0 is allowed.

Another edge case: '0.5M' → 0.5 * 1024^2 = 524288. Correct.

So, the function should handle all these cases.

Now, the test cases should be written to cover all these scenarios. But since the user suggested using TDD, perhaps they want the code to be written with tests in mind, but in this case, the code is written after considering the tests.

So, the final code is as above.
