Okay, I need to write a Python function called replace_dots that replaces all occurrences of '.' in a string with a given argument. Let me think about how to approach this.

First, I should understand the problem. The function takes two arguments: value, which is the original string, and arg, which is the string to replace each '.' with. The function should return a new string where every '.' in value is replaced by arg.

I remember that in Python, strings have a replace method. So maybe I can use that. The string method is str.replace(old, new), which replaces all occurrences of old with new. That seems perfect here.

So the plan is to use the replace method on the value string, replacing each '.' with arg. That should handle all cases, including when arg is more than one character. For example, if arg is 'x', it replaces '.' with 'x', if arg is 'xy', it replaces each '.' with 'xy', and so on.

Wait, but what if the value is None? Oh, the function signature says value is the old string, so I assume it's a string. But maybe I should handle cases where value is not a string. Hmm, the problem statement doesn't specify, so perhaps I can assume that value is always a string.

Next, I should think about unit tests. Since the problem suggests using a test-driven approach, I should write tests before writing the code. Let me think of different test cases.

Test case 1: Replace '.' with 'a'. Input is 'hi.world', expected output is 'hiawa'.

Test case 2: Replace '.' with nothing, which effectively removes them. Input is 'test..ing', output should be 'testing'.

Test case 3: Replace '.' with a multi-character string, like 'xy'. Input is 'a.b.c', output is 'axybxy c' (wait, no, the third part would be 'c' but the input is 'a.b.c', so replacing each '.' with 'xy' would give 'axybxyxy c'? Wait, no, the input 'a.b.c' has two '.'s, so it would become 'axybxyxy c'? Wait, no, 'a.b.c' has two '.'s, so replacing each with 'xy' would result in 'axybxyxy c'? Wait, no, the input is 'a.b.c', so after replacement, it's 'a' + 'xy' + 'b' + 'xy' + 'c' which is 'axybxy c'?

Wait, no, the input 'a.b.c' is 'a', '.', 'b', '.', 'c', so replacing each '.' with 'xy' would result in 'a' + 'xy' + 'b' + 'xy' + 'c' which is 'axybxy c'?

Wait, no, 'a.b.c' is a string where the first '.' is between a and b, and the second is between b and c. So replacing each with 'xy' would give 'a' + 'xy' + 'b' + 'xy' + 'c' which is 'axybxy c'.

Another test case: Replace '.' with a longer string, like 'xyz'. Input is 'hello.world', output should be 'helloxyzworld'.

What about edge cases? Like when the string is empty. If value is an empty string, replacing '.' with anything should still return an empty string.

Another case: value is None. But the function expects a string, so maybe we can assume value is always a string. But perhaps we should handle it, but the problem doesn't specify, so maybe it's safe to proceed.

So, considering all this, the function can be written as:

def replace_dots(value, arg):
    return value.replace('.', arg)

Wait, that's it? It's that simple? Because the replace method does exactly that. So the function is just returning the replace of '.' with arg in value.

But wait, what if arg is an empty string? Then replacing '.' with '' would remove them, which is correct.

Yes, that should handle all cases.

Now, writing the unit tests. Let's see.

Test case 1: value = 'hi.world', arg = 'a' → expected 'hiawa'.

Test case 2: value = 'test..ing', arg = '' → expected 'testing'.

Test case 3: value = 'a.b.c', arg = 'xy' → expected 'axybxy c'.

Test case 4: value = '', arg = 'xyz' → expected ''.

Test case 5: value = '...', arg = 'a' → expected 'aaa'.

These tests should cover various scenarios.

So the code is straightforward. The function uses the built-in replace method, which is efficient and handles all cases.
