Okay, I need to write a Python function called subclasses that returns all subclasses of a given class, including those from inheritance and recursion. The user mentioned using test-driven development, so I should think about how to approach this.

First, I'll consider what the function needs to do. For any given class, it should list all its direct and indirect subclasses. For example, if the input is a base class, it should go through each of its subclasses, and for each of those, check if they have more subclasses, and so on.

I should start by writing some unit tests to cover different scenarios. Test cases should include:

1. A class with no subclasses.
2. A class with one direct subclass.
3. A class with multiple direct subclasses.
4. A class with a subclass that has its own subclasses.
5. Edge cases like built-in types (though in Python, types like int are not classes, so maybe not applicable here).
6. A class that doesn't have any subclasses.

Wait, but in Python, types like int, str, etc., are not user-defined classes, so the function might not need to handle them. However, if a user passes such a type, it should probably return an empty list since they don't have subclasses.

Now, thinking about how to implement this. The function needs to traverse the class hierarchy. I can use the inspect module, specifically inspect.getsubclasses(). This function returns all the subclasses of a given class, including those from inheritance and recursion.

But I should handle cases where the class doesn't exist or isn't a class. So, first, I'll check if the input is a class. If not, maybe return an empty list or raise an error. The docstring says "cls" is the class, so I assume it's a valid class.

Putting it together, the function can be as simple as returning inspect.getsubclasses(cls). But wait, what about the case where the class is a built-in type? For example, if someone passes int, inspect.getsubclasses(int) would return all int's subclasses, but in Python, int is a built-in type and doesn't have subclasses in the same way as user-defined classes. So perhaps the function should handle that by checking if the class is an instance of type. If it is, maybe it's a built-in class, and we should return an empty list or something. Alternatively, we can let it return whatever inspect.getsubclasses() returns, but that might include things we don't want.

Hmm, perhaps the function should first check if the class is a user-defined class. So, if isinstance(cls, type) and not isinstance(cls, (Class, type))... Wait, no, that's not correct. Built-in classes are instances of type. So, maybe the function should check if the class is a type and not a built-in type. But how? Alternatively, we can proceed and let the inspect module handle it, but perhaps in practice, it's better to filter out any non-class objects.

Wait, the inspect.getsubclasses() function is designed to work with user-defined classes. If you pass a built-in type, it might not behave as expected. So, perhaps the function should handle that by checking if the class is an instance of type and then return an empty list if it's a built-in type.

Alternatively, perhaps it's better to proceed and let inspect handle it, but I'm not sure. Maybe it's safer to proceed and see.

So, the function can be written as:

import inspect

def subclasses(cls):
    return inspect.getsubclasses(cls)

But wait, let's test this with some examples.

Test case 1: cls = object. What does inspect.getsubclasses() return? It returns an empty list because object is the base class and doesn't have any subclasses.

Test case 2: cls = list. The function should return all subclasses of list, which includes dict, set, etc. So, inspect.getsubclasses(list) should return a list of these.

Test case 3: cls = a user-defined class with multiple subclasses. It should return all of them recursively.

But wait, what about if the class is not a class? For example, if someone passes a function or an integer. In that case, inspect.getsubclasses() will raise an AttributeError. So, perhaps the function should handle that by checking if the input is a class. So, the function should first check if the input is a class, and if not, return an empty list.

So, adding a check:

import inspect

def subclasses(cls):
    if not isinstance(cls, type) or inspect.isbuiltin(cls):
        return []
    return inspect.getsubclasses(cls)

Wait, inspect.isbuiltin(cls) returns True if the class is a built-in class. So, if the user passes a built-in type, it returns an empty list.

Alternatively, perhaps the function should just return the subclasses regardless, but I think it's better to handle cases where the input is not a class or is a built-in type.

So, putting it all together, the function should first check if the input is a class (type) and not a built-in type. If not, return an empty list. Otherwise, return all its subclasses.

So, the code would be:

import inspect

def subclasses(cls):
    if not isinstance(cls, type) or inspect.isbuiltin(cls):
        return []
    return inspect.getsubclasses(cls)

Wait, but inspect.isbuiltin(cls) returns True for built-in types. So, the condition correctly skips them.

Testing this function:

Case 1: cls = object → returns empty list.

Case 2: cls = list → returns all subclasses of list.

Case 3: cls = a user-defined class with multiple subclasses → returns all recursively.

Case 4: cls = int → returns empty list because int is a built-in type.

Case 5: cls = a class without any subclasses → returns empty list.

This should handle all the cases. Now, writing the code with this logic.
