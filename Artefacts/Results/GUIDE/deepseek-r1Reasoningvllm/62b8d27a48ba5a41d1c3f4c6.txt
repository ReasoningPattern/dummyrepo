Okay, so I need to write a Python function called 'cached' that acts as a decorator. The function has a specific signature and docstring, and I should follow a test-driven development approach. Hmm, let me think about how to approach this.

First, I remember that decorators in Python are functions that take another function as an argument and return a new function. So, the 'cached' function is a decorator factory because it returns a decorator. That makes sense.

The function signature is def cached(cache, key=hashkey, lock=None):. So, it's going to take a cache, a key function, and an optional lock. The key function is used to generate a key for storing the result in the cache, and the lock is for thread safety, I suppose.

The docstring says that the decorator saves results in the cache. So, I need to implement this caching mechanism. Let me outline the steps.

First, I'll need to create a decorator that wraps the target function. Inside the decorator, I'll check if the result is already in the cache. If it is, return it immediately. If not, execute the function, store the result in the cache using the key, and then return the result.

Wait, but how do I handle the lock? Oh right, if a lock is provided, I should atomically check and set the result in the cache. Without a lock, it's just a normal check.

I should also make sure that the cache is a dictionary or some kind of mapping object. The key function will generate a key for each function's result, so I'll use that to look up in the cache.

Now, considering unit tests, I should write tests to verify that the caching works correctly. For example, test that calling the function twice with the same arguments returns the cached value. Also, test that the function is called only once per unique key. Additionally, test thread safety if the lock is provided, but that might be more complex.

Wait, the user mentioned following a test-driven approach, so I should start by writing tests before writing the code. But since I'm supposed to generate the code, maybe I can outline the tests in my mind.

I'll need to write a class or a module where I can test the cached decorator. Maybe create a Cache class that implements the necessary methods like get, set, and has. That way, I can mock the cache in my tests.

Wait, but the user wants the code generated, so perhaps I should structure the code to include the tests as well. Or maybe the tests are part of the same module. Hmm, but the user's initial question is just about generating the code for the 'cached' function, so perhaps the tests are part of the code I'll produce.

Wait, no, the user said to output only the code in Python markdown format. So, I think the code should include the 'cached' function along with any necessary helper functions and tests.

But wait, the initial response I saw included a Cache class, a default key function, and the cached decorator. So, perhaps the code should include all that.

Let me outline the structure:

1. Define the Cache class with methods to handle caching: get, set, has, delete.
2. Define a default key function that uses hash of the arguments.
3. Implement the cached decorator that uses the cache, key function, and lock.
4. Write tests to ensure that the decorator works as expected.

So, in the code, I'll start by defining the Cache class. It should be thread-safe, so using a threading.Lock makes sense. The get method will atomically retrieve the value, set will store it, has will check existence, and delete will remove it.

Next, the default key function uses the hash of the arguments. I'll use functools.cmp_to_key if needed, but wait, no, because hashkey is a function that takes a tuple of arguments and returns a hashable key. So, I can just call key(*args) to get the key.

Then, the cached decorator. It will take the cache, key function, and lock. The decorator will wrap the target function, and before calling it, it will check if the result is in the cache. If not, it will call the function, store the result, and then return it.

Wait, but the decorator returned by cached should handle the caching. So, the decorator function will take the target function as an argument and return a wrapped function.

So, putting it all together, the code will have:

- Cache class with lock and methods.
- Key function.
- Cached decorator that uses the cache, key, and lock.
- Tests to verify that the decorator works correctly.

Now, considering the tests, I should write tests that:

- Check that the same arguments return the same result.
- Ensure that the function is called only once per unique key.
- Test that the cache is thread-safe when a lock is provided.

I'll need to use pytest for testing, so I'll include that as a dependency.

Wait, but in the initial code, the tests are written as @pytest.mark.parametrize, etc. So, I think the code should include the necessary test cases.

Putting it all together, the code will have the Cache class, the key function, the cached decorator, and the tests.

I think that's the plan. Now, I'll write the code accordingly, making sure to include all the necessary parts and handle edge cases, like when the cache is None or when the key function returns None.
