def lru_cache(maxsize=128, typed=False):
    """
    Decorator to wrap a function with a memoizing callable that saves
    up to `maxsize` results based on a Least Recently Used (LRU)
    algorithm.
    """
    from functools import lru_cache

    def decorator(func):
        cache = {}
        call_order = []

        def wrapper(*args, **kwargs):
            # Generate the key based on the arguments
            args_tuple = tuple(args)
            kwargs_tuple = tuple(kwargs.items())
            key = (args_tuple, kwargs_tuple)

            # Check if the key is in the cache
            if key in cache:
                return cache[key]

            # Compute the result
            result = func(*args, **kwargs)
            cache[key] = result
            call_order.append(key)

            # Evict the least recently used item if the cache is full
            if len(cache) > maxsize:
                evict_key = call_order.pop(0)
                del cache[evict_key]

            return result

        return wrapper

    return decorator