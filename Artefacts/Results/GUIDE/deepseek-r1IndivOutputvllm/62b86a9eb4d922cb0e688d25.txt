

To solve this problem, we need to create a function that returns regular expressions used to validate resource names for Kraken, a cryptocurrency exchange. The function should return different regex patterns for different types of resources.

### Approach
1. **Understand Resource Names**: Kraken resources likely include:
   - Wallet addresses
   - Transaction addresses
   - Possibly mnemonic phrases (for cold wallets)
   - Other alphanumeric strings

2. **Regex Patterns**:
   - **Wallet Address Regex**: Matches typical wallet addresses which start with a letter, contain letters and numbers, and have a specific length.
   - **Mnemonic Phrase Regex**: Matches phrases consisting of lowercase words with specific length constraints.
   - **General Alphanumeric Regex**: Matches any string containing only alphanumeric characters.

3. **Unit Testing**: 
   - Write test cases for each regex pattern to ensure they correctly match valid strings and reject invalid ones.
   - Test cases include valid examples, edge cases, and invalid examples for each regex.

### Solution Code

```python
import re

def _get_resource_name_regex():
    """
    Return the regular expressions that are used to validate the name of the Krake resources
    """
    # Regex patterns for resource name validation
    address_regex = re.compile(
        r'^[A-Za-z0-9]{32}$',  # 32 character alphanumeric string
        re.IGNORECASE
    )
    
    mnemonic_regex = re.compile(
        r'^[a-ix-z0-9]{3,44}$',  # 3-44 character alphanumeric string
        re.IGNORECASE
    )
    
    alphanumeric_regex = re.compile(
        r'^[a-zA-Z0-9]{1,}',  # Any length alphanumeric string
        re.IGNORECASE
    )
    
    return (
        (address_regex, "Wallet Address Regex"),
        (mnemonic_regex, "Mnemonic Phrase Regex"),
        (alphanumeric_regex, "General Alphanumeric Regex")
    )

def does_match(pattern, text):
    """
    Helper function to test if a string matches a regex pattern.
    """
    return bool(pattern.match(text))

def test_resource_name_regex():
    """
    Unit tests for resource name regex patterns.
    """
    # Test cases for address regex
    address_valid = does_match(address_regex, "ABC1234567890XYZABCDEF12345")
    address_invalid = does_match(address_regex, "@$%^&*()_+{}|;:")
    assert address_valid, "Address regex did not match valid address string"
    assert not address_invalid, "Address regex incorrectly matched invalid string"
    
    # Test cases for mnemonic regex
    mnemonic_valid = does_match(mnemonic_regex, "a bcdefghijklmnopqrstuvwxyz12345678")
    mnemonic_invalid = does_match(mnemonic_regex, "1234567890123456789012345678901234567890")
    assert mnemonic_valid, "Mnemonic regex did not match valid mnemonic string"
    assert not mnemonic_invalid, "Mnemonic regex incorrectly matched invalid string"
    
    # Test cases for alphanumeric regex
    alphanumeric_valid = does_match(alphanumeric_regex, "ValidString123")
    alphanumeric_invalid = does_match(alphanumeric_regex, "@$%^&*()_+{}|;")
    assert alphanumeric_valid, "Alphanumeric regex did not match valid alphanumeric string"
    assert not alphanumeric_invalid, "Alphanumeric regex incorrectly matched invalid string"
    
    print("All tests passed!")

# Example usage
if __name__ == "__main__":
    test_resource_name_regex()
```

### Explanation
- **Regex Patterns**:
  - **Wallet Address Regex**: `^[A-Za-z0-9]{32}$` - Matches strings that are exactly 32 characters long, containing only alphanumeric characters, case insensitive.
  - **Mnemonic Phrase Regex**: `^[a-ix-z0-9]{3,44}$` - Matches phrases between 3 to 44 characters long, containing alphanumeric characters and specific allowed letters.
  - **General Alphanumeric Regex**: `^[a-zA-Z0-9]{1,}` - Matches any string that contains at least one alphanumeric character.

- **Testing**:
  - The `does_match` function is a helper to test if a string matches a given regex pattern.
  - The `test_resource_name_regex` function contains comprehensive tests for each regex pattern, ensuring they correctly validate and reject strings based on their expected formats.

This approach ensures that we have robust regular expressions for validating different types of Kraken resource names while providing thorough testing to confirm their correctness.