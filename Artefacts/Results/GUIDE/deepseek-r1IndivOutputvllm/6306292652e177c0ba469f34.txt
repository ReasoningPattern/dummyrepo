

To solve this problem, we need to write a Python function called `fetch_content_type` that determines the appropriate Content-Type header based on the given URL. The function should analyze both the query parameters and the path of the URL to infer the content type. If it can't determine the content type through these means, it should return `None`.

### Approach
1. **Parse the URL**: Use the `urlsplit` function from the `urllib.parse` module to break down the URL into its components (path, query, etc.).
2. **Check Query Parameters**: Extract query parameters and check if any of them correspond to known content types. For example, if a query parameter is 'json', the content type is set to 'application/json'.
3. **Check Path Extension**: If the query parameters don't provide a content type, check the filename extension of the URL path. Known file extensions are mapped to their corresponding MIME types.
4. **Return Content Type**: If a content type is determined through either the query parameters or the path extension, return it. Otherwise, return `None`.

### Solution Code
```python
import urllib.parse

def fetch_content_type(url: str) -> Optional[str]:
    parsed_url = urllib.parse.urlsplit(url)
    path = parsed_url.path
    query = parsed_url.query

    content_type = None

    # Check query parameters for known content types
    if query:
        params = urllib.parse.parse_qs(query)
        for key, values in params.items():
            for value in values:
                value = value.lower()
                if value in {'json', 'html', 'txt', 'application/json', 'text/html', 'text/plain'}:
                    if value == 'json':
                        content_type = 'application/json'
                    elif value == 'html':
                        content_type = 'text/html'
                    elif value == 'txt':
                        content_type = 'text/plain'
                    elif value == 'application/json':
                        content_type = value
                    elif value == 'text/html':
                        content_type = value
                    elif value == 'text/plain':
                        content_type = value
                    break
            if content_type is not None:
                break

    # Check path extension if no query params
    if not content_type and path:
        # Extract filename extension
        filename_ext = None
        path_parts = urllib.parse.urlsplit(path).path.split('/')
        if path_parts:
            filename_ext = path_parts[-1]
        # Define known extensions and their MIME types
        content_type_extensions = {
            '.pdf': 'application/pdf',
            '.png': 'image/png',
            '.jpg': 'image/jpeg',
            '.gif': 'image/gif',
            '.txt': 'text/plain',
            '.log': 'text/plain',
            # Add more extensions as needed
        }
        if filename_ext in content_type_extensions:
            content_type = content_type_extensions[filename_ext]

    # If still not determined, return None
    return content_type
```

### Explanation
1. **Parsing the URL**: The URL is split into its path and query components to separately analyze each part.
2. **Query Parameters**: The function checks if any query parameter matches known content types (like 'json', 'html', etc.) and sets the content type accordingly.
3. **Path Extension Check**: If the query parameters don't provide a content type, the function checks the filename extension of the URL path. Known extensions are mapped to their MIME types, and the corresponding content type is set.
4. **Return**: The function returns the determined content type if found; otherwise, it returns `None`.

This approach ensures that the function can infer the appropriate Content-Type header based on the URL's structure, providing a robust solution for setting HTTP requests through a browser extension.