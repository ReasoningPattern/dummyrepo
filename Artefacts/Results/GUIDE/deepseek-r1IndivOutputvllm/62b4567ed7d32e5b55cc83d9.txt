

To solve this problem, we need to merge a list of nodes such that any duplicate keys are resolved by keeping the last occurrence. If the values associated with these keys are `MappingNode` instances, they should be deeply merged. Otherwise, the last value should be used.

### Approach
1. **Deep Merge Helper Function**: Create a helper function `deep_merge` that takes two `MappingNode` instances and merges them deeply. This function will recursively merge nested `MappingNode` instances.
2. **Merge Nodes Function**: Implement the main function `deep_merge_nodes` that processes each node in the input list. For each node, check if its key already exists in the result dictionary:
   - If the key does not exist, add the node's value directly.
   - If the key exists, check if the current value is a `MappingNode`. If it is, merge the new node into the existing one using `deep_merge`. If not, simply update the existing value with the new node's value.

### Solution Code
```python
class MappingNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value

def deep_merge(a, b):
    if isinstance(a, MappingNode) and isinstance(b, MappingNode):
        return MappingNode(a.key, deep_merge(a.value, b.value))
    elif isinstance(a, MappingNode):
        return MappingNode(a.key, deep_merge(a.value, b))
    elif isinstance(b, MappingNode):
        return MappingNode(b.key, deep_merge(a, b.value))
    else:
        return b

def deep_merge_nodes(nodes):
    """
    Merge any node values corresponding to duplicate keys and return the result.
    If there are colliding keys with non-MappingNode values, the last of the values remains.
    """
    merged = {}
    for node in nodes:
        key = node.key
        value = node.value
        if key in merged:
            if isinstance(merged[key], MappingNode):
                merged[key] = deep_merge(merged[key], value)
            else:
                merged[key] = value
        else:
            merged[key] = value
    return merged
```

### Explanation
1. **MappingNode Class**: This class represents a node with a key and a value, which can be another `MappingNode` or a primitive value.
2. **deep_merge Function**: This function recursively merges two `MappingNode` instances. If both are `MappingNode`, it merges their values deeply. If one is a `MappingNode` and the other is not, it merges the `MappingNode` into the other value.
3. **deep_merge_nodes Function**: This function processes each node in the input list. It uses a dictionary to accumulate merged nodes, resolving duplicates by either deep merging or taking the last value, depending on the type of the existing value.

This approach ensures that all duplicate keys are resolved correctly, handling both nested and non-nested values appropriately.