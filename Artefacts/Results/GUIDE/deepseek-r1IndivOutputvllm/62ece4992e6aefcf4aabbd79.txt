

To solve this problem, we need to create a function `make_find_paths` that transforms a given list of paths into glob patterns. The function should leave existing glob patterns unchanged while converting any non-glob patterns into valid glob patterns.

### Approach
The approach involves the following steps:
1. **Check if a Path is a Glob Pattern**: Use the `glob` module to determine if a given path is a valid glob pattern. This is done by attempting to parse the path using `glob.parse`. If it raises a `GlobError`, the path is not a valid glob pattern.
2. **Transform Non-Glob Paths**: If a path is not a valid glob pattern, it is transformed into a glob pattern by appending a '*' at the end. This ensures that the path conforms to the glob pattern syntax, which typically uses '*' to match any sequence of characters.

### Solution Code
```python
import glob
import os
from six import text_type

def make_find_paths(find_paths):
    def is_glob(path):
        try:
            glob.parse(path)
            return True
        except glob.GlobError:
            return False

    transformed = []
    for path in find_paths:
        if is_glob(path):
            transformed.append(path)
        else:
            transformed.append(text_type(path) + '*')
    return tuple(transformed)
```

### Explanation
- **Checking Glob Patterns**: The helper function `is_glob` uses `glob.parse` to check if a path is a valid glob pattern. If parsing succeeds, the path is considered a glob pattern and is added to the result as is.
- **Transforming Paths**: For paths that are not valid glob patterns, the function appends a '*' to the end of the path. This ensures that all paths are transformed into valid glob patterns, which can then be used for searching across directories and files.

This approach ensures that existing glob patterns are left unchanged while converting any non-glob patterns into valid glob patterns, thus meeting the problem requirements efficiently.