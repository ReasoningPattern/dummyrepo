

To solve this problem, we need to create a decorator function `cached` that saves the results of a function call in a cache. The cache should be thread-safe and use a provided key function to determine the storage key. We'll follow a test-driven development approach to ensure the correctness of our implementation.

### Approach
1. **Define a Cache Class**: This class will handle storing and retrieving results using a provided lock for thread safety.
2. **Default Key Function**: This function will generate a hashable key from the function's arguments.
3. **Cached Decorator**: This decorator will check the cache before calling the target function. If the result is cached, it will return the cached value; otherwise, it will execute the function, store the result, and then return the result.
4. **Unit Tests**: These tests will verify that the caching works correctly, handles unique keys, and is thread-safe when a lock is provided.

### Solution Code

```python
import functools
import threading

class Cache:
    def __init__(self, maxsize=None, lock=None):
        self.maxsize = maxsize
        self.lock = threading.Lock(lock) if lock is not None else None
        self.cache = {}

    def get(self, key):
        if self.lock is not None:
            with self.lock:
                return self.cache.get(key)
        return self.cache.get(key)

    def set(self, key, value):
        if self.lock is not None:
            with self.lock:
                self.cache[key] = value
        else:
            self.cache[key] = value

    def has(self, key):
        if self.lock is not None:
            with self.lock:
                return key in self.cache
        return key in self.cache

    def delete(self, key):
        if self.lock is not None:
            with self.lock:
                if key in self.cache:
                    del self.cache[key]
        else:
            if key in self.cache:
                del self.cache[key]

def hashkey(args):
    return hash(args)

def cached(cache, key=hashkey, lock=None):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            key = key(*args, **kwargs)
            if cache is None:
                return func(*args, **kwargs)
            result = cache.get(key)
            if result is not None:
                return result
            try:
                value = func(*args, **kwargs)
                if cache is not None:
                    cache.set(key, value)
                return value
            except Exception as e:
                if cache is not None:
                    cache.delete(key)
                raise e
        return wrapper
    return decorator

@pytest.mark.parametrize("key, expected", [
    ("sum([1,2,3])", 6),
    ("sum([4,5,6])", 15),
    ("sum([7,8,9])", 24),
])
def test_cache_sum(p, key, expected):
    def sum_list(lst):
        return sum(lst)
    
    cache = Cache(maxsize=1)
    cached(cache, key)(sum_list)("1,2,3")  # Using string representation for key
    assert cache.get(key) == expected

@pytest.mark.parametrize("key, expected", [
    ("len([1,2,3])", 3),
    ("len([4,5,6])", 3),
    ("len([7,8,9])", 3),
])
def test_cache_len(p, key, expected):
    def get_length(lst):
        return len(lst)
    
    cache = Cache(maxsize=1)
    cached(cache, key)(get_length)("1,2,3")
    assert cache.get(key) == expected

def test_lock():
    cache = Cache(maxsize=1, lock=threading.Lock())
    key = "test"
    result1 = None
    result2 = None
    def func():
        nonlocal result1, result2
        result1 = cached(cache, key)(lambda x: x)(key)
        result2 = cached(cache, key)(lambda x: x)(key)
    func()
    assert result1 == result2
    assert result1 is not None
```

### Explanation
1. **Cache Class**: This class manages the cache with thread-safe operations using a lock. It supports setting, getting, checking existence, and deleting keys.
2. **hashkey Function**: Generates a hash key from the function's arguments using the hash function.
3. **cached Decorator**: Takes a cache, key function, and lock. It wraps the target function and checks the cache before executing it. If the result exists, it returns it; otherwise, it executes the function, stores the result, and returns it.
4. **Tests**: The tests ensure that the cache works correctly for different functions and handles thread safety when a lock is provided. They use parameterized tests to verify various scenarios.