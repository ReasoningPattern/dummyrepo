

To solve this problem, we need to create a Python class with a decorator method that registers functions under specific hooks. The decorator will allow us to add handlers to a registry, which can be used to manage side effects or additional functionality associated with specific hook names.

### Approach
The approach involves creating a class with a classmethod `on` that returns a decorator. This decorator will take a function and a hook name as arguments and register the function under the specified hook name in a class-level dictionary. The class-level dictionary, `_HOOKS`, will store the registered functions with their corresponding hook names as keys.

1. **Class Definition**: Define a class with a class-level dictionary `_HOOKS` to store the registered handlers.
2. **Class Method `on`**: Implement a class method `on` that accepts a `hook` parameter. This method will return a decorator function.
3. **Decorator Function**: The decorator function will take a `func` parameter (the function to register) and update the `_HOOKS` dictionary with the function under the specified `hook` name.
4. **Testing**: Use unit tests to ensure that the decorator correctly registers functions under the specified hooks and that multiple handlers can be registered without conflicts.

### Solution Code

```python
class MyClass:
    _HOOKS = {}

    @classmethod
    def on(cls, hook):
        """
        Return a decorator function to add a new handler to the "hook" in the registry in the class.
        """
        def decorator(func):
            cls._HOOKS[hook] = func
            return func
        return decorator

# Test code (to be run separately)
import unittest

class TestHooks(unittest.TestCase):
    def test_on_decorator(self):
        class TestClass:
            _HOOKS = {}

            @classmethod
            def on(cls, hook):
                def decorator(func):
                    cls._HOOKS[hook] = func
                    return func
                return decorator

        test_instance = TestClass()
        test_instance.on('test_hook')(lambda: None)
        self.assertEqual(test_instance._HOOKS['test_hook'], lambda: None)

    def test Multiple Handlers(self):
        class TestClass:
            _HOOKS = {}

            @classmethod
            def on(cls, hook):
                def decorator(func):
                    cls._HOOKS[hook] = func
                    return func
                return decorator

        test_instance = TestClass()
        test_instance.on('hook1')(print)
        self.assertEqual(test_instance._HOOKS['hook1'], print)

        test_instance.on('hook2')(lambda: None)
        self.assertEqual(test_instance._HOOKS['hook2'], lambda: None)

if __name__ == "__main__":
    unittest.main()
```

### Explanation
- **Class Definition**: The `MyClass` class has a class-level dictionary `_HOOKS` which is initialized as an empty dictionary. This dictionary will store the registered functions.
- **Class Method `on`**: The `on` method is a class method that takes a `hook` parameter. It returns a decorator function that will be used to register functions.
- **Decorator Function**: The decorator function takes a `func` parameter and updates the `_HOOKS` dictionary by adding the function under the specified `hook` name. This allows multiple functions to be registered under different hooks.
- **Testing**: The provided test cases ensure that the decorator correctly registers functions and handles multiple handlers without conflicts. The tests check if functions are correctly added to the `_HOOKS` dictionary and if the decorator behaves as expected.

This solution provides a clear and efficient way to manage function registration under specific hooks, which can be useful in various applications such as logging, configuration management, or executing side effects.