

To solve this problem, we need to create a function that returns the list of files contained within a given zip file path. We will follow a test-driven development approach to ensure our solution is robust and handles various edge cases.

### Approach
1. **Test Cases**: 
   - Test with an empty zip path, expecting an empty list.
   - Test with a valid zip file containing multiple files, expecting a list of file names.
   - Test with a non-existent zip path, expecting `None`.

2. **Handling the Zip File**:
   - Use Python's `zipfile` module to open and read the zip file.
   - Extract all entries from the zip file and collect their names.
   - Handle cases where the zip file might be invalid or does not exist by returning `None`.

### Solution Code

```python
import io
import zipfile
from unittest.mock import patch

def files_list_from_zipfile(zip_path):
    """
    Return the files in the given zip path.
    """
    if not zip_path:
        return []
    
    try:
        with io.open(zip_path, 'r') as f:
            with zipfile.ZipFile(f) as z:
                return list(z.namelist())
    except (FileNotFoundError, PermissionError, IsADirectoryError):
        return None
```

### Explanation
1. **Function Definition**: The function `files_list_from_zipfile` takes a single argument `zip_path`, which is the path to the zip file.

2. **Empty Zip Path Handling**: If the `zip_path` is an empty string, the function immediately returns an empty list.

3. **Zip File Operations**:
   - The function attempts to open the zip file using `io.open`, which is a context manager that handles file closing automatically.
   - Using `zipfile.ZipFile`, the contents of the zip file are read and parsed.
   - The `namelist()` method of the `ZipFile` object is used to get a list of all filenames in the archive.

4. **Error Handling**: The function includes a try-except block to catch common exceptions such as `FileNotFoundError`, `PermissionError`, and `IsADirectoryError`. If any of these exceptions occur, the function returns `None`.

This approach ensures that the function handles typical use cases as well as edge cases gracefully, providing a reliable solution for extracting files from a zip archive.