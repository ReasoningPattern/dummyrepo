

To solve this problem, we need to create a function that takes a list of dictionaries and returns a new dictionary where the values with the same keys are summed. This is a common operation when dealing with aggregated data from multiple sources.

### Approach
The approach to solve this problem involves the following steps:
1. **Initialize an empty result dictionary**: This will store the summed values.
2. **Iterate through each dictionary in the input list**: For each dictionary, we will process each key-value pair.
3. **Sum values for the same key**: For each key-value pair, check if the key already exists in the result dictionary. If it does, add the value to the existing value. If it does not, create a new entry with the key and the value.
4. **Return the result dictionary**: After processing all dictionaries, return the result.

This approach ensures that we efficiently sum the values for each key across all dictionaries.

### Solution Code
```python
def _dictsum(dicts):
    """
    Sum values with the same key in the dictionaries and return a new dictionary.
    
    Args:
        dicts (list of dict): A list of dictionaries to be summed.
        
    Returns:
        dict: A dictionary with summed values for each key.
    """
    result = {}
    for d in dicts:
        for key, value in d.items():
            result[key] = result.get(key, 0) + value
    return result

import unittest

class TestDictSum(unittest.TestCase):
    def test_dictsum_single_dict(self):
        dicts = [{'a': 1, 'b': 2}]
        expected = {'a': 1, 'b': 2}
        self.assertEqual(_dictsum(dicts), expected)
    
    def test_dictsum_multiple_dicts(self):
        dicts = [{'a': 1, 'b': 2}, {'a': 5, 'b': 0}]
        expected = {'a': 6, 'b': 2}
        self.assertEqual(_dictsum(dicts), expected)
    
    def test_dictsum_empty_list(self):
        dicts = []
        expected = {}
        self.assertEqual(_dictsum(dicts), expected)
    
    def test_dictsum_non_overlapping_keys(self):
        dicts = [{'a': 3}, {'b': 5}]
        expected = {'a': 3, 'b': 5}
        self.assertEqual(_dictsum(dicts), expected)
    
    def test_dictsum_mixed_values(self):
        dicts = [{'a': 10, 'b': 20}, {'a': 5, 'b': 15}, {'c': 30}]
        expected = {'a': 15, 'b': 35, 'c': 30}
        self.assertEqual(_dictsum(dicts), expected)

if __name__ == "__main__":
    unittest.main()
```

### Explanation
- **Initialization**: We start with an empty dictionary `result` to store our summed values.
- **Iteration through Dictionaries**: For each dictionary in the input list, we iterate through each key-value pair.
- **Summing Values**: For each key, we check if it exists in `result`. If it does, we add the current value to the existing value. If it does not, we create a new entry with the key and the current value.
- **Return Result**: After processing all dictionaries, we return the `result` dictionary containing the summed values.

The provided unit tests cover various scenarios, including single dictionaries, multiple dictionaries with overlapping and non-overlapping keys, empty lists, and dictionaries with mixed values. These tests ensure that our function behaves correctly under different conditions.