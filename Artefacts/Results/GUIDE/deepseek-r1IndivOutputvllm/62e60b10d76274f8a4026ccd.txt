

```python
class RecordExporter:
    def transform(self, keys):
        """
        Processes the given keys and returns them in a standardized format.
        """
        return {key: str(key) for key in keys if isinstance(key, str)}

    def data(self, *keys):
        """
        Returns the keys processed by the transform method of the RecordExporter class.
        """
        return self.transform(keys)

def test_record_exporter():
    """Unit tests for RecordExporter class"""
    exporter = RecordExporter()
    
    # Test with no keys
    assert exporter.data() == {}
    
    # Test with valid keys
    test_keys = ['key1', 'key2']
    result = exporter.data(*test_keys)
    assert result == {k: str(k) for k in test_keys}
    
    # Test with invalid keys (non-strings)
    invalid_keys = [123, None]
    result = exporter.data(*invalid_keys)
    assert result == {}
```

This solution:
1. Creates a `RecordExporter` class with a `transform` method that processes keys
2. Implements the `data` method to interface with the `transform` method
3. Includes unit tests that verify the behavior with valid and invalid inputs
4. Uses test-driven development by first writing tests then implementing the production code

The `transform` method standardizes the keys by converting them to strings and storing them in a dictionary. The `data` method simply delegates to the `transform` method.

To use this code, you would instantiate the `RecordExporter` class and call the `data` method with your keys:

```python
exporter = RecordExporter()
keys = ['key1', 'key2']
result = exporter.data(*keys)
print(result)  # Output: {'key1': 'key1', 'key2': 'key2'}
```