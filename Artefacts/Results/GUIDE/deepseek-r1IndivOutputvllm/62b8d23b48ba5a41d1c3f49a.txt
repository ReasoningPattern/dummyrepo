

```python
import unittest
import inspect
from types import FrameType
from functools import wraps

def mru_cache(maxsize=128, typed=False):
    """
    Decorator to wrap a function with a memoizing callable that saves
    up to `maxsize` results based on a Most Recently Used (MRU)
    algorithm.

    This decorator maintains a cache of the most recently used function
    calls, evicting the least recently used item when the cache exceeds
    `maxsize` size. The cache is based on the arguments of the function
    (typed=True) or its identity (typed=False).

    Args:
        maxsize (int, optional): Maximum size of the cache. Defaults to 128.
        typed (bool, optional): Whether to check the types of arguments
            when looking up cached results. Defaults to False.

    Returns:
        callable: A wrapped version of the decorated function with cached
        results.
    """
    if typed:
        from . import types
        func = types.mru_cache(maxsize, func)
    else:
        func = _mru_cache_base(maxsize, func)
    return func

def _mru_cache_base(maxsize, func):
    cache = {}
    call_count = 0

    @wraps(func)
    def wrapper(*args, **kwargs):
        nonlocal call_count
        call_count += 1

        # Check if the arguments are already in the cache
        key = _get_memo_key(args, kwargs, typed=func is None)
        if key in cache:
            return cache[key]
        else:
            # Compute the result
            result = func(*args, **kwargs)
            cache[key] = result
            return result

    # Get the number of unique calls without counting duplicates
    def _unique_key(item):
        return item[0]

    # Evict the MRU item if the cache exceeds maxsize
    while len(cache) > maxsize:
        # Get the oldest item by using the index as a timestamp
        oldest = min(cache.items(), key=lambda x: _unique_key(x[1]))
        del cache[oldest[0]]
    
    return wrapper

def _get_memo_key(args, kwargs, typed):
    """
    Generates a key for memoization based on the arguments of the function
    call. If `typed` is True, the type of each argument is used in the key.
    Otherwise, the actual values are used.
    """
    if typed:
        key = tuple(
            inspect.gettype(args[i]) if args else type(None)
            for i in range(len(args))
        ) + tuple(
            inspect.gettype(kwargs[key]) if kwargs else type(None)
            for key in kwargs
        )
    else:
        key = args + tuple(kwargs.values())
    return key

def test_mru_cache():
    """
    Test the mru_cache decorator with various scenarios.
    """
    # Basic MRU cache functionality
    def square(x):
        return x ** 2

    @mru_cache(maxsize=2)
    def target(x):
        return square(x)

    # Verify that the cache works correctly
    target.cache_clear()
    assert target.cache_info() == (2, 1, 1, 1)
    
    # Test MRU behavior
    target.cache_clear()
    for i in range(5):
        assert target.cache_info().maxsize == 2
        target(i)
    assert len(target.cache) == 2
    
    # Verify that after exceeding maxsize, the least recently used is evicted
    target.cache_clear()
    for _ in range(10):
        target(1)
    assert len(target.cache) == 2
    
    # Check typed caching
    def target2(x, y=0):
        return (x, y)
    
    @mru_cache(maxsize=2, typed=True)
    def target2(x, y=0):
        return (x, y)
    
    target2.cache_clear()
    # Check that different types are considered different keys
    assert target2.cache_info().maxsize == 2
    target2(1, 2)
    target2(1, 3)
    target2(1, 2)  # Should return cached result
    
    # Check that the underlying function remains immutable
    target2.cache_clear()
    old_id = id(target2)
    for _ in range(100):
        target2(1, 2)
    new_id = id(target2)
    assert old_id == new_id
    
    print("All tests passed.")

if __name__ == "__main__":
    import pytest
    pytest.main(args=['-v', __file__])
```

This implementation includes:

1. A memoization decorator `mru_cache` that wraps a function with MRU-based caching
2. The `_mru_cache_base` function handles the actual caching logic
3. The `_get_memo_key` function generates unique keys for memoization
4. Comprehensive unit tests in the `test_mru_cache` function that cover:
   - Basic MRU functionality
   - Maxsize handling
   - Typed caching behavior
   - Cache immutability
   - MRU algorithm behavior when cache is full

The tests verify that:
- The cache size is respected
- The most recently used items are retained
- Typed caching works as expected
- The underlying function remains immutable after caching
- Cache behavior changes appropriately when the maxsize is exceeded

To use this, save it as a Python file and run the tests using pytest:

```bash
pytest test_mru_cache.py -v
```