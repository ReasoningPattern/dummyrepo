

To solve this problem, we need to generate the next version identifier based on a given version string following a specific pattern. The version string is expected to be in the format of major.minor.patch, where each part is an integer. The next version should increment the last part, carrying over any overflow to the next higher part if necessary.

### Approach
1. **Split the Version String**: Convert the version string into a list of integers, each representing a part of the version.
2. **Increment and Carry Over**: Start from the last part and increment it by 1. If the incremented value exceeds 9, set it to 0 and carry over 1 to the next higher part. This process continues until there is no carry left or all parts have been processed.
3. **Handle Overflow**: If after processing all parts there is still a carry, add a new part at the beginning of the list with the carry value.
4. **Convert Back to String**: Convert the list of integers back into a string with parts separated by dots.

### Solution Code
```python
def next_version(version):
    version_parts = list(map(int, version.split('.')))
    carry = 1
    i = len(version_parts) - 1
    while i >= 0 and carry:
        current = version_parts[i] + carry
        if current >= 10:
            version_parts[i] = 0
            carry = 1
        else:
            version_parts[i] = current
            carry = 0
        i -= 1
    if carry:
        version_parts.insert(0, carry)
    return '.'.join(map(str, version_parts))
```

### Explanation
- **Splitting the Version String**: The version string is split into a list of integers using `split('.')` and `map(int, ...)`.
- **Incrementing and Carrying Over**: Starting from the last element, we increment it by 1. If it exceeds 9, it is reset to 0, and a carry is added to the next higher part. This ensures that each part stays within a single digit.
- **Handling Overflow**: If after processing all parts there is still a carry, a new part is added at the beginning of the list to accommodate the overflow.
- **Conversion to String**: The list of integers is converted back into a string using `map(str, ...)` and `join('.')`.

This approach ensures that each version increment correctly handles carry-over and maintains the expected format, providing a robust solution for generating the next version identifier.