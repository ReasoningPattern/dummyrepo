

To solve this problem, we need to create a function that forces a given object to be decoded as UTF-8 if it is a bytes or numpy.bytes object. If the object is already a string or any other type, it should be returned as is.

### Approach
1. **Problem Analysis**: The task is to decode bytes objects into strings using UTF-8 encoding if the input is either a standard Python bytes object or a numpy.bytes object. For all other types, including strings, we simply return the input as is.
2. **Type Checking**: We will use Python's `isinstance` function to check if the input is an instance of either `bytes` or `np.bytes_` (the numpy equivalent of bytes). This ensures we handle both Python and numpy byte objects.
3. **Decoding**: If the input is determined to be a byte object, we decode it using UTF-8 encoding and return the resulting string. For all other types, we return the input directly.

### Solution Code
```python
import numpy as np

def force_string(obj):
    """
    Force decoding obj with 'utf-8' if it is a numpy.bytes or bytes

    Args:
        obj: Consistency config

    Returns:
        Returns the bytes object corresponding to `obj` in case it is a string using UTF-8 else returns `obj`
    """
    if isinstance(obj, (bytes, np.bytes_)):
        return obj.decode('utf-8')
    else:
        return obj
```

### Explanation
- **Type Checking**: The function uses `isinstance(obj, (bytes, np.bytes_))` to check if the input is either a standard Python bytes object or a numpy.bytes object. This ensures both types are handled correctly.
- **Decoding**: If the input is a byte object, it is decoded using UTF-8 encoding. This is done using the `decode('utf-8')` method on the bytes object.
- **Return Value**: For all other types, including strings and non-bytes objects, the function returns the input as is.

This approach ensures that the function behaves correctly for both Python and numpy byte objects while leaving other types unchanged, as required by the problem statement.