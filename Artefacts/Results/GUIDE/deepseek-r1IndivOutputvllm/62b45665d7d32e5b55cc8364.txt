

To solve this problem, we need to write a function that distributes a sequence of arguments among multiple subparsers, allowing common arguments like "--repository" to be shared across these subparsers. The function should return a dictionary of parsed arguments for each subparser and a list of remaining arguments that were not parsed by any subparser.

### Approach
The approach involves the following steps:
1. **Initialization**: Start with an empty dictionary to hold the parsed arguments for each subparser and a list to hold the remaining arguments.
2. **Iterate Over Subparsers**: For each subparser, parse the remaining arguments using the subparser's `parse_args()` method.
3. **Update Remaining Arguments**: After parsing, update the list of remaining arguments to exclude those that have been parsed by the current subparser.
4. **Return Results**: After processing all subparsers, return the dictionary of parsed arguments and the list of remaining arguments.

This approach ensures that each subparser processes its share of the arguments, and any arguments not processed by a subparser are carried forward to the next subparser.

### Solution Code
```python
def parse_subparser_arguments(unparsed_arguments, subparsers):
    """
    Given a sequence of arguments and a dict from subparser name to argparse.ArgumentParser
    instance, give each requested action's subparser a shot at parsing all arguments. This allows
    common arguments like "--repository" to be shared across multiple subparsers.

    Returns:
        tuple: (a dict mapping from subparser name to a parsed namespace of arguments, a list of remaining arguments not claimed by any subparser).
    """
    parsed = {}
    remaining = list(unparsed_arguments)
    for subparser_name in subparsers:
        subparser = subparsers[subparser_name]
        try:
            subparser_args = subparser.parse_args(remaining)
            parsed[subparser_name] = subparser_args
            remaining = [arg for arg in remaining if arg not in subparser_args.args]
        except (ValueError, TypeError) as e:
            # Handle cases where the subparser cannot parse some arguments
            remaining = [arg for arg in remaining if arg not in subparser_args.args]
            raise e
    return parsed, remaining
```

### Explanation
- **Initialization**: The function starts by initializing an empty dictionary `parsed` to store the parsed arguments for each subparser and a list `remaining` to keep track of arguments not yet parsed.
- **Processing Each Subparser**: For each subparser, the function calls `parse_args()` with the current list of remaining arguments. This method returns the parsed arguments and the arguments that were successfully parsed.
- **Updating Remaining Arguments**: After parsing, the remaining arguments are updated to exclude those that have been parsed by the current subparser. This ensures that each argument is processed by only one subparser.
- **Error Handling**: The function includes try-except blocks to handle cases where a subparser cannot parse certain arguments, ensuring that the remaining arguments are correctly updated and any errors are propagated appropriately.

This solution efficiently distributes the parsing of arguments among multiple subparsers, allowing for shared common arguments while ensuring that all arguments are processed.