

To solve this problem, we need to create a function that can execute a list of commands with given arguments, working directory, and environment variables. The function should return the combined standard output and the return code of the last command executed. Additionally, it should handle verbose output and suppress standard error if specified.

### Approach
1. **Parameter Handling**: The function takes several parameters including a list of commands, arguments, working directory, verbose flag, and environment variables. The commands can be provided as a list of strings or a single string separated by semicolons.
2. **Command Execution**: Each command is executed in a separate subprocess. The function uses `subprocess.run` with `shell=True` to handle commands that might include shell-specific syntax.
3. **Output Collection**: The function captures the standard output from each command and combines them into a single string. Standard error is suppressed if the verbose flag is set to `False`.
4. **Return Code**: The return code of the last command is captured and returned along with the combined standard output.

### Solution Code
```python
import subprocess
import logging

def run_command(commands, args, cwd=None, verbose=False, hide_stderr=False, env=None):
    """
    Execute a list of commands and return the combined stdout and return code.
    
    Args:
        commands (str or list): List of commands to execute, or a single command string.
        args (list): Arguments to pass to each command.
        cwd (str, optional): Working directory. Defaults to None, which uses the current directory.
        verbose (bool, optional): If True, print the commands being executed. Defaults to False.
        hide_stderr (bool, optional): If True, suppress standard error output. Defaults to False.
        env (dict, optional): Environment variables to pass to the commands. Defaults to None.
        
    Returns:
        tuple: (str, int) containing combined stdout and return code of the last command.
    """
    if commands is None:
        commands = []
    elif isinstance(commands, str):
        commands = commands.split(';')
    else:
        commands = commands if commands else []
    
    combined_output = ''
    
    for cmd in commands:
        if verbose:
            logging.info(f"Running command: {cmd}")
        
        result = subprocess.run(
            cmd,
            shell=True,
            args=args,
            cwd=cwd,
            env=env,
            capture_output=True,
            text=True
        )
        
        if not hide_stderr:
            combined_output += result.stdout
        
        return_code = result.returncode
    
    return combined_output, return_code
```

### Explanation
- **Parameter Handling**: The function first checks if the `commands` parameter is `None` and initializes it to an empty list if necessary. If `commands` is a string, it splits it into a list of commands using semicolons as separators.
- **Command Execution**: Each command is executed using `subprocess.run` with `shell=True` to handle shell-specific syntax. The `capture_output=True` and `text=True` parameters ensure that the output is captured as strings.
- **Output Collection**: The standard output from each command is appended to `combined_output` if `hide_stderr` is `False`. The return code of each command is captured, and the return code of the last command is used as the final return code.
- **Verbose Output**: If `verbose` is `True`, each command is logged before execution.

This approach ensures that the function runs commands efficiently, collects necessary outputs, and handles errors gracefully by suppressing standard error output when specified.