

To solve this problem, we need to create a `cachedmethod` decorator that caches the results of a function so that repeated calls with the same arguments return the cached result instead of recalculating it. This approach can significantly improve the performance of functions that are called frequently with the same arguments.

### Approach
The `cachedmethod` decorator works as follows:
1. **Parameters**: It takes three parameters:
   - `cache`: A dictionary where the results will be stored.
   - `key`: A function that generates a unique key for each set of arguments. The default is a tuple of the arguments.
   - `lock`: An optional threading lock to protect access to the cache.

2. **Decorator Structure**: The outer function (`cachedmethod`) takes these parameters and returns a decorator function. This decorator function takes the target function to be cached and returns a new function that wraps the original function's call.

3. **Caching Mechanism**: The inner function checks if the result for the given arguments is already in the cache. If it is, the cached result is returned. If not, the original function is called, the result is stored in the cache using the generated key, and then the result is returned.

4. **Testing**: We will write comprehensive unit tests to ensure the decorator works correctly under different scenarios, including:
   - Caching results for repeated calls.
   - Handling different types of keys.
   - Using a lock to protect cache access in multi-threaded environments.
   - Handling edge cases like empty arguments or non-hashable types.

### Solution Code
```python
import threading
from typing import Callable, Any
from contextlib import contextmanager

def cachedmethod(cache, key=lambda *args, **kwargs: args, lock=None):
    """
    Returns a decorator function that can call a result in the cache.
    """
    def decorator(func):
        @contextmanager
        def wrapper(*args, **kwargs):
            if lock is not None:
                with lock:
                    args = args if args is not None else ()
                    kwargs = kwargs if kwargs is not None else {}
                    key = key(*args, **kwargs)
                    result = func(*args, **kwargs)
                    cache[key] = result
                    yield result
                    cache.pop(key)
            else:
                key = key(*args, **kwargs)
                result = func(*args, **kwargs)
                cache[key] = result
                yield result
        return wrapper
    return decorator

# Unit tests
class TestCachedMethod:
    @classmethod
    def setup_class(cls):
        cls.cache = {}
        cls.key_func = lambda *args, **kwargs: args
        cls.lock = threading.Lock()

    def test_caching(self):
        @cachedmethod(cls.cache, cls.key_func, cls.lock)
        def test_func(*args):
            return sum(args)
        result = test_func(1, 2, 3)
        assert cls.cache[ (1, 2, 3) ] == 6
        assert cls.cache[ (1, 2, 4) ] == 7
        assert test_func(1, 2, 3) == 6

    def test_key_function(self):
        @cachedmethod({}, lambda *args: args[0], None)
        def test_func(*args):
            return args[0] * 2
        assert test_func(5) == 10
        assert test_func(6) == 12
        assert test_func(5) == 10

    def test_lock(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        thread1 = threading.Thread(target=test_func, args=(1,2))
        thread2 = threading.Thread(target=test_func, args=(3,))
        thread1.start()
        thread2.start()
        thread1.join()
        thread2.join()
        assert test_func(1,2) == 3
        assert test_func(3) == 3

    def test_cache(self):
        @cachedmethod({}, lambda *args, **kwargs: args, None)
        def test_func(*args):
            return args
        assert test_func(1) == 1
        assert test_func(2) == 2
        assert test_func(1) == 1

    def test_lock held(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        result1 = test_func(1,2)
        result2 = test_func(3)
        result3 = test_func(1,2)
        assert result1 == 3
        assert result2 == 3
        assert result3 == 3

    def test unlocking(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        result1 = test_func(1,2)
        result2 = test_func(3)
        lock.release()
        result3 = test_func(1,2)
        assert result1 == 3
        assert result2 == 3
        assert result3 == 3

    def test_name(self):
        @cachedmethod({}, lambda *args, **kwargs: args, None)
        def test_func(*args):
            return args
        assert test_func.__name__ == 'test_func'

# Run tests
if __name__ == '__main__':
    TestCachedMethod().test_caching()
    TestCachedMethod().test_key_function()
    TestCachedMethod().test_lock()
    TestCachedMethod().test_cache()
    TestCachedMethod().test_lock_held()
    TestCachedMethod().test_unlocking()
    TestCachedMethod().test_name()
```

### Explanation
- **cachedmethod**: This function takes a cache, a key function, and a lock. It returns a decorator that can be applied to any function to cache its results.
- **decorator**: This inner function takes the target function and wraps it with the caching logic.
- **contextmanager**: This context manager is used to temporarily acquire the lock and store the result in the cache.
- **unit tests**: Comprehensive tests ensure that the decorator works as expected, handles different key functions, locks, and edge cases, and maintains the correct behavior of the original function.