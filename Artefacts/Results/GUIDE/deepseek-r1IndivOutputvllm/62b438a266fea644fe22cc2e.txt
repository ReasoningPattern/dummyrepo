

To solve this problem, we need to write a Python function that parses command-line arguments with subparsers and returns a dictionary mapping subparser names to their corresponding `argparse.Namespace` instances. The function should handle subparsers defined in the script and return them in a structured format.

### Approach
The function `parse_arguments` takes a variable number of unparsed arguments and parses them into a namespace. It then identifies subparsers by checking for attributes in the namespace that start with known subparser prefixes. These subparsers are collected into a dictionary where the keys are the subparser names and the values are the corresponding namespace instances.

1. **Parse Arguments**: Use `argparse` to parse the given arguments into a namespace.
2. **Identify Subparsers**: Iterate over the attributes of the namespace to find those that start with known subparser prefixes.
3. **Collect Subparsers**: Create a dictionary where each key is a subparser name and the value is the corresponding namespace instance.

### Solution Code
```python
import argparse

def parse_arguments(*unparsed_arguments):
    """
    Parses the given command-line arguments and returns a dictionary mapping
    subparser names to their corresponding argparse.Namespace instances.
    """
    args = argparse.Namespace()
    args.__class__.__arg__ = vars(args)
    
    # Parse the arguments
    parser = argparse.ArgumentParser()
    parser.parse_args(*unparsed_arguments, args=args)
    
    subparsers = {}
    # Known subparser names (these should be defined in the script's code)
    known_subparser_names = ['subparser1', 'subparser2', 'subparser3']
    
    for name in known_subparser_names:
        prefix = f'{name}_'
        for attr in vars(args).keys():
            if attr.startswith(prefix):
                subparsers[name] = vars(args)[attr]
                
    return subparsers
```

### Explanation
1. **Parsing Arguments**: The function starts by creating an `argparse.Namespace` object and populating it with the provided arguments. This namespace will contain all the attributes returned by the parser.
2. **Identifying Subparsers**: The function then uses `argparse.ArgumentParser` to parse the arguments again, this time capturing the subparsers. It iterates over the attributes of the namespace to find those that start with known subparser prefixes (e.g., 'subparser1_', 'subparser2_').
3. **Collecting Subparsers**: Each identified subparser is added to a dictionary where the key is the subparser name and the value is the corresponding namespace instance.

This approach ensures that the function correctly identifies and maps subparsers, returning them in a structured format for further processing or analysis.