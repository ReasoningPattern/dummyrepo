

To solve this problem, we need to merge multiple lists into a single list while ensuring there are no duplicate elements. The order of elements in the resulting list should reflect their first occurrence across all input lists.

### Approach
The approach involves iterating through each sublist in the input and then through each element within those sublists. We maintain a set to track elements that have already been added to the result list to ensure no duplicates. For each element, if it has not been seen before, it is added to both the result list and the seen set. This ensures that each element appears only once in the final list, in the order of their first occurrence.

### Solution Code
```python
def _legacy_mergeOrderings(orderings):
    """
    Combine multiple lists in the sequence of occurrence into a list with no duplicate elements.
    """
    result = []
    seen = set()
    for sublist in orderings:
        for element in sublist:
            if element not in seen:
                result.append(element)
                seen.add(element)
    return result
```

### Explanation
1. **Initialization**: We start with an empty list `result` to store the merged elements and an empty set `seen` to track elements that have been added.
2. **Iterate through Sublists**: For each sublist in the input `orderings`, we process each element.
3. **Check for Duplicates**: For each element, we check if it is in the `seen` set.
4. **Add to Result**: If the element is not seen before, it is added to both `result` and `seen`.
5. **Return Result**: After processing all elements, the function returns the merged list with no duplicates.

This approach efficiently handles the merging process with a time complexity of O(n), where n is the total number of elements across all sublists, ensuring optimal performance.