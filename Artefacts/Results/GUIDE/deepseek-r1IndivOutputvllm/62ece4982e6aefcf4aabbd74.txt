

To solve this problem, we need to create a function that takes an archive path and extracts it, returning a Git repository URL. This URL can be used as an origin for a Git repository. The function should handle both tar and zip archives and optionally extract a specific file if provided.

### Approach
1. **Extract Archive Content**: Use shell commands to extract the contents of the archive. If a specific filename is provided, extract only that file. Otherwise, extract all files.
2. **Return Git Repository URL**: For tar archives, use `tar -xvf`. For zip archives, use `zip -x`. Construct the URL based on the extracted directory.
3. **Handle Different Archive Types**: Check the extension of the archive to determine whether to use `tar` or `zip` commands.
4. **Test Cases**: Implement comprehensive test cases to ensure the function works correctly for different types of archives and filenames.

### Solution Code

```python
import subprocess
import shlex
from pathlib import Path

def prepare_repository_from_archive(
    archive_path: str,
    filename: Optional[str] = None,
    tmp_path: Union[PosixPath, str] = "/tmp",
) -> str:
    """
    Given an existing archive_path, uncompress it.
    Returns a file repo url which can be used as origin url.

    This does not deal with the case where the archive passed along does not exist.
    @param archive_path : archive file path
    @param filename: File name
    @param tmp_path: Temporary file path
    @return Repo URL
    """
    # Determine the command based on the archive type
    if archive_path.lower().endswith('.tar'):
        cmd = f"tar -xvf {archive_path}" if filename is None else f"tar -xvf {filename} {archive_path}"
    elif archive_path.lower().endswith('.zip'):
        cmd = f"zip -xvf {archive_path}" if filename is None else f"zip -xvf {filename} {archive_path}"
    else:
        raise ValueError("Archive must be a tar or zip file")

    # Extract the contents
    result = subprocess.run(
        shlex.split(cmd),
        text=True,
        capture_output=True,
        check=False
    )

    # Get the output and construct the URL
    extracted_path = result.stdout.strip()
    if extracted_path:
        return f"file://{extracted_path}"
    else:
        raise RuntimeError("Failed to extract archive")
```

### Test Cases
Here are some test cases to ensure the function works as expected:

```python
import os
import pytest
from pathlib import Path

@pytest.fixture
def tmp_path():
    return os.path.join(os.getcwd(), "tmp")

def test_tar_extraction(tmp_path):
    archive_path = os.path.join(tmp_path, "test.tar")
    with open(os.path.join(tmp_path, "test"), "wb") as f:
        f.write(b"testing data")
    path = Path(archive_path)
    path.write_bytes(path.read_bytes() + b".tar")
    url = prepare_repository_from_archive(archive_path)
    assert url.startswith(f"file://{tmp_path}/test/")

def test_zip_extraction(tmp_path):
    archive_path = os.path.join(tmp_path, "test.zip")
    with open(os.path.join(tmp_path, "test"), "wb") as f:
        f.write(b"testing data")
    path = Path(archive_path)
    path.write_bytes(path.read_bytes() + b".zip")
    url = prepare_repository_from_archive(archive_path)
    assert url.startswith(f"file://{tmp_path}/test/")

def test_specific_fileExtraction(tmp_path):
    archive_path = os.path.join(tmp_path, "test.zip")
    with open(os.path.join(tmp_path, "test"), "wb") as f:
        f.write(b"testing data")
    path = Path(archive_path)
    path.write_bytes(path.read_bytes() + b".zip")
    url = prepare_repository_from_archive(archive_path, filename="test")
    assert url.startswith(f"file://{tmp_path}/test/")
```

This solution provides a robust way to extract archives and generate the appropriate Git repository URL, handling different archive types and optional filenames. The test cases ensure the functionality works as expected.