

To solve this problem, we need to create a function that returns a pretty formatted string representation of an object. The function should handle different types of objects, including strings and other objects, and it should also include optional debug information.

### Approach
The function `pretty` is designed to return a formatted string that includes the class name, indentation, and the object representation. Here's the step-by-step approach:

1. **Check Object Type**: Determine if the object (`self.obj`) is a string. If it is, format it with single quotes.
2. **Handle Other Objects**: If the object is not a string, use its string representation.
3. **Include Indentation**: Prepend the formatted string with the specified indentation.
4. **Debug Information**: Optionally append debug information if the `debug` parameter is set to `True`.

The function combines these elements into a single string that provides a clear and concise representation of the object.

### Solution Code
```python
def pretty(self, indent=0, debug=False):
    """
    Return a pretty formatted representation of self.
    
    If self.obj is a string, returns it enclosed in single quotes.
    Otherwise, returns the repr of self.obj.
    
    Args:
        indent (int): The number of spaces for indentation. Defaults to 0.
        debug (bool): If True, appends '(debug)' to the object representation.
    
    Returns:
        str: The pretty formatted string.
    """
    if isinstance(self.obj, str):
        obj_str = f"'{self.obj}'"
    else:
        obj_str = repr(self.obj)
        if debug:
            obj_str += f" (debug)"
    return (" " * indent) + f"{self.__class__.__name__}({obj_str})"
```

### Explanation
- **String Check**: The function first checks if `self.obj` is a string. If it is, it formats the string with single quotes.
- **Object Representation**: For non-string objects, it uses the default string representation (using `repr()`).
- **Debug Information**: If `debug` is `True`, it appends `(debug)` to the object representation.
- **Formatting**: The formatted string is then constructed with the class name, indentation, and the object representation, which is returned as the result.

This approach ensures that the function handles various object types and provides optional debug information, making it versatile and user-friendly.