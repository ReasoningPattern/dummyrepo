

To solve this problem, we need to create a function that finds tags in a given text and optionally replaces them using a provided replacer function. The function should ignore any tags that are inside code blocks, which are defined as triple backticks.

### Approach
1. **Splitting the Text**: The text is split into segments of code blocks and normal text using regular expressions. Code blocks are identified by triple backticks, and normal text segments are the text outside these blocks.
2. **Collecting Tags**: For each normal text segment, we split the text into words and collect all unique words as tags.
3. **Replacing Tags**: If a replacer function is provided, each tag in the normal text segments is replaced using this function. If no replacer is provided, the tags are left as they are.
4. **Reconstructing the Text**: The code blocks and modified normal text segments are combined to form the final text. Code blocks are added as they are, while the normal text segments are modified to have their tags replaced.

### Solution Code
```python
import re

def find_tags(text: str, replacer: callable = None) -> Tuple[Set, str]:
    code_blocks = re.findall(r'```[\s\S]*?`', text)
    normal_text = re.split(r'```[\s\S]*?`', text, flags=re.DOTALL)
    
    tags = set()
    new_text = []
    
    for seg in normal_text:
        words = seg.split()
        for word in words:
            tags.add(word)
        if replacer:
            new_words = [replacer(word) for word in words]
        else:
            new_words = words
        new_text.append(' '.join(new_words))
    
    reconstructed = []
    for i in range(len(code_blocks)):
        reconstructed.append(code