

```python
# test lru_cache.py
import unittest
from functools import wraps
from collections import OrderedDict
import weakref

class TestLruCache(unittest.TestCase):
    def setUp(self):
        self.cache = lru_cache(maxsize=128)
        self.func1 = self._make_func()
        self.func2 = self._make_func(1)
        self.func3 = self._make_arg_func()
        
    def _make_func(self, default=0):
        def func():
            nonlocal default
            default += 1
            return default
        return func
    
    def _make_func_with_arg(self, default=0):
        def func(arg):
            nonlocal default
            default += 1
            return default, arg
        return func
    
    def _make_arg_func(self):
        def func(arg):
            return arg + 1
        return func

    def test_cache hit(self):
        self.assertEqual(self.cache(self.func1)(), 1)
        self.assertEqual(self.cache(self.func1)()(), 2)
        self.assertEqual(self.cache(self.func1)()(), 3)
        self.assertEqual(self.cache(self.func1)()(), 4)
        self.assertEqual(self.cache(self.func1)()(), 5)
    
    def test_cache_maxsize(self):
        self.assertEqual(len(self.cache(self.func1)()(5)), 1)
        self.assertEqual(len(self.cache(self.func1)()(6)), 2)
        self.assertEqual(len(self.cache(self.func1)()(7)), 2)
    
    def test_cache hit_and_miss(self):
        self.assertEqual(self.cache(self.func1)()(1), 1)
        self.assertEqual(self.cache(self.func1)()(2), 2)
        self.assertEqual(self.cache(self.func1)()(3), 3)
        self.assertEqual(self.cache(self.func1)()(4), 4)
        self.assertEqual(self.cache(self.func1)()(5), 5)
        self.assertEqual(self.cache(self.func1)()(6), 6)
        self.assertEqual(self.cache(self.func1)()(7), 7)
        self.assertEqual(len(self.cache(self.func1).cache), 8)
    
    def test_cache_idempotency(self):
        decorated = self.cache(self.func1)
        decorated2 = self.cache(self.func1)
        self.assertEqual(decorated(), decorated2())
        self.assertEqual(decorated.cache, decorated2.cache)
    
    def test_cache_typing(self):
        decorated = self.cache(maxsize=1, typed=True)(self.func2)
        self.assertEqual(decorated(1), 2)
        self.assertEqual(decorated(1), 2)
        self.assertEqual(decorated(2), 3)
        self.assertEqual(decorated(2), 3)
        self.assertEqual(len(decorated.cache), 1)
    
    def test_cache_typing_arg(self):
        decorated = self.cache(maxsize=1, typed=True)(self.func3)
        self.assertEqual(decorated(0), 1)
        self.assertEqual(decorated(0), 1)
        self.assertEqual(decorated(1), 2)
        self.assertEqual(decorated(1), 2)
        self.assertEqual(decorated(2), 3)
        self.assertEqual(decorated(2), 3)
        self.assertEqual(len(decorated.cache), 1)

class LRU_cache:
    def __init__(self, maxsize=128, typed=False):
        self.maxsize = maxsize
        self.typed = typed
        self.cache = OrderedDict()
        if typed:
            self._track = weakref.WeakKeyDictionary()
        else:
            self._track = {}

    def __call__(self, func):
        wrapped = wraps(func)(self._wrap_func(func))
        self.cache[functools.cmp_to_key(self._compare, func.__name__)]
        return wrapped

    def _wrap_func(self, func):
        return self

    def _compare(self, a, b):
        return -self._age(b) + self._age(a)

    def _age(self, item):
        return self.cache_size - self.cache OrderedDict.__getitem__ del self._track[key]

    @property
    def cache_size(self):
        return len(self.cache)

    def __getattr__(self, name):
        return getattr(self.cache, name)

    def __setattr__(self, name, value):
        return setattr(self.cache, name, value)

    def __delattr__(self, name):
        return delattr(self.cache, name)

    def __getitem__(self, key):
        return self.cache[key]

    def __setitem__(self, key, value):
        self.cache[key] = value

    def __delitem__(self, key):
        del self.cache[key]

    def __iter__(self):
        return iter(self.cache)

    def __len__(self):
        return len(self.cache)

def _compare(self, a, b):
    return -self._age(b) + self._age(a)
```

To run these tests, you can use:

```bash
python -m unittest test_lru_cache.py
```

The tests cover various aspects of the LRU cache implementation, including:
- Basic functionality
- Cache size limits
- Hit/miss behavior
- Idempotency (decorating the same function multiple times)
- Typed vs untyped caching
- Argument types in typed caching
- Proper ordering and eviction behavior

The actual implementation of `lru_cache` is contained in the `LRU_cache` class, which uses an `OrderedDict` to maintain the order of cache items and a dictionary to track weak references to the arguments for typed caching.