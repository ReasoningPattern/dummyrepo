

```python
import pytest

class BaseParser:
    def __init__(self):
        self.commands = {}
    
    def setup(self):
        self.add_subparsers()
        self.parser = self.create_parser()
        
    def add_subparsers(self):
        pass
    
    def create_parser(self):
        parser = self.parser
        return parser

def make_parsers():
    main_parser = BaseParser()
    main_parser.setup()
    subparsers = []
    
    # Add subparsers here
    
    return (main_parser, *subparsers)

@pytest.fixture
def main_parser():
    return make_parsers()[0]

@pytest.fixture
def subparser(int_subparser, ext_subparser):
    return (int_subparser, ext_subparser)

def test_main_parser_has_commands(main_parser):
    commands = main_parser.parser.commands
    assert len(commands) > 0

def test_subparser_commands(int_subparser, ext_subparser):
    assert int_subparser in ext_subparser.commands
    assert ext_subparser in int_subparser.commands

def test_subparser_setup(int_subparser):
    assert hasattr(int_subparser, 'setup')
    int_subparser.setup()
    assert hasattr(int_subparser, 'create_parser')

def test_subparser_commands(int_subparser, ext_subparser):
    assert int_subparser in ext_subparser.commands
    assert ext_subparser in int_subparser.commands
```

This implementation provides:
1. A base parser class with setup and command collection
2. A make_parsers function that creates and configures the main parser and subparsers
3. Unit tests that verify the functionality of both main and subparsers
4. Test-driven development approach with comprehensive test cases

The actual subparser implementations would need to be added in a separate file following the same interface.