def determineMetaclass(bases, explicit_mc=None):
    """
    Determine metaclass from 1+ bases and optional explicit __metaclass__
    """
    if explicit_mc is not None:
        return explicit_mc
    mcs = [type(b) for b in bases]
    candidate = mcs[0]
    for mc in mcs[1:]:
        if not issubclass(candidate, mc):
            if not issubclass(mc, candidate):
                raise TypeError("metaclass conflict: the metaclass of the base classes is not compatible")
            else:
                candidate = mc
    return candidate