import unittest
from datetime import datetime, timezone, timedelta

class CustomTimezone:
    def __init__(self, offset_hours):
        self.offset = timedelta(hours=offset_hours)

    def fromutc(self, dt):
        """
        Given a timezone-aware datetime in a given timezone, calculates a
        timezone-aware datetime in a new timezone.

        Since this is the one time that we *know* we have an unambiguous
        datetime object, we take this opportunity to determine whether the
        datetime is ambiguous and in a "fold" state (e.g. if it's the first
        occurrence, chronologically, of the ambiguous datetime).

        :param dt:
            A timezone-aware :class:`datetime.datetime` object.
        """
        # This is a simplified implementation that assumes no DST transitions.
        # In a real-world scenario, this would involve checking for DST transitions
        # and determining the fold state accordingly.
        local_dt = dt + self.offset
        return local_dt.replace(tzinfo=self)

class TestCustomTimezone(unittest.TestCase):
    def test_fromutc_simple_conversion(self):
        tz = CustomTimezone(2)
        utc_time = datetime(2023, 10, 1, 12, 0, tzinfo=timezone.utc)
        local_time = tz.fromutc(utc_time)
        self.assertEqual(local_time.tzinfo, tz)
        self.assertEqual(local_time, datetime(2023, 10, 1, 14, 0, tzinfo=tz))

    def test_fromutc_fold_state(self):
        # This test is illustrative; actual fold state handling would require DST logic.
        tz = CustomTimezone(0)
        utc_time = datetime(2023, 3, 12, 2, 30, tzinfo=timezone.utc)
        local_time = tz.fromutc(utc_time)
        self.assertFalse(hasattr(local_time, 'fold'), "Fold attribute should not be set in this simplified implementation")

if __name__ == '__main__':
    unittest.main()