import inspect
from zope.interface import providedBy, Invalid

def _verify(iface, candidate, tentative=False, vtype=None):
    """
    Verify that *candidate* might correctly provide *iface*.

    This involves:

    - Making sure the candidate claims that it provides the
      interface using ``iface.providedBy`` (unless *tentative* is `True`,
      in which case this step is skipped). This means that the candidate's class
      declares that it `implements <zope.interface.implementer>` the interface,
      or the candidate itself declares that it `provides <zope.interface.provider>`
      the interface

    - Making sure the candidate defines all the necessary methods

    - Making sure the methods have the correct signature (to the
      extent possible)

    - Making sure the candidate defines all the necessary attributes

    :return bool: Returns a true value if everything that could be
       checked passed.
    :raises zope.interface.Invalid: If any of the previous
       conditions does not hold.

    .. versionchanged:: 5.0
        If multiple methods or attributes are invalid, all such errors
        are collected and reported. Previously, only the first error was reported.
        As a special case, if only one such error is present, it is raised
        alone, like before.
    """
    errors = []

    # Check if the candidate provides the interface unless tentative is True
    if not tentative:
        if not providedBy(candidate):
            errors.append("Candidate does not provide the interface.")

    # Check for presence of all attributes/methods defined in the interface
    for name in iface.names():
        if not hasattr(candidate, name):
            errors.append(f"Missing attribute/method: {name}")
        else:
            attr = getattr(candidate, name)
            if callable(attr):
                # Check method signature
                try:
                    expected_signature = inspect.signature(iface[name])
                    actual_signature = inspect.signature(attr)
                    if expected_signature != actual_signature:
                        errors.append(f"Signature mismatch for method {name}")
                except Exception as e:
                    errors.append(f"Error checking signature for {name}: {e}")

    # Check for attributes (non-callable)
    for name in iface.names():
        if not hasattr(candidate, name):
            errors.append(f"Missing attribute/method: {name}")
        else:
            attr = getattr(candidate, name)
            if not callable(attr):
                # No signature check needed for attributes
                pass

    # Raise errors if any
    if errors:
        if len(errors) == 1:
            raise Invalid(errors[0])
        else:
            raise Invalid("\n".join(errors))

    return True