
Okay, I need to generate Python code for the function fetch_content_type based on the given signature and docstring. The user mentioned using test-driven development, so I should start by writing the unit tests first.

First, let's think about what the function is supposed to do. The docstring says it sets the head of the request through the URL and USER_AGENT. Wait, maybe that's a typo? Perhaps it's supposed to fetch the content type from the URL by making a HEAD request, using a specific user agent. The function returns an Optional[str], so it might return None if something goes wrong.

So the function likely sends a HEAD request to the given URL, sets the User-Agent header, and then returns the Content-Type header from the response. But how to handle errors? Like if the URL is invalid, or the request fails. The function should probably return None in those cases.

Now, for the tests. I need to write tests that check different scenarios. For example:

1. A valid URL that returns a Content-Type.
2. A URL that doesn't have a Content-Type header.
3. A URL that's invalid or unreachable.
4. Maybe a case where the request is blocked by the server, like a 403 or 404.

But how to mock the requests in the tests? Using a library like unittest.mock to patch the requests module. Also, need to make sure that the tests don't actually make real HTTP requests, to avoid dependencies and network issues.

So for the test cases, I'll create a test class with setup and teardown methods. Then, for each scenario, I'll mock the requests.head method to return a response with specific status codes and headers.

Now, writing the actual function. The function needs to use the requests library. So import requests. Then, set the User-Agent header. The default User-Agent might be something like 'python-requests/2.25.1' but maybe the function uses a specific one. Wait, the docstring mentions USER_AGENT, but it's not defined. So perhaps the function uses a predefined USER_AGENT variable. But since the user didn't provide that, maybe I should define it within the function or as a constant.

Wait, the code might need to have a USER_AGENT constant. For example:

USER_AGENT = 'MyApp/1.0'

Then, in the function, send a HEAD request with headers={'User-Agent': USER_AGENT}.

But since the user didn't specify, maybe I should define it inside the function or as a module-level variable. Let's assume that the USER_AGENT is a constant defined in the same module.

So the function would be:

import requests
from typing import Optional

USER_AGENT = 'MyApp/1.0'

def fetch_content_type(url: str) -> Optional[str]:
    try:
        response = requests.head(url, headers={'User-Agent': USER_AGENT}, timeout=10)
        response.raise_for_status()
        return response.headers.get('Content-Type')
    except requests.RequestException:
        return None

Wait, but the timeout is set to 10 seconds. That's a reasonable default. Also, using raise_for_status() to catch HTTP errors. So if the response is 4xx or 5xx, it will throw an exception, which is caught and returns None.

Now, the tests. Let's write them using unittest and mock.

For example:

import unittest
from unittest.mock import patch, Mock
from your_module import fetch_content_type, USER_AGENT

class TestFetchContentType(unittest.TestCase):

    @patch('your_module.requests.head')
    def test_valid_url(self, mock_head):
        # Setup mock response
        mock_response = Mock()
        mock_response.headers = {'Content-Type': 'text/html'}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertEqual(result, 'text/html')

    @patch('your_module.requests.head')
    def test_url_without_content_type(self, mock_head):
        mock_response = Mock()
        mock_response.headers = {}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('your_module.requests.head')
    def test_http_error(self, mock_head):
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = requests.HTTPError()
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('your_module.requests.head')
    def test_connection_error(self, mock_head):
        mock_head.side_effect = requests.ConnectionError()
        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

But wait, in the function, the exception is caught with requests.RequestException, which is the base class for all requests exceptions. So any exception from requests (like ConnectionError, Timeout, HTTPError, etc.) will be caught.

In the test cases, I need to mock the requests.head method and simulate different scenarios.

But the user might not have the 'your_module' imported, so in the actual code, the function and the USER_AGENT would be in the same module.

Now, putting it all together. The user wants only the code generated in Python markdown format. So the answer should include both the tests and the function code.

But the user's initial instruction says to generate the code based on the function signature and docstring, but the tips suggest TDD, so first tests then code.

So the final answer should have the tests first, then the function code.

But the user says to output ONLY the code generated, in Python markdown format. So I need to write the tests and the function code, properly formatted.

Also, the function's docstring says "Set the head of the request through the URL and USER_AGENT." Maybe that's a translation error, and it's supposed to say "Send a HEAD request...". But the code should be based on the given docstring.

So the final code would include the tests and the function. Also, the function uses the requests library, so it needs to import that. Also, the Optional type comes from typing.

So the code would be:

First, the tests:

import unittest
from unittest.mock import patch, Mock
from typing import Optional
import requests

# Assuming the function is in the same module
def fetch_content_type(url: str) -> Optional[str]:
    """
    Set the head of the request through the URL and USER_AGENT.
    """
    # Code here

Then the tests:

class TestFetchContentType(unittest.TestCase):

    @patch('requests.head')
    def test_valid_url(self, mock_head):
        mock_response = Mock()
        mock_response.headers = {'Content-Type': 'text/html'}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertEqual(result, 'text/html')

    @patch('requests.head')
    def test_url_without_content_type(self, mock_head):
        mock_response = Mock()
        mock_response.headers = {}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('requests.head')
    def test_http_error(self, mock_head):
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = requests.HTTPError()
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('requests.head')
    def test_connection_error(self, mock_head):
        mock_head.side_effect = requests.ConnectionError()
        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

But wait, in the function code, the USER_AGENT is not defined. So I need to add that.

So the function code would be:

import requests
from typing import Optional

USER_AGENT = 'MyApp/1.0'

def fetch_content_type(url: str) -> Optional[str]:
    """
    Set the head of the request through the URL and USER_AGENT.
    """
    try:
        response = requests.head(url, headers={'User-Agent': USER_AGENT}, timeout=10)
        response.raise_for_status()
        return response.headers.get('Content-Type')
    except requests.RequestException:
        return None

But the tests need to import this function and the USER_AGENT. However, in the test code, if the function and USER_AGENT are in the same module, then the tests can access them. But in the test code above, the tests are in the same module, so the code would be structured accordingly.

But in the generated code, the tests and the function are in the same file. So the complete code would be:

import unittest
from unittest.mock import patch, Mock
from typing import Optional
import requests

USER_AGENT = 'MyApp/1.0'

def fetch_content_type(url: str) -> Optional[str]:
    """
    Set the head of the request through the URL and USER_AGENT.
    """
    try:
        response = requests.head(url, headers={'User-Agent': USER_AGENT}, timeout=10)
        response.raise_for_status()
        return response.headers.get('Content-Type')
    except requests.RequestException:
        return None

class TestFetchContentType(unittest.TestCase):

    @patch('requests.head')
    def test_valid_url(self, mock_head):
        mock_response = Mock()
        mock_response.headers = {'Content-Type': 'text/html'}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertEqual(result, 'text/html')

    @patch('requests.head')
    def test_url_without_content_type(self, mock_head):
        mock_response = Mock()
        mock_response.headers = {}
        mock_response.raise_for_status.return_value = None
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('requests.head')
    def test_http_error(self, mock_head):
        mock_response = Mock()
        mock_response.raise_for_status.side_effect = requests.HTTPError()
        mock_head.return_value = mock_response

        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

    @patch('requests.head')
    def test_connection_error(self, mock_head):
        mock_head.side_effect = requests.ConnectionError()
        result = fetch_content_type('http://example.com')
        self.assertIsNone(result)

But wait, in the test cases, when patching 'requests.head', if the function is in the same module, the patch should target the correct path. However, in the code above, the function uses 'requests.head', so the patch in the test should be 'requests.head'.

But when using patch in the test, the first argument is the path to the object to mock. So in the test, if the code under test is importing requests, then the patch should be 'requests.head'.

Yes, that's correct.

Now, the code seems complete. The function uses the USER_AGENT, sends a HEAD request, handles exceptions, and returns the Content-Type or None.

The tests cover various scenarios: valid response with content type, no content type, HTTP error, connection error.

I think this should be the correct approach.
