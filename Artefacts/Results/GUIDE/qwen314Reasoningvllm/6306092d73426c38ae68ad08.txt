
Okay, I need to generate Python code for the function _get_conditionally_required_args based on the given signature and docstring. Let me think about what this function does.

The docstring says it lists arguments with required_when conditions matched. So, the function is supposed to check which arguments are required based on certain conditions. The parameters are command_name, options_spec, and args. The return is a list of argument names that meet the required_when condition.

First, I should figure out how the options_spec is structured. Since it's a list of command spec options, each option probably has a 'required_when' attribute. Maybe each option is a dictionary or an object with that attribute. The args parameter is the input arguments received, so perhaps it's a dictionary of argument names to their values.

The function needs to iterate over each option in options_spec and check if the 'required_when' condition is met. If it is, then the argument name is added to the result list.

But how does the 'required_when' condition work? It's probably a function or a string that can be evaluated. For example, it might be a lambda function that takes args and returns True if the condition is met. Or maybe it's a string that represents a condition, like "arg1 == 'value'".

Assuming that each option in options_spec has a 'required_when' key, which is a callable that takes args and returns a boolean. Then, for each option, we check if required_when(args) is True. If so, add the argument name to the list.

Wait, but the function is called _get_conditionally_required_args. So maybe the options_spec is a list of options, each with a 'name' and 'required_when' condition. The function checks for each option if the condition is met, and if so, includes the name in the result.

So the steps would be:

1. Initialize an empty list to collect the required argument names.
2. Iterate over each option in options_spec.
3. For each option, check if it has a 'required_when' condition.
4. If it does, evaluate the condition using the provided args.
5. If the condition evaluates to True, add the option's name to the list.
6. Return the list.

But how to handle the 'required_when' condition? Let's think about possible implementations. If the 'required_when' is a string, maybe it's a condition that can be evaluated as a Python expression. However, using eval() can be dangerous. Alternatively, it might be a function that takes args as input.

But since the function is part of a class (since it's a method, self is the first parameter), maybe the options_spec is structured with each option having a 'required_when' that's a function. Or perhaps it's a string that's a condition to check against the args.

Alternatively, maybe the 'required_when' is a dictionary that specifies conditions. For example, {'arg': 'value'}, meaning that if the argument 'arg' has the value 'value', then this option is required.

But without more context, I need to make an assumption. Let's assume that each option in options_spec has a 'required_when' key which is a function that takes the args dictionary and returns a boolean. So for each option, we call required_when(args), and if it returns True, then the option's name is added to the list.

So, the code would look something like this:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](args):
                required_args.append(option['name'])
    return required_args

But wait, the parameters are command_name, options_spec, and args. The command_name might be used in the required_when condition. For example, the condition might depend on the command name. However, the current code doesn't use command_name. So perhaps the required_when function also takes command_name into account.

But the function signature shows that the required_when is part of the options_spec. So maybe the options_spec's required_when is a function that takes command_name and args. Or maybe the function is designed to have the required_when condition check based on command_name and args.

Alternatively, maybe the required_when is a string that is evaluated in a context where command_name and args are available. But again, without more info, it's hard to tell.

Looking back at the function parameters: the function has command_name, options_spec, and args. The options_spec is a list of command spec options. So perhaps each option in options_spec has a 'required_when' that is a condition that depends on command_name and args.

But the current code example I wrote doesn't use command_name. That might be a problem. Maybe the required_when is a function that takes command_name and args. So the code would be:

for option in options_spec:
    if 'required_when' in option:
        if option['required_when'](command_name, args):
            required_args.append(option['name'])

But again, this is an assumption. Since the original code doesn't have any examples, I need to proceed with the best possible guess.

Another possibility is that the required_when is a string like "arg1 is present" or something, and the code evaluates that string in the context of args. For example, using eval, but that's risky. However, perhaps the code is designed to use the command_name and args in some way.

Alternatively, maybe the required_when is a key in the args. For example, if the required_when is set to a certain value, then the argument is required. But that's not clear.

Given the ambiguity, perhaps the best approach is to write code that checks for each option's required_when condition, which is a function that takes args as input. The command_name might not be used here, but perhaps it's part of the condition. However, without more information, I can't be sure.

Alternatively, maybe the required_when is a string that is a condition on the args. For example, "args['other_arg'] == 'value'". Then, the code would evaluate that string as a Python expression. But using eval is not safe, but perhaps that's what the code is intended to do.

So, perhaps the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            condition = option['required_when']
            # evaluate the condition using args and command_name
            # assuming condition is a string that can be evaluated
            # with locals() having command_name and args
            if eval(condition, {'command_name': command_name, 'args': args}):
                required_args.append(option['name'])
    return required_args

But this is risky and depends on the structure of the options_spec. However, given the lack of information, this might be a possible approach.

But the original function's docstring says that it returns the list of argument names with matched required_when condition. So, perhaps the options_spec is a list of dictionaries, each with 'name' and 'required_when' keys. The required_when could be a function or a string.

But again, without more context, it's challenging. However, given that the function is part of a class and the parameters include command_name, options_spec, and args, perhaps the required_when is a function that takes command_name and args as parameters.

In that case, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](command_name, args):
                required_args.append(option['name'])
    return required_args

But again, this is an assumption. However, given the parameters, this seems plausible.

Alternatively, maybe the required_when is a function that only takes args, and the command_name is not used here. But why is it passed as a parameter then?

This is a bit of a puzzle. But since the user hasn't provided more details, I'll proceed with the assumption that each option in options_spec has a 'required_when' key which is a function that takes args as input. The command_name is not used in this function, but it's passed as a parameter, perhaps for other purposes.

So the code would be as follows:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    """
    List arguments with ``required_when`` condition matched.

    :param command_name: the command name.
    :param options_spec:  the list of command spec options.
    :param args: the received input arguments
    :return: list, list of argument names with matched ``required_when``
        condition
    """
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            if option['required_when'](args):
                required_args.append(option['name'])
    return required_args

But this code assumes that each option in options_spec is a dictionary with 'name' and 'required_when' keys. Also, that 'required_when' is a function that takes args as a parameter.

Alternatively, maybe the required_when is a string that is evaluated in a context where args is available. For example, if the required_when is a string like "args.get('other_arg') == 'value'". Then, using eval would work, but it's not safe. However, if that's the intended use, then the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            condition = option['required_when']
            # evaluate the condition in a context where args is available
            if eval(condition, {'args': args}):
                required_args.append(option['name'])
    return required_args

But again, this is speculative.

Given that the user hasn't provided more details, perhaps the best approach is to proceed with the first assumption, that required_when is a function that takes args as input. That seems more secure and less error-prone than using eval.

So the final code would be as I wrote earlier. Now, considering that the user also mentioned test-driven development, I should generate unit tests first. But the user's instruction says to generate the code based on the function signature and docstring, outputting only the code in Python markdown format. However, the initial instruction said to generate code based on the function signature and docstring, but the tips mention to do test-driven development, first generating tests. But the user's final instruction says to output only the code generated, in Python markdown format.

Wait, the user's original request says: "Generate Python code based on the following function signature and docstring. Output ONLY the code generated, in python markdown format." So they want the code for the function, not the tests. However, the tips mention to do TDD, but the actual code to generate is the function itself.

So I should focus on writing the function code. Given the ambiguity, I'll proceed with the first approach where required_when is a function that takes args as input.

Another possibility: maybe the required_when is a key in the args. For example, if the required_when is set to a certain value, then the argument is required. But that doesn't make much sense.

Alternatively, the required_when could be a list of conditions. But again, without more info, it's hard to tell.

In conclusion, the code I'll write is the one that checks each option's required_when function, passing args to it, and if it returns True, adds the name to the list. That seems like a logical approach.
