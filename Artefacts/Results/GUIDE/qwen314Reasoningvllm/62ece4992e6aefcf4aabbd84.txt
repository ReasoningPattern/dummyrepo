
Okay, I need to generate Python code for the is_ipv4 function. The function should check if a given target is an IPv4 address and return a boolean. Let me think about how to approach this.

First, I remember that IPv4 addresses are in the format of four octets separated by dots, like 192.168.1.1. Each octet must be a number between 0 and 255. So the steps would be to split the target by dots, check if there are exactly four parts, and then validate each part.

But wait, there's also the case where the target might be a string representation of an IPv4 address. So I need to make sure that the input is a string first. If it's not a string, maybe return False immediately.

Wait, the function's parameter is 'target', which could be any type. So first, check if it's a string. If not, return False. Then split into parts.

So the plan is:

1. Check if the input is a string. If not, return False.
2. Split the string by '.' to get four parts.
3. Check if there are exactly four parts.
4. For each part, check if it's a numeric string (no letters), and then convert to integer.
5. Ensure each integer is between 0 and 255, inclusive.
6. Also, leading zeros might be a problem. For example, '00.0.0.0' is invalid because each part should not have leading zeros unless it's exactly zero. So, check that each part doesn't have leading zeros unless it's a single zero.

Wait, but according to IPv4 standards, leading zeros are not allowed. For example, "192.168.01.1" is invalid because "01" is not a valid octet. So each part must be a string that represents a number between 0-255, without leading zeros unless the number is zero itself.

So, for each part:

- It must be a string that can be converted to an integer.
- The integer must be between 0 and 255.
- The string must not have leading zeros unless it's exactly "0".

So, for example, "0" is okay, "00" is not, "123" is okay, "012" is not.

So, how to check that? For each part, if the length is more than 1, then the first character can't be '0'.

So, putting it all together:

Function steps:

Check if target is a string. If not, return False.

Split into parts = target.split('.')

If len(parts) !=4, return False.

For each part in parts:

   if part is empty, return False.

   if not part.isdigit(), return False.

   num = int(part)

   if num <0 or num >255: return False.

   if len(part) >1 and part[0] == '0': return False.

Wait, but wait, part.isdigit() would return True for "0", "00", etc. But we need to check for leading zeros. So, for example, part is "0" is okay. But "00" is not. So, for each part, after checking that it's a digit, check if the length is more than 1 and starts with 0. If so, invalid.

So that's the logic.

Now, let's think about test cases. The user mentioned test-driven development, so maybe write tests first.

But the user wants the code generated, but according to the initial instruction, the user wants the code for the function. However, the tips say to generate unit tests first. But the user's instruction says to generate the code based on the function signature and docstring, outputting only the code in Python markdown.

Wait, the user says "Generate Python code based on the following function signature and docstring. Output ONLY the code generated, in python markdown format."

So maybe the user wants the actual implementation code, not the tests. But the tips suggest to do TDD, but perhaps the user wants the code for the function, not the tests. However, the original problem says to generate code based on the function signature and docstring, which is the is_ipv4 function.

So, the code for the function.

So, implementing the steps above.

Now, code:

def is_ipv4(target):
    """
    Test if IPv4 address or not.

    Returns: Boolean, True if target is IPv4 address, else False.
    """
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
        if len(part) > 1 and part[0] == '0':
            return False
    return True

Wait, but wait, the check for part.isdigit() would return False for parts like "123.45.67.89" if any part is not a digit. But what about leading zeros?

Wait, for example, "0.0.0.0" is valid. But "00.0.0.0" would have part "00" which is digits, but len(part) is 2 and starts with 0. So the code would return False for that.

But what about "123.45.67.89"? Each part is digits, numbers are between 0-255, and no leading zeros. So returns True.

But what about "255.255.255.255"? Valid.

What about "256.1.1.1"? The first part is 256, which is >255, returns False.

What about "1.2.3.4"? Valid.

But what about "1.2.3.4.5"? Split into 5 parts, returns False.

What about "1.2.3"? Split into 3 parts, returns False.

What about "1.2.3."? Split into 4 parts, but the last is empty. So in the loop, part is empty, which is not digits. So returns False.

But wait, if target is "1.2.3.", then split into ['1', '2', '3', ''], so parts has len 4. Then, the last part is empty, which is not digits. So returns False.

Another case: "123.45.67.89a" would split into ['123', '45', '67', '89a'], which part is '89a' which is not digits. So returns False.

What about "192.168.01.1"? The third part is "01", which is digits, but len(part) is 2 and starts with 0. So returns False.

So this code should handle all these cases.

But wait, what about "0.0.0.0"? Each part is "0", which is allowed. So returns True.

What about "123.45.067.89"? The third part is "067" which starts with 0 and length >1. So returns False.

So this code seems to handle that.

But wait, what about "123.45.67.89"? All parts are valid. So returns True.

But what about "123.45.67.89"? Yes.

But what about "123.45.67.89"? Same as before.

So this code should work.

But I need to make sure that the code is correct.

Another possible edge case: "255.255.255.255" is valid. "0.0.0.0" is valid. "1.2.3.4" is valid. "1.2.3.04" is invalid because of leading zero.

But wait, what about "1.2.3.4"? The code returns True.

Another case: "123.45.67.89" is okay.

But what about a part that is "0"? That's allowed.

But what about a part that is "00"? The code checks if len(part) >1 and starts with 0. So returns False.

So the code seems correct.

But wait, what about "192.168.1.1"? It should return True.

Yes.

So the code should be correct.

Now, the code as written.

But wait, in Python, the split method on a string will split on every occurrence of the separator. So, for example, "192.168.1.1" splits into four parts. But if there are multiple dots, like "192..168.1.1", then split would produce ['192', '', '168', '1', '1'], which has len 5. So the code checks len(parts) ==4, so returns False. Which is correct.

Another case: "192.168.1.1." would split into ['192', '168', '1', '1', ''], len 5. So returns False.

So the code handles that.

But what about if the target is an integer? Like, target=12345. Then, since it's not a string, returns False. Which is correct.

So the code seems to handle all cases.

But wait, what about if the target is a string that's not an IPv4 address, like "192.168.1"? Split into 3 parts, returns False.

Yes.

Another case: "192.168.1.256" would have the last part as 256, which is >255. So returns False.

So the code should work.

Therefore, the code is as written above.
