

```python
def deep_merge_nodes(nodes):
    """
    Merge any node values corresponding to duplicate keys and return the result. If there are colliding keys with non-MappingNode values, the last of the values remains.
    """
    result = {}
    
    def merge_node(node):
        if not node:
            return {}
        
        value = node.get('value')
        children = node.get('children', [])
        
        # Process the value
        merged_value = merge_value(value)
        
        # Process the children
        merged_children = merge_children(children)
        
        return {merged_value: merged_children}
    
    def merge_value(val):
        if not val:
            return {}
        current_val = val.get('value')
        current_children = val.get('children', [])
        merged_current_val = merge_value(current_val)
        merged_current_children = merge_children(current_children)
        return {merged_current_val: merged_current_children}
    
    def merge_children(children):
        if not children:
            return {}
        result = {}
        for child in children:
            merged_child = merge_node(child)
            for key in merged_child:
                if key in result:
                    # If the existing value is not a MappingNode, keep the current one
                    if not isinstance(result[key], dict):
                        result[key] = merged_child[key]
                    else:
                        # Merge the two dictionaries
                        # This is a simplified approach; actual merging logic may vary
                        result[key] = merged_child[key]
                else:
                    result[key] = merged_child[key]
        return result
    
    for node in nodes:
        merged_node = merge_node(node)
        result.update(merged_node)
    
    return result
```