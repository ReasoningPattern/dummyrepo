import threading
from typing import Callable, Any
from contextlib import contextmanager

def cachedmethod(cache, key=lambda *args, **kwargs: args, lock=None):
    """
    Returns a decorator function that can call a result in the cache.
    """
    def decorator(func):
        @contextmanager
        def wrapper(*args, **kwargs):
            if lock is not None:
                with lock:
                    args = args if args is not None else ()
                    kwargs = kwargs if kwargs is not None else {}
                    key = key(*args, **kwargs)
                    result = func(*args, **kwargs)
                    cache[key] = result
                    yield result
                    cache.pop(key)
            else:
                key = key(*args, **kwargs)
                result = func(*args, **kwargs)
                cache[key] = result
                yield result
        return wrapper
    return decorator

# Unit tests
class TestCachedMethod:
    @classmethod
    def setup_class(cls):
        cls.cache = {}
        cls.key_func = lambda *args, **kwargs: args
        cls.lock = threading.Lock()

    def test_caching(self):
        @cachedmethod(cls.cache, cls.key_func, cls.lock)
        def test_func(*args):
            return sum(args)
        result = test_func(1, 2, 3)
        assert cls.cache[ (1, 2, 3) ] == 6
        assert cls.cache[ (1, 2, 4) ] == 7
        assert test_func(1, 2, 3) == 6

    def test_key_function(self):
        @cachedmethod({}, lambda *args: args[0], None)
        def test_func(*args):
            return args[0] * 2
        assert test_func(5) == 10
        assert test_func(6) == 12
        assert test_func(5) == 10

    def test_lock(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        thread1 = threading.Thread(target=test_func, args=(1,2))
        thread2 = threading.Thread(target=test_func, args=(3,))
        thread1.start()
        thread2.start()
        thread1.join()
        thread2.join()
        assert test_func(1,2) == 3
        assert test_func(3) == 3

    def test_cache(self):
        @cachedmethod({}, lambda *args, **kwargs: args, None)
        def test_func(*args):
            return args
        assert test_func(1) == 1
        assert test_func(2) == 2
        assert test_func(1) == 1

    def test_lock held(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        result1 = test_func(1,2)
        result2 = test_func(3)
        result3 = test_func(1,2)
        assert result1 == 3
        assert result2 == 3
        assert result3 == 3

    def test unlocking(self):
        @cachedmethod({}, lambda *args, **kwargs: args, threading.Lock())
        def test_func(*args):
            return sum(args)
        lock = threading.Lock()
        result1 = test_func(1,2)
        result2 = test_func(3)
        lock.release()
        result3 = test_func(1,2)
        assert result1 == 3
        assert result2 == 3
        assert result3 == 3

    def test_name(self):
        @cachedmethod({}, lambda *args, **kwargs: args, None)
        def test_func(*args):
            return args
        assert test_func.__name__ == 'test_func'

# Run tests
if __name__ == '__main__':
    TestCachedMethod().test_caching()
    TestCachedMethod().test_key_function()
    TestCachedMethod().test_lock()
    TestCachedMethod().test_cache()
    TestCachedMethod().test_lock_held()
    TestCachedMethod().test_unlocking()
    TestCachedMethod().test_name()