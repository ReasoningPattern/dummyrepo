def lfu_cache(maxsize=128, typed=False):
    """
    Decorator to wrap a function with a memoizing callable that saves
    up to `maxsize` results based on a Least Frequently Used (LFU)
    algorithm.
    """
    from collections import defaultdict
    import functools

    def decorating_function(user_function):
        cache = {}
        freq = defaultdict(int)
        usage = {}

        def wrapper(*args, **kwargs):
            key = (args, frozenset(kwargs.items())) if typed else (args, frozenset(kwargs.items()))
            if key in cache:
                freq[key] += 1
                usage[key] = len(cache)
                return cache[key]
            if len(cache) >= maxsize:
                # Find the LFU item, breaking ties by least recently used
                lfu_key = min(cache, key=lambda k: (freq[k], usage[k]))
                del cache[lfu_key]
                del freq[lfu_key]
                del usage[lfu_key]
            result = user_function(*args, **kwargs)
            cache[key] = result
            freq[key] = 1
            usage[key] = len(cache)
            return result

        wrapper.cache_info = lambda: len(cache)
        return functools.wraps(user_function)(wrapper)

    return decorating_function