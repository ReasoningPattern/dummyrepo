def lfu_cache(maxsize=128, typed=False):
	"""
	Decorator to wrap a function with a memoizing callable that saves
up to `maxsize` results based on a Least Frequently Used (LFU)
algorithm.
	"""
	
	from collections import defaultdict, deque
	
	class LFUCache:
		def __init__(self, maxsize):
			self.maxsize = maxsize
			self.cache = defaultdict(int)
			self.freq = defaultdict(int)
			self.order = deque()
		
		def _get_key(self, key):
			return key
		
		def __getitem__(self, key):
			self._get_key(key)
			self.freq[key] += 1
			self.order.append(key)
			return self.cache[key]
		
		def __setitem__(self, key, value):
			if key in self.cache:
				self.cache[key] = value
				self.freq[key] += 1
				self.order.append(key)
				self.order.pop(self.order.index(key))
				if len(self.order) > self.maxsize:
					self.order.popleft()
				return
			
			if len(self.cache) >= self.maxsize:
				lfu_key = self.order.popleft()
				del self.cache[lfu_key]
				del self.freq[lfu_key]
			
			self.cache[key] = value
			self.freq[key] = 1
			self.order.append(key)
		
		def __delitem__(self, key):
			if key in self.cache:
				del self.cache[key]
				del self.freq[key]
				del self.order[self.order.index(key)]
		
		def __contains__(self, key):
			return key in self.cache
		
		def __len__(self):
			return len(self.cache)
	
	def decorator(func):
		def wrapper(*args, **kwargs):
			key = func.__name__
			result = func(*args, **kwargs)
			return result
		
		return wrapper
	
	if typed:
		return decorator
	else:
		return LFUCache(maxsize)