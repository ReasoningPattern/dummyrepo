Okay, I need to write a Python function called is_ipv4 that checks if a given target is a valid IPv4 address. Let's think about how IPv4 addresses are structured. They consist of four octets separated by dots, each ranging from 0 to 255. So first, I should split the target string by dots. There must be exactly four parts. If there aren't, return False.

Then, each part has to be a number. So each part should be a string that can be converted to an integer. But also, leading zeros might be an issue? Wait, according to standard IPv4 rules, leading zeros are allowed but when converted to an integer, that's okay. However, the string should not have leading zeros unless the number is 0. Wait, actually, some sources say that leading zeros in IPv4 octets are acceptable. For example, 192.168.01.01 is technically a valid IPv4 address even though it has leading zeros. So maybe the function doesn't need to check for that. Hmm, but maybe the problem expects that each part must be a valid integer between 0 and 255, regardless of leading zeros. Wait, the question says "test if IPv4 address or not". The standard definition allows leading zeros, so perhaps the function should just check the numeric value, not the string format. So the steps would be:

1. Split the target into parts by '.'.
2. Check if there are exactly 4 parts. If not, return False.
3. For each part in the parts:
   a. Check if it's a numeric string. So, can't have letters or other characters.
   b. Convert to integer. Check if the number is between 0 and 255 inclusive.

Wait, but how to handle empty strings? For example, if the input is "123.45.6.7.." then splitting would give more than four parts. So splitting on '.' would give parts like empty strings if there's a trailing dot. So the first check is that the split must result in exactly four parts, and each part must be a numeric string that can be converted to an integer between 0 and 255.

So step by step:

First, split the target into parts. If the length isn't 4, return False.

Then loop over each part:

- Check if the part is a digit string. So, for example, '0' is okay, '123' is okay, but 'abc' is not. Also, if the part is empty, that's invalid.

Wait, but what about leading zeros? Like '0123'? The numeric value would be 123 which is okay. Wait no, 0123 is 123 but as a decimal, but as a string, the leading zero is allowed in the string, but when converted to an integer, it's just 123, which is okay as long as it's <=255. Wait, but the problem is, the function should return True for an IPv4 address. So, according to IPv4 standards, each octet is a number from 0 to 255, but the string representation can have leading zeros. So the leading zeros are allowed in the string. So the function doesn't need to check for that. The key is that each part is a number between 0-255 when converted to an integer. So the steps for each part:

Check if the part is a string that can be converted to an integer. So first, check if it's all digits. Also, if it's something like '0', that's okay, or '255', but '0255' would be 255? Wait, no. Wait, '0255' as a string when converted to an integer is 255, because leading zeros are allowed in the string but the numeric value is 255, which is okay. Wait, but 0255 in some contexts (like octal) but in Python, '0255' as a string would convert to 255 as an integer? Wait, no. Wait, in Python, if you have a string like '0255', converting to int with base 10 would give 255. So that's acceptable. So the function doesn't need to check for leading zeros. The problem is only whether each part is a number between 0 and 255.

So the steps:

Split into parts. Check length is 4.

For each part in parts:

- Check that the part is a string that is numeric. So, can't be empty, and all characters are digits. So if part is empty, return False. Also, if part is something like '12.3' then splitting would have given parts but this part can't be converted to an integer.

Wait, so first check that each part is composed of digits. So for part in parts:

if not part.isdigit(): return False? Wait, no, because maybe part starts with a zero but is okay. Wait, but part.isdigit() returns True for '0123', since all characters are digits. So that's okay. But part must be a non-empty string of digits.

Wait, but what about if part is '0'? That's okay. '0' is valid. '255' is okay. '256' is 256 which is over 255, so that part would be invalid.

So the steps for each part:

Check if the part is all digits (using isdigit()), so that it can be converted to an integer. Also, the part must not be empty. Because if the original string was '192.168.0.1', split into 4 parts, each is non-empty.

Wait, but for the split, if the target is like '1.2.3.4.5', then split gives 5 parts, so that's already rejected. But if a part is empty? Like '...1' would split into ['', '', '', '1'], but that's four parts but first two parts are empty. So in that case, the first part is empty, so when checking isdigit(), it would return False because ''.isdigit() is False.

So, for each part:

if part.isdigit() is False, return False.

Then, convert the part to an integer, and check if it's between 0 and 255 inclusive. So:

num = int(part)

if not 0 <= num <= 255:

return False

So putting all together:

def is_ipv4(target):

    parts = target.split('.')

    if len(parts) !=4:

        return False

    for part in parts:

        if not part.isdigit():

            return False

        num = int(part)

        if num <0 or num>255:

            return False

    return True

Wait, but what about something like '255.255.255.255'? That should return True. What about '0.0.0.0'? Also true. What about '192.168.0.1' yes. What about '192.168.01.1'? The parts are '192', '168', '01', '1'. The third part is '01', which is digits, converted to 1, which is okay. So the function would return True. But according to some definitions, leading zeros in the octets are allowed, so that's okay.

So this code would accept that. But the problem says to test if it's an IPv4 address. So that's correct.

Wait, but what about leading zeros? Like '012.034.045.056'? The function would return True, which is correct.

What about '256.1.1.1'? The first part is '256', which as an integer is 256, which is over 255, so returns False. Correct.

What about empty string? ' ' would split into parts with one element? No, split on '.' would split into parts. For example, an empty string would split into [''], so len(parts) is 1, so returns false.

What about '123.45.67.89' which is four parts, each digit, and each number is less than 255. So that's okay.

Another case: '123.45.67' split into three parts, so returns false.

Edge case: '0.0.0.0' is valid. '255.255.255.255' is valid. '192.168.0.255' valid.

What about a part with leading zeros but the number is okay? '0.000.000.0' is okay? The function would return True because each part is digits, and converted to 0, etc. So yes.

So I think this code should work.

Wait, but what about a part that is '0' (allowed) versus '0a'? Like '192.168.0a.1'? The '0a' is not digits, so isdigit() returns False, so returns False.

Another case: '123.45.6.7.8' splits into 5 parts, so returns false.

Yes, this should handle all the cases.
