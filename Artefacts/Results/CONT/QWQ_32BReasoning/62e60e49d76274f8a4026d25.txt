Okay, so I need to write a Python decorator called unit_of_work that takes two optional parameters: metadata and timeout. The decorator should return a wrapper function that has attributes metadata and timeout. Let me think about how to structure this.

First, the unit_of_work function is a decorator factory. It receives metadata and timeout, which are optional. The function should return a decorator that can be applied to another function. The returned decorator needs to set the metadata and timeout attributes on the wrapped function.

Wait, right. So the structure would be something like this:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        # set the attributes here
        func.metadata = metadata
        func.timeout = timeout
        return func
    return decorator

But wait, maybe the inner decorator should return a wrapper? No, because in this case, the decorator is just adding attributes, not modifying the function's behavior. So the inner function can just return the original function with the attributes added. That should work.

Let me check the requirements again. The decorator returned by unit_of_work should have the metadata and timeout as attributes. So when someone uses @unit_of_work(...) on a function, those attributes are added to the function object.

Yes, that code should do that. Let me test in my mind. Suppose someone does:

@unit_of_work(metadata={'key': 'value'}, timeout=30)
def my_func():
    pass

Then my_func.metadata should be the dictionary, and my_func.timeout 30. The code above does that by decorating the function with the inner decorator, which adds the attributes.

Hmm, but what if the user doesn't provide metadata or timeout? The parameters are optional, so they default to None. That's handled by the parameters in the unit_of_work function.

I think that's all. So the code is as I wrote. Let me make sure there's no syntax errors. The outer function returns the decorator, which is a function taking another function. Then inside, the func's attributes are set. Yep, that should work.

I think that's the correct approach. The key points are creating the decorator factory that returns a decorator which adds the attributes to the wrapped function. The wrapper function doesn't need to do anything else except pass through the original function since the main purpose is just adding attributes. So this should satisfy the problem's requirements.
