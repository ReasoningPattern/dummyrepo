Okay, I need to write the Python function find_tags based on the given signature and docstring. Let me start by understanding what the function is supposed to do.

The function's goal is to find tags in a given text. The tags are probably something like words starting with a # symbol, like hashtags. But the problem mentions ignoring tags inside code blocks. Code blocks are typically denoted by being enclosed in triple backticks (```), so I need to parse the text and avoid any tags within those regions.

Additionally, there's an optional replacer function. If provided, the function should replace each tag with the result of replacer(tag), and return the modified text along with the set of tags found. If no replacer is given, the original text is returned.

Hmm, how to approach this. Let's think step by step.

First, I need to parse the text, looking for code blocks. So the text is split into sections inside and outside code blocks. For each section outside code blocks, I can look for tags. For sections inside, I can ignore any tags there.

The plan is:

1. Split the text into regions inside and outside code blocks. Each time a ``` is encountered, it toggles whether we're in a code block.

But wait, code blocks are usually denoted by triple backticks, so the opening is ``` and the closing is another ```, but how do we handle that? Because the opening is three backticks, and the closing is also three backticks. So the code block starts at the first ``` and ends at the next occurrence of ```, right? But maybe the user could have other formatting, but perhaps the problem assumes that code blocks are enclosed between triple backticks.

So the approach would be to split the text into parts separated by triple backticks. The first part is outside code, then the next is inside, then the next is outside, etc. But that might not account for the closing properly, but perhaps this is a reasonable approach.

Alternatively, iterate through the text, tracking whether we are in a code block. Whenever we see three backticks, we toggle the state. While not in a code block, collect tags.

So, let's think of the text as a sequence of segments separated by triple backticks. The segments alternate between non-code and code blocks. So segments at even indices (0, 2, 4...) are non-code, and odd indices (1, 3, ...) are code.

Wait, actually, the first segment before the first ``` is non-code. Then the first ``` starts a code block, so the next segment (between ``` and the next ```) is code. Then another ``` would end the code block, so the next segment is non-code again. So yes, the even indices are non-code, odd are code.

So splitting the text on triple backticks gives us these segments. For each non-code segment, we can process them for tags. For code segments, we ignore any tags inside them.

So step by step:

- Split the text into parts using the triple backtick as a delimiter. The parts are stored in a list called segments.

Then, for each segment in segments:

- if the index is even (0,2,4), it's a non-code section. So process this part for tags.

- if odd, it's code, so skip.

But also, after splitting, the segments alternate between non-code and code. So for each non-code segment, we can process it to find tags.

Now, how to find the tags in a non-code segment. Let's assume that tags are words starting with a #, like #python or #tag. So we can search for sequences of characters starting with # followed by letters, numbers, underscores, etc. But perhaps the exact definition is up to the problem's requirements, but the problem's docstring doesn't specify. So perhaps we can use a regex to find all # followed by word characters (letters, digits, underscores) until a non-word character or whitespace.

Alternatively, maybe the tags are any word that starts with a # and is followed by a space or end of line. But perhaps the exact regex can be determined.

Wait, the problem says "find tags in text". The exact definition of a tag isn't given, so maybe the standard approach is to look for words starting with #, but the exact regex may need to be thought of.

Alternatively, perhaps the tags are any substring starting with # and followed by non-whitespace characters until a whitespace or punctuation. So perhaps a regex like #\S+ ?

Alternatively, perhaps the problem considers a tag as any sequence of characters starting with # followed by letters, numbers, underscores, hyphens, etc., but not including spaces or other separators. So the regex could be r'#\w+' or something similar.

Hmm, perhaps the correct approach is to use a regular expression to find all occurrences of # followed by word characters (letters, digits, underscores) but maybe including other characters. Alternatively, perhaps the problem is more general, so the regex should capture any # followed by a word (letters, numbers, underscores, etc.) until a non-word character or end of string. Alternatively, maybe it's any # followed by any characters until a whitespace. Not sure, but perhaps the problem expects the regex to find all # followed by any non-whitespace characters. Let's go with r'#\w+' for now, but maybe need to adjust.

Wait, perhaps the problem is expecting the tags to be like hashtags, so like #python, so the regex would be # followed by word characters (letters, numbers, underscores) but maybe also including hyphens or periods? Hmm, maybe the problem just wants the standard hashtag style, so using r'#\w+' would be sufficient. Alternatively, maybe it's better to use r'#\S+' to include any non-whitespace characters after the #. That way, even if there's a hyphen, like #hello-world, it would be captured as one tag. Let's go with r'#\S+' but perhaps that's overreaching. Hmm, perhaps the problem expects the tags to be words starting with # and followed by word characters. Let me proceed with r'#\w+'.

Wait, but the problem says "tags", but the exact definition might not be given, so perhaps the regex is left to the implementer's discretion. Let's proceed.

So, for each non-code segment, we can process the text to find all the tags (using regex) and collect them in a set. Additionally, if a replacer is provided, we need to replace each tag in the non-code segments with replacer(tag). So, when building the new text, for non-code segments, we can process the text by replacing each tag with the replacer's result. For code segments, we leave them as is.

The steps would be:

Initialize a set for tags.

Split the text into segments using ``` as the delimiter. The segments list is obtained via text.split('```').

Initialize a new_text list to accumulate the processed text.

current_in_code is a boolean indicating whether we are in a code block. Initially, it's False.

Wait, actually, the splitting approach may not track the code regions correctly. Let me think again. The split would create segments where each segment alternates between code and non-code. The first segment is non-code, then code, then non-code, etc. So the index determines if it's code or not. So for each segment in segments:

if index is even: non-code, process for tags and replace if needed.

if odd: code, just append as is.

So the loop over the segments would be:

for i, seg in enumerate(segments):

    if i % 2 == 0:

        process the non-code segment, collect tags, replace if needed.

    else:

        append as is.

Wait, but splitting on triple backticks may split the text into parts where each segment is separated by the triple backticks. So for example, "abc```def```ghi" would split into ["abc", "def", "ghi"]. The first segment (index 0) is non-code, the next (index1) is code, then index2 is non-code again.

Yes, so that's correct.

So processing each non-code segment:

For each non-code segment, first find all the tags in it. Using a regex findall to get all the tags.

Add them to the set.

Then, if replacer is given, replace each occurrence of the tag in the segment with replacer(tag). The replacement must be done in a way that preserves the rest of the text.

Wait, how to replace the tags in the text while collecting them. Because when replacing, we can process the text by using re.sub with a function.

Alternatively, here's an approach:

For each non-code segment:

- find all tags in the segment. Add to the tags set.

- if replacer is provided, replace each tag in the segment with replacer(tag). The replacement can be done using re.sub with a lambda function.

Wait, but how to do that:

Suppose the regex is r'#(\w+)' (assuming tags are like #python, so matching the # followed by word characters). Wait, maybe the regex is r'#\S+' but let's see.

Wait, perhaps the regex is r'#\w+', but let's think of the regex as r'#\w+' (so the tag is the entire matched string). So the pattern would be r'#\w+', and each match is a tag.

Alternatively, perhaps the regex should be r'#\S+' to include any non-whitespace characters after the #. For example, #hello-world would be captured as a single tag.

Hmm, perhaps that's better. Let's use r'#\S+' but then we need to ensure that the match stops at the next whitespace. Wait, \S+ will match any non-whitespace sequence. So #hello there would match the #hello part, and the rest is whitespace. That seems okay.

So the regex can be re.compile(r'#\S+', re.UNICODE). Wait, but maybe the problem expects the tags to be words separated by spaces. Alternatively, perhaps it's better to use a regex that captures the entire tag. Let me proceed with r'#\S+'.

Wait, but maybe the problem wants the tags to be exactly the words starting with # and followed by word characters (letters, numbers, underscores). Let's think of the regex as r'#\w+'.

Alternatively, perhaps the problem expects tags to be any sequence starting with # and followed by alphanumeric characters and underscores, so the regex would be r'#\w+'.

Hmm, perhaps the problem's definition of a tag is any substring starting with a # followed by a sequence of word characters (letters, numbers, underscores). Let's proceed with that regex.

So, the regex pattern = re.compile(r'#\w+').

Wait, but the problem says "find tags in text". Maybe the tags are words starting with a #, so the regex should be something like r'#\w+'.

So, for each non-code segment:

- find all tags in the segment using the regex.

- add each tag to the tags set.

- if replacer is not None, replace each occurrence of the tag with replacer(tag). The replacer is called with the tag as an argument. So the replacement would be the result of replacer(matched_tag).

But how to do this in Python. The re.sub function can take a function as the replacement. So, for example, re.sub(pattern, lambda m: replacer(m.group()), text).

Wait, the replacer is a function that takes the tag string (the entire matched string, like "#python") and returns the replacement.

Wait, but in the problem's docstring, it says "the replacer function called with the tag word". So the replacer's argument is the tag (the actual string found, like "#python"). So the function replacer(tag_str) returns the replacement string.

Therefore, in the substitution, for each match m (the matched tag string), the replacement is replacer(m.group()).

Therefore, in code:

processed_segment = re.sub(pattern, lambda m: replacer(m.group()), seg)

So putting this together.

Now, the steps for each non-code segment:

1. Find all occurrences of the pattern (the tags) in the segment, add to the tags set.

Wait, how to collect the tags. The re.findall function can be used to get all matches.

But since we also need to process the replacement, perhaps the best way is to first collect all the tags, and then do the substitution.

Wait, but for collecting the tags, in the non-code segments, we can do:

matches = pattern.findall(seg)

for tag in matches:

    tags.add(tag)

Then, if replacer is not None, do the substitution as above.

Alternatively, during substitution, we can collect the tags, but perhaps it's easier to first collect them.

So in code:

tags = set()

segments = text.split('```')

new_text = []

for i, seg in enumerate(segments):

    if i % 2 == 0: # non-code segment

        # find all tags in seg

        found_tags = pattern.findall(seg)

        for t in found_tags:

            tags.add(t)

        # now, process replacement if needed

        if replacer is not None:

            new_seg = pattern.sub(lambda m: replacer(m.group()), seg)

        else:

            new_seg = seg

        new_text.append(new_seg)

    else: # code segment, just append as is

        new_text.append(seg)

Wait, but this approach may have a problem: the code segments are the ones with odd indices, and non-code even. So the code segments are the ones between the triple backticks.

Wait, but when splitting on '```', the segments alternate between non-code and code. So the first segment is non-code, the next is code, then non-code, etc.

Therefore, the code above should work.

Then, after processing all segments, the new_text is the list of segments (processed or not) that we need to join with '```' again? Wait no, because the split on '```' removes the delimiters, so to reassemble the text, we need to insert the '```' between the segments.

Ah, right. Because when you split on a delimiter, the resulting list's elements are the parts between the delimiters. So to reconstruct the text, you have to join the segments with the delimiter. So the reconstructed text would be:

'```'.join(new_text)

Wait no, let's see: original text was split into segments by splitting on '```', so the reconstructed text is '```'.join(segments). So in the code above, after processing each segment into new_seg (either the original or modified), the new_text list contains all the segments (non-code and code) in order, and then the final text is '```'.join(new_text).

Yes, that makes sense.

So putting this all together.

Wait, but first, the pattern must be defined. Let's set pattern = re.compile(r'#\w+').

Wait, but the problem may consider that the tags are words that start with # and are followed by non-whitespace characters. So maybe the regex should be r'#\S+'.

Hmm, perhaps the problem expects the tags to include any characters except whitespace. Let me think of an example. Suppose the text is "This has #tag and #another in a code block ```#ignore this``` and more #tags here." Then the code segments are the part between the triple backticks. So the non-code segments are the first part and the last part. The tags in non-code would be #tag, #another, and #tags. The code's #ignore is not counted. So the regex should capture those.

Using r'#\S+' would capture #tag, #another, #tags. So that's correct.

Wait, the regex r'#\S+' would match the # followed by any non-whitespace characters. So in the example, yes.

Alternatively, if a tag is like #hello-world, the regex would capture the entire #hello-world as a single tag. That's probably correct.

So I'll use pattern = re.compile(r'#\S+').

Wait, but in the problem's example, maybe the replacer is supposed to replace the entire tag. So that's okay.

So the code:

import re
from typing import Set, Tuple

def find_tags(text: str, replacer: callable = None) -> Tuple[Set, str]:
    pattern = re.compile(r'#\S+')
    segments = text.split('```')
    tags = set()
    new_segments = []
    for i, seg in enumerate(segments):
        if i % 2 == 0:  # non-code segment
            found = pattern.findall(seg)
            for t in found:
                tags.add(t)
            if replacer:
                new_seg = pattern.sub(lambda m: replacer(m.group()), seg)
            else:
                new_seg = seg
            new_segments.append(new_seg)
        else:  # code segment
            new_segments.append(seg)
    new_text = '```'.join(new_segments)
    return tags, new_text

Wait, but in the code above, when joining the new_segments with '```', that's correct because the split on '```' separated the text into parts, and the join puts them back with the delimiters in between.

Testing this code with an example.

Example 1:

text = "Check out #python and #javascript. In code block: ```#ignore #this``` and more #tags."

Processing:

segments after split on '```' are:

["Check out #python and #javascript. In code block: ", "#ignore #this", " and more #tags."]

Processing the first segment (index 0, non-code):

found tags are #python, #javascript. These are added to the set.

The new_seg is the same as the original (since replacer is None).

Second segment (index1, code) is added as is.

Third segment (index2, non-code):

found tags #tags. Added to set.

new_seg is same as original.

The new_text is:

segments[0] + '```' + segments[1] + '```' + segments[2]

Which is the original text. The tags set has {'#python', '#javascript', '#tags'}

That works.

Another test case with replacer:

Suppose replacer is a function that replaces #tag with [tag].

def replacer(tag):
    return f"[{tag[1:]}]"

Then, the text:

text = "Use #python and #java."

Processing:

segments split into ["Use #python and #java."]

so i=0, non-code.

found tags are #python, #java. added to set.

Then, new_seg is the result of replacing each tag with replacer's result.

For #python → [python], #java → [java].

so the new_seg becomes "Use [python] and [java]."

Thus the new_text is that string, and the tags set has both tags.

So that should work.

Now, what about overlapping code blocks?

Suppose text has triple backticks in odd numbers, like "start```middle```end```. Then the split would be ["start", "middle", "end", ""]. The last segment is index 3 (odd, code) but the next segment (index3 is code, but the next would be even, but there's only 4 segments. Hmm.

Wait, in that case, the code would handle it correctly. The last segment (index 3) is even or odd?

Wait, indexes start at 0. So for 4 segments, indexes 0,1,2,3.

Segments 0 (non-code), 1 (code), 2 (non-code), 3 (code).

So the third segment (index 2 is non-code, then index3 is code.

So in any case, the code correctly processes each segment.

What about empty segments?

Like text = "```" → split into ['', ''] → first segment index0 is non-code (empty string). Then the second segment (index1, code) is also empty.

Processing the first segment (empty) gives no tags, and new_seg is empty. The second is added as is.

The new_text would be '```.join(['', '']) → "" + '```' + "" → "```".

Which is correct.

Another case: text with no code blocks, so all is non-code.

text = "No code here, just #tags."

Then split into ["No code here, just #tags."], so index0 is non-code. The code processes the tags.

So that works.

Now, what about the regex?

Suppose a tag has other characters, like #hello-world. The regex r'#\S+' would match the entire #hello-world as one tag. That's correct.

Another case: # at the end of a line, like "end with #python " → the regex would capture #python.

Edge case: a # followed by a space, like "#python is cool". The regex would capture #python (since the next character is ' ', which is whitespace, so the \S+ stops there).

Wait, no. The regex is #\S+, so the # must be followed by at least one non-whitespace character. So in the case of "#python is cool", the first # is followed by 'python' (non-whitespace), so it's captured as #python. The next part is space, so that's the end of the tag.

So that's correct.

What about a lone # with no characters? Like "# is a start"?

The regex would not match because after the #, there's a space, so the \S+ is zero length. So the regex would not capture a # alone. That seems correct.

Thus the regex seems okay.

Now, the code uses the 'replacer' function correctly. The replacer is called with the matched string (the entire tag), so for example, in the replacer function, the argument is the entire string like '#python'.

Now, the function's return type is a tuple of Set and str. The code uses 'set' and the new_text as a string.

Wait, in the code above, the new_text is built as '```'.join(new_segments). Yes.

Thus, the code should work.

Now, I should check the code's edge cases.

Wait, in the code, the pattern is re.compile(r'#\S+'). But this will also match something like #123 or #_test, which might be acceptable.

Alternatively, perhaps the problem expects tags to be alphanumeric and underscores, but the problem's description doesn't specify, so the current regex is okay.

Thus, the code should be correct.
