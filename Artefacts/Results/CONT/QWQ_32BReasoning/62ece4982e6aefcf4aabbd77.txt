Okay, I need to write a Python function called parse_frequency that takes a frequency string and returns a timedelta. Let's see the requirements. 

First, if the input is None or "always" (case-sensitive?), return None. Wait the doc says if it's None or "always", so probably check exactly those. So first, check if frequency is None, return None. Then, if the string is "always" (case matters?), then also return None. 

Next, the function should parse a string like "3 timeunit" into a timedelta with the appropriate unit. The units must correspond to the arguments that timedelta accepts. Let me recall: timedelta can take days, seconds, microseconds, milliseconds, minutes, hours, weeks. So the valid timeunits here are those keywords. So the possible units in the input string must be one of those. 

So the steps would be: split the input string into two parts, number and unit. Split on whitespace. So split into parts = frequency.split(), then check if there are exactly two parts. If not, raise ValueError. 

Then, the first part must be a number. So try converting it to an integer. If that fails, raise ValueError. 

The second part is the unit. Check if it's one of the valid units for timedelta. Like, if the unit is 'days', 'hours', etc. But wait, the example in the doc says "timeunit" becomes the keyword argument. So for example, if the input is "5 days", then the timedelta is timedelta(days=5). Similarly, "2 hours" would be timedelta(hours=2). 

So the valid units are the keywords accepted by timedelta. So the possible units are: 'days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks'. So the second part of the split must be one of these. So if the unit is not in that list, raise ValueError. 

Putting this together:

First, handle the cases where to return None. 

Then split the string into two parts. If the split doesn't result in exactly two parts, error. 

Then check if the second part is a valid unit. 

Then create a dictionary with that unit as the key and the number as the value. 

Then pass that to timedelta using ** operator. 

Wait, but how to do that? Because the unit is a string, like 'days', so we can create a dictionary like {unit: number}, then use ** to unpack it. 

So, for example, if the parts are ["3", "days"], the dict is {'days':3}, then timedelta(**{'days':3}) would work. 

Yes. 

So steps in code:

def parse_frequency(frequency):
    if frequency is None or frequency.lower() == 'always':
        return None

Wait wait, the doc says "if the frequency is None or 'always'", so the check for 'always' is case-sensitive? The example given in the doc says the input is "3 timeunit", so the unit is given as a valid keyword. The 'always' case must be exactly "always" as a string. So the code should check if frequency == 'always', not case-insensitive. 

Wait the doc says: "If the frequency is None or 'always', return None." So the string must be exactly "always" (case-sensitive). So in code:

if frequency is None or frequency == 'always':
    return None

So that's the first check. 

Then split the input into parts. 

parts = frequency.split()
if len(parts) != 2:
    raise ValueError("Invalid frequency format")

Then, number_str, unit = parts. 

number = parts[0]
unit = parts[1]

Check if number is an integer. 

try:
    number = int(number)
except ValueError:
    raise ValueError("Number must be an integer")

Then check if unit is in the valid units. 

valid_units = {'days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks'}

if unit not in valid_units:
    raise ValueError(f"Invalid time unit: {unit}")

Then create the timedelta. 

So:

return timedelta(**{unit: number})

Putting it all together. 

Wait, but what about leading or trailing spaces? The split() will handle that because split() by default splits on any whitespace and ignores leading/trailing. So if the input is " 5 days " it will split into ["5", "days"], which is okay. 

Edge cases: What if the number is zero? The problem says to raise ValueError only if the frequency can't be parsed. So if the number is 0, but the unit is valid, then it's okay, but the timedelta would be zero. 

Another case: "5 Day" with uppercase. The unit must be exactly the keyword. So "day" is not a valid unit, but "days" is. Wait, the example in the doc says "timeunit", so the input's unit must be the exact keyword that timedelta expects. So "days" is correct, "day" would be invalid. 

So the code as above will handle that. 

Testing all the steps. 

Testing the case where frequency is "3 days" returns timedelta(days=3). 

What about "2 Hours"? The unit is "Hours" which is not lowercase. The valid units are in lowercase. So that would be invalid. So the input must have the unit in lowercase. 

The problem says "unit of time" but the example uses "timeunit" so the unit must be one of the valid keywords. 

Therefore, the code should work as written. 

Now, code structure:

Handle the None or 'always' case first. 

Then split into parts. Check parts length. 

Check number is integer. 

Check unit is valid. 

Then return the timedelta. 

Now code:

Wait, in the function, the return type is supposed to be a timedelta, but the docstring says @return str, the corresponding datetime. Wait, that seems like a mistake in the docstring. Wait looking back:

The user's docstring says:

"@return str, the corresponding datetime"

Wait that's probably a mistake. Because the function is supposed to return a timedelta instance. The user might have made an error in the docstring. But since the problem says to follow the function signature and docstring, perhaps the return is actually a timedelta. The function's doc says "return a corresponding datetime.timedelta instance". So the @return should be a timedelta. But the docstring in the problem has a typo. But the code should return the timedelta. 

So proceed accordingly. 

Putting it all into code:

Now code:

import datetime

def parse_frequency(frequency):
    if frequency is None or frequency == 'always':
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Invalid frequency format")
    try:
        number = int(parts[0])
    except ValueError:
        raise ValueError("Number must be an integer")
    unit = parts[1]
    valid_units = {'days', 'seconds', 'microseconds', 'milliseconds', 'minutes', 'hours', 'weeks'}
    if unit not in valid_units:
        raise ValueError(f"Invalid time unit: {unit}")
    return datetime.timedelta(**{unit: number})

Wait, but what about cases where the unit is something like 'seconds' but the number is too big? The timedelta can handle that, so the function doesn't need to check. 

Testing edge cases:

Test case 1: input is None → returns None. 

Test case 2: input is 'always' → returns None. 

Test case 3: input '5 days' → returns timedelta(days=5). 

Test case 4: input '3 hours' → okay. 

Test case 5: input 'invalid unit' → split into parts, but if the second part is not a valid unit, raise error. 

Test case 6: input '5' (only one part) → error. 

Test case 7: '5 days extra' → split into three parts → len(parts) is 3, so error. 

Test case 8: 'five days' → number is not integer → ValueError. 

Yes, this should work. 

Now, the code must be written exactly as per the instructions. The user says to output only the code in Python markdown format. Wait, the user's instruction says: "Output ONLY the code generated, in python markdown format." Wait, perhaps they mean to put the code in a code block, but the user also says to not include any markdown formatting. Wait, the initial instruction says "Do NOT include any explanation, reasoning, or markdown formatting. Output ONLY the code generated, in python markdown format."

Hmm, maybe they want the code enclosed in ```? Like:

```python
...code here...
```

But the user might be confused. Since the user says to output the code in Python markdown format, but without any markdown. But perhaps they want the code in a code block. So I'll present it as such.

Wait, but the user's example in the problem shows that when they say "Output ONLY the code generated, in python markdown format." they might mean to present the code in a code block using triple backticks. 

So the code would be enclosed in:

```python
def parse_frequency(frequency):
    ... rest of code ...
```

Yes, that's probably it. So the code needs to be in a code block with the python language specified. 

Therefore, the final code would be as written above, enclosed in the markdown code block.
