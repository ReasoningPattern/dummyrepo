Okay, I need to write a Python function called round_half_to_even that rounds a floating-point number. The docstring says to round according to the standard rules, but wait, the name suggests maybe using the round half to even method, which is actually the default rounding method in Python. Let me think.

Wait, Python's built-in round function already uses the round half to even strategy, also known as banker's rounding. So maybe the function is just supposed to be an alias for the regular round? But then why the specific name? Let me check.

The problem says to generate code based on the given signature and docstring. The docstring is brief: "Round a floating-point number". The function's name is round_half_to_even, so perhaps the user wants to make sure that it's using that method. Since Python's round does use that method, then the function can just call round with the same arguments. But wait, does round take into account the same parameters?

Wait, the function's parameter is n, a float. The standard round function rounds to the nearest integer when no second argument is given. So, the function should take a float and return the rounded integer using the half-to-even rule, which is exactly what round(n) does. Therefore, the code is straightforward: return round(n). 

Hmm, but let me test edge cases. For example, 2.5 should round to 2 or 3? Let's see. Using Python: round(2.5) is 2, and round(3.5) is 4? Wait, let me check in my head. The round function rounds to the nearest even integer when halfway between two integers. So 2.5 would round to 2 (even), 3.5 would round to 4 (even). So yes, the built-in function does that. Therefore the code is simply returning round(n). 

So the code would be:

def round_half_to_even(n):
    return round(n)

Wait, but maybe the problem expects more? Like handling some specific cases or different parameters? The function's signature only has n, so I think that's all. The docstring is simple. Alright, I think that's the correct approach.
