Okay, I need to write a Python function called subclasses that takes a class cls and returns all its subclasses, recursively. Hmm, how do I get all the subclasses in Python?

I remember that each class in Python has a __subclasses__() method which returns the direct subclasses. But the problem says recursively, so I need to collect all subclasses of those subclasses too.

So the approach should be to start with the direct subclasses of cls, then for each of those, recursively collect their subclasses as well. That sounds like a recursive function.

Wait, but I have to make sure there's no infinite loop. Like, if a subclass is part of a hierarchy that loops back, but since classes can't have circular subclass relationships, that's not possible. So I don't have to worry about that.

Let me think of the steps:

1. Initialize a list to hold all subclasses.
2. Get the direct subclasses using cls.__subclasses__().
3. For each direct subclass, add it to the list.
4. Then, recursively call the same function on each direct subclass to get their subclasses and add those to the list as well.
5. Return the accumulated list.

Wait, but when we add the subclasses recursively, we need to flatten the results or collect them all. Let me structure it properly.

Maybe something like this:

def subclasses(cls):
    subcls = cls.__subclasses__()
    all_subclasses = subcls.copy()  # Start with direct subclasses
    for s in subcls:
        all_subclasses.extend(subclasses(s))  # Recurse and add those
    return all_subclasses

Wait, but in Python, lists can be extended with the results of the recursive calls. However, this might not be the most efficient, but for the problem's sake, it's acceptable.

Wait, let me test this logic in my mind. Suppose a class A has B and C as direct subclasses. B has D and E. C has F. Then the function for A would first get [B, C], then for B, it would get [D, E], and their subclasses (none?), so adding those. For C, get [F]. So the total would be B, C, D, E, F. That seems right.

Wait, but in the code above, when you do all_subclasses = subcls.copy(), then for each s in subcls, you add their subclasses. So for B's case, the recursive call would return D and E and their subclasses. So the code would collect all in the list.

Wait, but in the code I wrote, the initial all_subclasses is the list of direct subclasses, then for each s in subcls (the direct ones), we add the result of subclasses(s), which includes all subclasses of s. So the total list would be the direct plus all the deeper ones. That should work.

Wait, but in Python, the __subclasses__() returns a list of immediate subclasses, so the code should work recursively.

Wait, but in the code above, the code would be:

Wait, the code would start with all_subclasses being the list from __subclasses__(). Then, for each s in that list, we get all subclasses of s (including their subclasses), and add them to the list. But that would include the direct subclasses again, right?

Wait no, let's see. Suppose A has B and C as direct. Then in the first step, all_subclasses is [B, C]. Then for s in [B, C], we get the subclasses of B (D, E) and their subclasses, which would be D's subclasses plus E's, etc. So when we add the result of subclasses(s), which for B would return [D, E, ... their subclasses...], those get added to all_subclasses. So the total list would be [B, C, D, E, ... etc.]. So the code is correct?

Wait, but in the code:

all_subclasses starts as a copy of subcls (the direct subclasses). Then for each s in subcls, we do all_subclasses.extend( subclasses(s) ). So the total list is the direct plus all the subclasses of the direct. That's exactly what we want. Because the subclasses of s include their own subclasses, so adding them all will collect everything.

Wait, but in that case, the code would return all the subclasses in a single list, including all levels. Let me test with an example.

Suppose A has B and C. B has D. D has E. Then:

subclasses(A) would first get subcls = [B, C].

all_subclasses starts as [B, C].

Then for s = B:

subclasses(B) is called. Its subcls is [D]. Then for D, we call subclasses(D), which has [E], and so on. The result for B would be [D, E] (assuming E has no subclasses). Wait, no, let's walk through step by step.

Let's see:

Starting with A:

subcls = [B, C]

all_subclasses = [B, C]

Then for s in [B, C]:

First s = B:

subclasses(B) is called. Its subcls is [D].

all_subclasses_B starts as [D].

Then for s in [D], call subclasses(D). D's subcls is [E].

all_subclasses_D starts as [E], then call subclasses(E). If E has none, then that returns empty list? Wait, no:

Wait, let's see the code again. Suppose in the function:

def subclasses(cls):
    subcls = cls.__subclasses__()
    all_subclasses = list(subcls)  # or .copy()
    for s in subcls:
        all_subclasses.extend(subclasses(s))
    return all_subclasses

Wait, in the case where a class has no subclasses, like E, then subcls would be empty. So the loop doesn't run, and the function returns an empty list. So when we get to D's case:

subclasses(D) would have subcls = [E], so all_subclasses starts as [E]. Then for s=E, call subclasses(E), which returns empty list. So the extend adds nothing. So the return is [E].

So back to B's case: the call to subclasses(B) would have:

subcls [D], so all_subclasses starts as [D], then for s=D, we call subclasses(D) which returns [E], so extend adds [E], so all_subclasses becomes [D, E]. So the return from B's call is [D, E].

Then back to the original loop in A's processing, after B, we add [D, E] to the all_subclasses of A. So after processing B, the A's all_subclasses is [B, C, D, E].

Then s=C. Suppose C has no subclasses. Then subclasses(C) returns empty. So adding nothing. So the total for A is [B, C, D, E].

Which is correct, since D and E are all the subclasses of A, including via inheritance.

Wait, but E is a subclass of D, which is a subclass of B, which is a subclass of A. So yes, E is a subclass of A. So the function returns all subclasses at all levels. So the code works?

Wait, but the code for the function returns all_subclasses which is the list of direct subclasses plus the recursive list. So the code is correct?

Hmm, I think so. Let me think of another case where a class has a subclass that has another, but the code should collect them all.

Another example: class Root, with Child1 and Child2. Child1 has Grandchild. Grandchild has Greatgrandchild.

Then the function called on Root would return [Child1, Child2, Grandchild, Greatgrandchild].

Testing the code:

First, Root's subcls is [Child1, Child2].

all_subclasses starts as [Child1, Child2].

Processing Child1: call subclasses(Child1). Its subcls is [Grandchild].

all_subclasses for Child1 starts as [Grandchild].

Then process Grandchild: call subclasses(Grandchild) which has [Greatgrandchild].

So the Grandchild's call would return [Greatgrandchild].

Thus, in Child1's processing, after the loop, the all_subclasses for Child1 is [Grandchild, Greatgrandchild].

So when we add those to the Root's all_subclasses, the list becomes Child1, Child2, Grandchild, Greatgrandchild.

Yes, that works.

Wait, but in the code, the initial all_subclasses for Root is [Child1, Child2], then for each of those, we add their subclasses. For Child1, its subclasses() returns [Grandchild, Greatgrandchild], so adding those to the Root's list. For Child2, if it has none, nothing added. So the total list is correct.

Therefore, the code seems correct.

Wait, but in the code, when we call all_subclasses.extend(subclasses(s)), the 'subclasses(s)' returns a list of all the subclasses of s, which are all the subclasses of the original class. So adding them all in extends the list correctly.

Yes, so the code should work.

Now, but in Python, the __subclasses__() method returns a list of immediate subclasses. So the code is correct.

Now, the problem says "Return all subclasses of a class, recursively". So the function should return a list of all classes that are subclasses of cls, including indirect ones.

Therefore, the code I wrote should be correct. Let me write it properly.

Wait, in Python, to make a copy of the list, because the __subclasses__() returns a list, but maybe we can just do list(subcls) or subcls.copy()? Well, in Python, list.copy() is a thing for lists. Alternatively, list(subcls) would also work.

Alternatively, all_subclasses = []

Wait, perhaps the code can be written as:

def subclasses(cls):
    subcls = cls.__subclasses__()
    all_subclasses = []
    for s in subcls:
        all_subclasses.append(s)
        all_subclasses.extend(subclasses(s))
    return all_subclasses

Wait, that might be better. Let's see:

In the first approach, the initial all_subclasses is the list of direct subclasses. Then, for each s in subcls, we add the result of subclasses(s). But that would add the entire list of s's subclasses, including s's direct subclasses again?

Wait, let me think again. Suppose in the first code example:

all_subclasses starts as subcls (direct), then for each s in subcls, we add the list from subclasses(s). The list from subclasses(s) includes all subclasses of s, so adding them all to the all_subclasses list would include those. So the total would be direct plus all the deeper ones.

But in the alternative code:

all_subclasses starts empty. For each s in subcls (direct), add s to the list, then add all of s's subclasses (recursively). So that would also include s plus their subclasses. So the total would be the same.

Wait, let's see with the first example.

First code version:

all_subclasses starts as [B, C].

Then, for B, we add the result of subclasses(B) which is [D, E], so the list becomes B, C, D, E.

Second code version:

all_subclasses starts as empty. For each s in [B, C], first s is B:

append B → list is [B]

then extend with subclasses(B), which returns [D, E], so list becomes [B, D, E].

Then next s is C:

append C → [B, D, E, C]

extend with subclasses(C) (empty), so remains same. So the total is [B, D, E, C].

Wait, but the order is different. But the problem doesn't specify order, so that's okay. The content is correct.

Hmm, so both approaches are correct, but the first code might have a different order. But the problem doesn't care about the order.

Wait, but in the first code, the order would be direct first, then their children. The second approach would have B, then D and E, then C. So the order is different, but the set is the same.

So which code is better?

The first code's approach might be more efficient? Not sure. But the code in the first approach is shorter.

Wait, in the first code, the initial all_subclasses is subcls.copy()? Or just list(subcls). Let me think of the first code again.

Wait, the first code as I had written earlier was:

def subclasses(cls):
    subcls = cls.__subclasses__()
    all_subclasses = subcls.copy()  # or list(subcls)
    for s in subcls:
        all_subclasses.extend(subclasses(s))
    return all_subclasses

Wait, in that case, the all_subclasses starts with the direct subclasses, then adds the subclasses of each direct. So for B's case, the subclasses(B) would be [D] + [subclasses(D)], which would be D and E. So when we add that to the all_subclasses for the original, it adds D and E. So the total list for the original would be B, C, D, E. The order is B, C, then D and E.

But the alternative approach where you build the list by adding each s and then their subclasses would also work.

I think the first approach is correct. Let me code it properly.

Wait, in Python, the list's copy() method is a thing, but maybe it's better to use list() constructor. Because for a list, list(subcls) creates a copy.

Alternatively, just using subcls would be a reference, but since we need to create a new list, we have to make a copy.

Wait, in the first code, the line:

all_subclasses = subcls.copy()

Yes, that's okay. So the code is as written.

Wait, but when I test with the first example, the first code's all_subclasses starts as [B, C], then adding the subclasses of B and C. For B's case, the subclasses(B) is [D, E], so adding those, so the total becomes [B, C, D, E].

Yes.

So that code should work.

Wait, but I should test for a class with no subclasses. Suppose cls has no subclasses. Then __subclasses__() returns an empty list, so all_subclasses is empty. Then the loop doesn't run, so returns empty list. Which is correct.

Another test: a class with one subclass which has none. Then the function returns the list with that subclass. Correct.

So the code should work.

Therefore, the code to write is:

def subclasses(cls):
    subcls = cls.__subclasses__()
    all_subclasses = list(subcls)
    for s in subcls:
        all_subclasses.extend(subclasses(s))
    return all_subclasses

Wait, using list(subcls) instead of copy(), which is perhaps more compatible? Because in some Python versions, maybe the list has a copy method? Probably yes, but list() is safer?

Alternatively, subcls.copy() would also work, but list() is a constructor.

Either way, the code works.

Hmm, okay, so that's the code. Let me make sure I didn't miss anything.

Another possible edge case: a class that has a subclass which is abstract, but in Python, that doesn't affect __subclasses__.

Yes, the code should work regardless.

So the final code is as above.
