Okay, I need to write a Python function called remove_ending_os_sep that takes an input list and returns a list with each string's trailing os separator removed. Let me think through this step by step.

First, the function's docstring says if the input is None, return an empty list. So the first thing I should check is whether input_list is None. If it is, return [].

Next, the function is supposed to iterate over each string in the list. For each string, I need to check two things: whether its length is greater than one (so that we don't process empty strings or single-character strings that might be the separator), and if the last character is the OS's path separator. 

Wait, the os module in Python has os.sep which gives the platform's separator. But maybe I should use pathlib's Path() methods? Hmm, no, the problem probably expects just using the os module's sep. Let me confirm: the standard approach is to check if the last character is os.sep. 

So for each string in the input list:

- If the string's length is 0, leave it as is.
- Else, check if the last character is os.sep. 
- If so, slice the string to exclude the last character. But also, need to ensure that the string isn't just a single separator. Wait, the problem says "if its length is greater than one and if the last character is the pathname separator." So the condition is: if len(s) > 1 and s[-1] == os.sep, then remove the last character.

Wait, the docstring says "Each string is tested if its length is greater than one and if the last character is the pathname separator." So even if the string is longer than one, but the last character is the separator. So for example, a string like "test/" would become "test", but "a/" (length 2) would become "a".

Wait, but what about a string like "a//"? The last character is a separator, so it would become "a/", but that's okay. The function only removes the trailing separator once. 

So the steps for each string:

Check if the string ends with os.sep and has length > 1. If so, strip the last character. Otherwise, leave it as is.

So, putting this into code:

First, import os? Wait, the function doesn't have an import, but in the code, I can use os.sep. So inside the function, we can use os.pathsep? Wait no, the os module's sep is the correct one here.

Wait, the problem mentions "pathname separator", so yes, that's os.sep.

So the code structure would be:

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    result = []
    for s in input_list:
        if len(s) > 1 and s[-1] == os.sep:
            # remove the last character
            s = s[:-1]
        result.append(s)
    return result

Wait, but what about cases where the string is exactly one character which is the separator? Like "/". The length is 1, so the condition would not trigger. So "/".strip(os.sep) would still be "", but according to the problem's condition, we don't process that. So the function leaves it as is.

Wait the problem says: "if its length is greater than one and if the last character is the pathname separator." So in the case of a single-character string (like "/"), since length is 1, we leave it as is. So the code above does that.

But what about empty strings? They just pass through. 

Wait, also, need to make sure that input_list is a list. The function's parameter is called input_list, so we can assume that it's a list. The function's first check is if input_list is None, then return empty list. Otherwise, proceed to loop over each element.

Wait, but what if the elements are not strings? The docstring says "Iterate over a string list" so the input is a list of strings. So we can safely process each element as a string.

Therefore, the code should be as above, but with the import of os. Wait, but the function can't have an import inside it. So the code must include an import os statement. Wait, but the user didn't mention any imports. The function's code needs to use os.sep, so the code must have an import statement for os.

Hmm, the problem says to generate Python code based on the signature and docstring, so the code should include the necessary imports. Let me check the problem's instruction again. The user says to output only the code, in Python markdown format. So I need to include the import statement.

Wait, but the function's code is part of a module. So the code would need to have:

import os

def remove_ending_os_sep(...):

So the code must start with that import. Otherwise, os.sep would be undefined. 

Therefore, the complete code is:

import os

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    result = []
    for s in input_list:
        if len(s) > 1 and s.endswith(os.sep):
            s = s[:-1]
        result.append(s)
    return result

Wait, alternatively, checking s[-1], but using endswith might be better. Wait, the code could use s.endswith(os.sep) which is equivalent. But for a single character check, either way is fine. Using endswith might be more readable. Let me see. The code I wrote earlier used s[-1] == os.sep, but endswith is perhaps better because it's clearer. 

Wait, but the condition requires that the length is greater than 1. So, in the code, I can write:

if len(s) > 1 and s.endswith(os.sep):

Wait, but if the string is exactly two characters, like "a/" — then endswith would be true, so we remove the last character, resulting in "a".

Yes. So that's correct.

Wait, perhaps using endswith is better because it's more explicit. 

Alternatively, maybe even for the case where the entire string is the separator, like "C:\\\" (on Windows, but that's a single backslash). Hmm, but the length check requires that the string is longer than 1. So "C:\\" would be length 2, so it would be processed. 

So the code is okay.

Wait, but in Python, strings can be of any length, so the code should handle all cases.

Another test case: input is None → returns empty list. 

Another case: input is ["test/"] → becomes ["test"]. 

["a/"] → becomes ["a"], ["a", "b/"] → ["a", "b"].

["/", "a//"] → the first is length 1, so stays as "/". The second is length 3 (assuming os.sep is "/"), so ends with "/", so becomes "a/".

Wait, but "a//" would be length 3 (assuming two slashes?), yes. So the code would leave it as "a/".

Hmm. That's correct according to the problem's conditions.

So the code looks correct. 

Wait, but in the code, the for loop is over input_list, but what if input_list is an empty list? Then the loop doesn't run, and returns empty list, which is correct.

Yes. So the code should work.
