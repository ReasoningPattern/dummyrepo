Okay, I need to write a Python function called parse_version that takes a string and returns a tuple of integers. The docstring says it converts a dot-concatenated string into a tuple of ints. 

Hmm, so the input is something like "1.2.3" and the output should be (1, 2, 3). Right. So first, I should split the string by dots. But wait, what if there are leading or trailing dots? Like "1.2.3." would split into ["1", "2", "3", ""], so I need to make sure to ignore empty strings?

Wait, the problem says "concatenated by dot", so maybe the input is properly formatted. But better safe to handle possible edge cases. Let me think. The function should split the input string by '.', then each part should be converted to an integer, and collect all into a tuple.

So steps:

1. Split the string s into parts using '.' as the delimiter.
2. For each part in the split result, convert to integer.
3. Return these as a tuple.

But what if a part is empty? Like if the input is "1.2." or ".3.4"? Then splitting would give parts like ["1", "2", ""], which would cause an error when converting to int. So I should filter out any empty strings.

Wait, the problem's example probably assumes that each part is a number. So the function should handle cases where there are parts like "0" or "abc"? Well, if a part can't be converted to an int, like if the input is "1.2.3a", then splitting gives "3a", which would throw a ValueError. So the function's docstring doesn't mention error handling. So perhaps the input is always a valid version string, where each part is numeric.

Therefore, the code can proceed by splitting on '.', then mapping each part to int, then making a tuple.

So code steps:

def parse_version(s):
    parts = s.split('.')
    numbers = [int(part) for part in parts]
    return tuple(numbers)

But wait, what about leading or trailing dots? Like "1.2.3." would split into ["1", "2", "3", ""], the last part is empty. So in that case, the code would try to convert "" to int, which would fail. So the function should probably ignore empty parts. So maybe add a filter to exclude empty strings.

So modifying the code:

parts = [part for part in s.split('.') if part]

That way, any empty strings from split are removed. So for "1.2.", splitting would give ["1", "2"], and the empty part is excluded. Similarly, leading dots like ".1.2" would split into ['', '1', '2'] and after filtering becomes ['1', '2'].

But the problem's docstring says "converts a string concatenated by dot to a tuple of integers." Maybe the input is such that each part is non-empty and a valid integer. But adding the filter would make it more robust, perhaps as per the problem's requirement.

Alternatively, maybe the input is like "1.2.3" so splitting gives three parts, all non-empty. So the code may work without the filter. But better to include it to handle edge cases.

So the code should be:

def parse_version(s: str) -> tuple[int, ...]:
    parts = s.split('.')
    parts = filter(None, parts)  # remove empty strings
    return tuple(int(p) for p in parts)

Wait, using a generator expression. Alternatively:

def parse_version(s: str) -> tuple[int, ...]:
    return tuple(int(part) for part in s.split('.') if part)

Yes, that's even better. So splitting into parts, then for each part that is not an empty string, convert to int and make a tuple.

This way, any empty parts are skipped. So that handles cases with multiple dots or leading/trailing dots.

Testing examples:

parse_version("1.2.3") → (1,2,3)

parse_version("0.12.34.5") → (0,12,34,5)

parse_version("1.2.3.") → (1,2,3)

parse_version(".42") → (42) ?

Wait, no. Let's see: the input ".42" would split into ['', '42'], then after the if part: the first part is empty, so only '42' is taken. So the result would be (42,). But the original string is ".42", which may not be intended. But according to the problem's description, perhaps the function is supposed to process such cases. Since the problem didn't specify, but the code as written would handle it.

Another test case: "abc.12" would cause an error because 'abc' can't be converted to int. But the function's docstring doesn't mention handling invalid inputs, so it's up to the user to provide valid strings. So the code is correct as per the problem's requirements.

So the final code is as above. Let me check again. The function's return type is a tuple of ints, and the code uses a generator expression converting each part to int. The split is done, and parts are filtered to exclude empty strings. So that's the code.
