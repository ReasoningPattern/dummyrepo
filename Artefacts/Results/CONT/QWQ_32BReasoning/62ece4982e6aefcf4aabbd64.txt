Okay, I need to write a Python function called strip_root that takes a path and a root, and removes the root from the path. If it can't do that, it should throw an exception. Let me think about how to approach this.

First, I remember that in Python, the os.path module has functions for manipulating paths. Maybe os.path.relpath could be useful here? Wait, but relpath gives the relative path from start, so if the path starts with root, it would return the relative path. But I have to make sure that the root is indeed the starting point of the path. If not, then relpath might not work as expected, or could return a path that starts with "..", which would indicate that the path is outside the root. In that case, we should raise an exception.

Alternatively, maybe using os.path.commonprefix to check if the root is actually a prefix of the path. Let me think. Let's see: the idea is that if the path starts with the root, then we can strip it off. But we have to be careful with the trailing slashes. For example, if the root is "/home/user/" and the path is "/home/user/Desktop", then the common prefix is "/home/user/", so stripping that would leave "Desktop". But if the root is "/home/user" (without the trailing slash), then the common prefix would be "/home/user", so the path after would be "/Desktop"? Wait no, the path is "/home/user/Desktop", so the root is exactly the prefix. So maybe we need to handle cases where the root ends with a slash or not.

Hmm, maybe the best approach is to use the os.path module's functions to handle this properly. Let me think again.

Another approach is to use the pathlib module, which is more modern. Using Path objects might make this easier. Let me see: if I convert both path and root to Path objects, then check if the path is relative to the root. The Path class has a method called is_relative_to, which can check that. For example, if path is "/home/user/Desktop" and root is "/home/user", then path.is_relative_to(root) would return True. Then, subtracting the root from the path would give the relative path.

Wait, but how to actually get the stripped path. Let's see, in pathlib, if you have a Path object, you can use the relative_to method. So path.relative_to(root) would give the path without the root. That's exactly what we need. However, if the path is not actually under the root, then this method throws a ValueError. Perfect! So the function can be written using pathlib.

So the steps would be:

1. Convert both path and root to Path objects.
2. Check if the path is relative to the root. If not, raise ValueError.
3. If yes, return the relative path as a string.

Wait, but the function's docstring says to return a path without the root, and throw an exception if it fails. So using Path.relative_to would do exactly that. So the code could be something like:

from pathlib import Path

def strip_root(path, root):
    p = Path(path)
    r = Path(root)
    try:
        return str(p.relative_to(r))
    except ValueError:
        raise ValueError("Path is not under the root")

Wait, but the problem says to throw an exception if it fails. The except block can just re-raise with an appropriate message. That should work.

But what about different operating systems? The Path module should handle the path separators correctly. Also, need to make sure that leading slashes are handled properly. For example, if the path is absolute and the root is also absolute.

Another consideration: the root might have a trailing slash, but that shouldn't matter because the Path object would handle that. Because Path("/home/user/") and Path("/home/user") are the same when used in relative_to.

Wait, let me test in my mind. Suppose root is "/home/user/", and path is "/home/user/Desktop". Then p.relative_to(r) would return "Desktop". If the root was without the trailing slash, same result. So that's okay.

Another case: if the path is exactly the root. For example, path is "/home/user", and root is "/home/user". Then the relative path would be empty. But in some cases, maybe that's acceptable. The function's docstring says to return a path without the root. So the empty string would be the result. But perhaps the function expects that, so it's okay.

What about if the path is a subdirectory deeper? Like path is "/home/user/projects/code.py", and root is "/home/user", then the relative path would be "projects/code.py".

So using the Path approach seems solid.

Now, the function's parameters are path and root, which are strings. The code would need to import Path from pathlib. Also, the exception message should probably be as specified? The docstring says to throw an exception if it fails. The default ValueError from Path.relative_to is appropriate, but maybe we can re-raise with a more specific message.

Wait, the problem says to "throw exception" but doesn't specify which one. The ValueError is okay, but perhaps we should re-raise with a custom message. Let me check the problem again.

The docstring says: "If fails, throw exception". So as long as an exception is thrown when the root isn't a prefix, it's okay. The exact type and message can be left as per the underlying method, but perhaps the problem expects a ValueError. Since the code uses the try-except to catch the ValueError and re-raise with a message, maybe it's better to do that. Alternatively, maybe just let the original exception propagate. Wait, the original exception's message might not be user-friendly. For example, on Windows, the error might be because of case sensitivity or different drive letters, but the problem probably assumes that the paths are correctly given. Let me see the exact error message from Path.relative_to when the path isn't under the root. For example, in Linux, if path is '/a/b' and root is '/c', then the error is "cannot represent '/a/b' relative to '/c'".

So the error message might be okay, but the problem says to throw an exception. So wrapping it in a ValueError with a custom message like "Path is not under the root" would be better. Alternatively, maybe the problem expects a specific exception. Since the docstring doesn't specify, perhaps it's okay to just let the ValueError from Path.relative_to be raised. But the problem says "throw exception" so perhaps the code should raise a ValueError with a message.

Alternatively, perhaps the code can just return the relative_to result and let the exception propagate. Because the function's docstring says to throw if it fails, and the exception raised by Path.relative_to is exactly that case, so perhaps no need to wrap it. Let me see:

def strip_root(path, root):
    from pathlib import Path
    p = Path(path)
    r = Path(root)
    return str(p.relative_to(r))

But then, when the path is not under the root, it would raise ValueError, which meets the requirement. So maybe that's sufficient. However, the problem's docstring says "throws exception", but the exact type isn't specified. So this code would work, but perhaps the problem expects a more specific message. Since the user's example in the function's docstring doesn't specify, maybe it's okay.

Wait, but in some cases, the root might be an empty string, or the path is a symbolic link. But the problem probably expects a straightforward solution. So the code using pathlib's Path.relative_to is the way to go.

Now, the code must be written without any markdown or explanations, just the code in a Python code block. Also, the function must be named strip_root, with the parameters path and root. Let me structure the code:

First, import the necessary modules. Since we need Path from pathlib, so:

from pathlib import Path

def strip_root(path, root):
    p = Path(path)
    r = Path(root)
    try:
        return str(p.relative_to(r))
    except ValueError:
        raise ValueError(f"Path {path!r} is not under the root {root!r}")

Wait, but maybe the problem expects the exception to be raised without any wrapping. Let me think again. The original code could just call p.relative_to(r), and let the exception propagate. The ValueError's message might be sufficient. But the problem's example might expect a more user-friendly message. However, the problem's docstring does not specify, so perhaps the minimal solution is better.

Alternatively, perhaps the problem expects the code to handle the case where the root is not the actual prefix, using some other method. Like splitting the path and root into components and checking if they match.

Another approach without pathlib: using os.path.commonprefix, but that might not be reliable because commonprefix returns the longest common prefix, which may not be a directory boundary. For example, if the root is '/home/user' and the path is '/home/userx/something', the commonprefix would be '/home/user', but the path isn't actually under the root. So that approach is flawed. Hence, using the pathlib method is better.

Therefore, the code using Path.relative_to is correct. So the code would be:

from pathlib import Path

def strip_root(path, root):
    p = Path(path)
    r = Path(root)
    return str(p.relative_to(r))

But then, when the path is not under the root, it raises ValueError, which is exactly what the problem requires. So this code would work, except that in the case where the root is the same as the drive on Windows, but I think Path handles that. For example, on Windows, if the root is 'C:\\' and the path is 'C:\\file.txt', then relative_to would return 'file.txt'. If the root is 'C:\\dir' and the path is 'C:\\file.txt', it would raise ValueError.

So this code should work. But perhaps the problem expects the exception to be raised with a custom message. Let me check the problem's docstring again. The function's docstring says "If fails, throw exception". The return says "Returns a path without root". So the code as written would return the correct path when possible, and raise ValueError otherwise. That meets the requirements. So I think this is the correct approach.

Therefore, the code is as above. But wait, in the problem's function signature, the return is stated, but the parameters are path and root. So the code is correct.

Wait, but the problem's function's docstring says "Remove root from path. If fails, throw exception". So the code uses Path.relative_to, which does exactly that. So the code is okay.

So putting it all together:

The code would be:

from pathlib import Path

def strip_root(path, root):
    p = Path(path)
    r = Path(root)
    return str(p.relative_to(r))

But I should make sure that the code is properly formatted. Let me check again. Also, the user said to output only the code in Python markdown format, which would be enclosed in triple backticks. Wait, the user's instruction says: "Output ONLY the code generated, in python markdown format." So perhaps like:

```python
from pathlib import Path

def strip_root(path, root):
    p = Path(path)
    r = Path(root)
    return str(p.relative_to(r))
```

Yes, that's the code. I think that's the correct solution.
