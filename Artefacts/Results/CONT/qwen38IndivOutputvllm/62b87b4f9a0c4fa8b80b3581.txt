

```python
def scale(self, other=None, recompute=False):
    """
    Compute or set scale (integral of the histogram).

    If *other* is ``None``, return scale of this histogram.
    If its scale was not computed before,
    it is computed and stored for subsequent use
    (unless explicitly asked to *recompute*).
    Note that after changing (filling) the histogram
    one must explicitly recompute the scale
    if it was computed before.

    If a float *other* is provided, rescale self to *other*.

    Histograms with scale equal to zero can't be rescaled.
    :exc:`.LenaValueError` is raised if one tries to do that.
    """
    if other is None:
        if recompute or self._scale is None:
            widths = [self.edges[d][1:] - self.edges[d][:-1] for d in range(self.dim)]
            product_of_widths = 1.0
            for d in range(self.dim):
                product_of_widths *= widths[d]
            self._scale = np.sum(self.bins * product_of_widths)
        return self._scale
    else:
        if self._scale is None:
            widths = [self.edges[d][1:] - self.edges[d][:-1] for d in range(self.dim)]
            product_of_widths = 1.0
            for d in range(self.dim):
                product_of_widths *= widths[d]
            self._scale = np.sum(self.bins * product_of_widths)
        if self._scale == 0:
            raise lena.LenaValueError("Cannot rescale histogram with zero scale.")
        scaling_factor = other / self._scale
        self.bins *= scaling_factor
        self._scale = other
```