class Histogram:
    def __init__(self, edges, bins, initial_value):
        self.edges = edges
        self.bins = bins
        self._scale = initial_value

    def scale(self, other=None, recompute=False):
        """
        Compute or set scale (integral of the histogram).

        If *other* is ``None``, return scale of this histogram.
        If its scale was not computed before, it is computed and stored for subsequent use
        (unless explicitly asked to *recompute*).
        Note that after changing (filling) the histogram, one must explicitly recompute the scale
        if it was computed before.

        If a float *other* is provided, rescale self to *other*.

        Histograms with scale equal to zero can't be rescaled. :exc:`.LenaValueError` is raised if
        one tries to do that.
        """
        if other is None:
            if self._scale is None:
                self._compute_scale()
            return self._scale
        elif isinstance(other, float):
            if self._scale is not None:
                if recompute:
                    self._compute_scale()
                else:
                    raise LenaValueError("Cannot rescale without recomputing the scale.")
            self._scale = other
        else:
            raise TypeError("Other must be None or a float.")

    def _compute_scale(self):
        scale = 0.0
        for i, (edges, values) in enumerate(zip(self.edges, self.bins)):
            for bin_index in range(len(values)):
                bin_val = values[bin_index]
                if bin_val == 0:
                    continue
                volume = 1.0
                for j in range(len(edges) - 1):
                    volume *= (edges[j+1] - edges[j])
                scale += bin_val * volume
        self._scale = scale