Okay, I need to generate Python code based on the given function signature and docstring. The function is called isoparse and it's part of a class. The function parses an ISO-8601 datetime string into a datetime.datetime object.

First, I'll look at the docstring to understand the requirements. The function supports both date and time portions, separated by 'T'. The date can be in various formats like YYYY, YYYY-MM, YYYYMM, etc. The time has similar formats, including seconds and up to six sub-second digits. The separators for date and time can be either '-' or 'T' for date and ':' or 'T' for time, but wait, no—the date and time are separated by 'T', so the date part can end with either '-' or 'MM' as separators.

Wait, the date portion can have separators as '-', '_', '.', or nothing. For example, YYYY-MM, YYYYMM, YYYY-MM-DD, YYYYMMDD. The time portion can have separators as '-', '_', '.', or nothing, like hh, hh:mm, etc.

The function needs to handle both common and uncommon date formats. For the uncommon ones, like YYYY-Www or YYYYWww for ISO week, and YYYY-Www-D or YYYYWwwD for week and day.

For the time portion, it supports up to six sub-second digits, so the regex should account for that. The time can be in formats like hh, hh:mm, hh:mm:ss, etc., with optional sub-second precision.

The function should parse the string into a datetime object, handling midnight as both 00:00 and 24:00. The decimal separator can be a dot or comma.

The docstring also mentions that the function is part of a class, so I'll need to include the self parameter. The function should handle both strings and streams, but in the code, I'll focus on the string case as per the signature.

Looking at the imports, I see functools, re, calendar, datetime, six are imported. So I'll need to use regular expressions for parsing. The function will split the string into date and time parts using 'T' as the separator.

I should split the string into two parts: date_str and time_str. Then, parse each part separately. For the date_str, I'll try different patterns to match common and uncommon date formats. Similarly, for time_str, I'll use patterns that match the supported time formats.

I'll need to handle cases where the date or time part might be missing. For example, if only a date is present, the time part is considered as midnight.

I'll also need to handle the separators in the date and time parts. For the date, the separator can be '-' or '_', and for the time, it can be ':' or '.'.

Wait, no—the separators are the same for both date and time. The 'T' is the separator between date and time. So, in the date_str, the separators can be '-', '_', '.', or nothing. Similarly for time_str.

I'll use regular expressions to capture these parts. For the date, the pattern could be something like (\d{4})([-_.]?\d{2})? etc., but I need to cover all common and uncommon formats.

Similarly, for the time, the pattern should capture hh, hh:mm, etc., with optional sub-second digits.

Once the date and time are parsed into their components, I'll create datetime objects. For the date, I'll use dateutil's parser, and for the time, I'll use datetime's parser.

I also need to handle the case where the string doesn't have enough components. For example, if the date part is just '2023' and the time part is missing, the time should default to midnight.

Additionally, the function should handle the decimal separator correctly, whether it's a dot or comma.

I think I should split the string into date and time using 'T' as the separator. Then, for each part, use regex to extract the components.

For the date part, the regex should handle YYYY, YYYY-MM, YYYYMM, YYYY-MM-DD, YYYYMMDD, YYYY-Www, YYYYWww, etc. Similarly, for the time part, it should handle hh, hh:mm, hh:mm:ss, etc.

Once the components are extracted, I'll parse them into date and time objects, then combine them into a datetime object.

I also need to handle the case where the string is in a format that's not recognized, but according to the docstring, the function should handle valid strings correctly with default settings.

Putting it all together, the code will split the string, parse each part, and then create a datetime object. I'll use the dateutil's parser for the date and time parts to handle the ISO formats.

I think I should import dateutil's parser functions. Wait, the imports include dateutil.tz, but not the parser. So I'll need to import dateutil.parser as well.

Wait, the context shows that within the class, there are methods like _parse_isoweekday, _parse_isocalendar, etc. So perhaps the date parsing is done using dateutil's parser.

So, in the code, after splitting into date_str and time_str, I'll parse each part using dateutil.parser.parse, which can handle the ISO formats.

But wait, the docstring mentions that the function should handle midnight as 00:00 or 24:00. The parse function should handle that correctly.

Also, the decimal separator can be a dot or comma, so the parse function should handle that.

I think the code will be something like:

import re
from dateutil.parser import parse as dateparse
from dateutil.parser import parse as timeparse

def isoparse(self, dt_str):
    sep = self._sep
    date_str, time_str = dt_str.split(sep)
    date_str = date_str.strip()
    time_str = time_str.strip()
    
    # Parse date
    date_format = self._parse_isodate_uncommon(date_str)
    date = dateparse(date_str, dayfirst=False)
    
    # Parse time
    time_format = self._parse_isotime(time_str)
    time = timeparse(time_str, dayfirst=False)
    
    # Combine
    return self.datetime.combine(date, time)

Wait, but the function is part of a class, so perhaps the date and time parsing are handled by methods in the class. The context shows that there are methods like _parse_isodalate_uncommon and _parse_isotime.

So, perhaps the code should extract the date and time parts, then call the appropriate parsing methods.

Alternatively, the code can split the string, then use regex to parse each part into their components, then create date and time objects.

But considering the complexity, perhaps using dateutil's parser is the way to go, as it's designed to handle ISO formats.

So, the code will split the string into date_str and time_str, then parse each using dateutil.parser.parse, ensuring that the correct formats are handled.

I think the final code will look something like this, using the dateutil parser for both date and time parts.
