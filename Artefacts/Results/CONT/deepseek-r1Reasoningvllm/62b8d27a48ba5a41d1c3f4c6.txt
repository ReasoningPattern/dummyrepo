Okay, I need to generate Python code based on the given function signature and docstring. The function is called 'cached' and it's supposed to return a decorator that saves results in a cache. Let me think about how to approach this.

First, the function signature is def cached(cache, key=hashkey, lock=None):. So, it takes three arguments: a cache, a key function (defaulting to hashkey), and a lock (defaulting to None). The docstring says it's a decorator that saves results in the cache.

I remember that in Python, a decorator can be a function that returns another function. So, the 'cached' function should return a decorator. The decorator will likely check if the result is in the cache, compute it if not, store it, and then return the result.

I should probably use the functools module, maybe a wraps decorator to preserve the original function's metadata. Wait, but in the context, it's mentioned that functools are imported, so I can use that.

Let me outline the steps the decorator should take:

1. When decorating a function, the returned decorator will wrap the function.
2. For each call to the decorated function, check if the result is already in the cache.
3. If it is, return the cached result.
4. If not, compute the result, store it in the cache, then return it.

So, the decorator inside 'cached' should do this. Let's think about how to structure it.

The 'cached' function returns a decorator, which is a function that takes a function 'func' and returns a new function that wraps 'func'. Inside this wrapper, for each call, it checks the cache.

Wait, but in the code I wrote earlier, I used a helper function 'save_in_cache' as the decorator. That's a good approach because it's reusable. So, the 'cached' function returns this helper, which does the actual caching logic.

Now, the 'save_in_cache' function needs to use the 'cache' provided, the 'key' function to generate the key, and the 'lock' to manage concurrent access.

I should import threading or something if I need a lock, but since the context says 'lock=None', maybe it's None by default, so no lock is used unless provided.

Wait, in the initial code I wrote, I used 'Lock' from threading. But the context doesn't specify any imports, so I need to make sure that the necessary modules are imported. However, the user said not to include any explanation or markdown, just the code. So, I should include the necessary imports if they are not already present.

Wait, the imports are in the context: 'imported Packages: functools'. So, I can assume that functools is available, but I might need to import threading for the Lock.

Hmm, but in the code I wrote, I used 'from threading import Lock' and then 'if lock is not None: lock.lock() ...'. So, I should include that import.

Wait, but the user didn't mention any imports in the context beyond 'functools'. So, I should add the necessary imports at the top of the code.

Putting it all together, the code should:

- Import functools and threading.
- Define the cached function that takes cache, key, and lock.
- Return a decorator that wraps the function.
- Inside the decorator, generate the key using the provided key function.
- Check if the result is in the cache.
- If not, compute it, store it, and return it.

I think the code I wrote earlier is correct. Let me double-check.

The 'cached' function returns 'save_in_cache', which is a decorator. The 'save_in_cache' function checks if the result is in the cache using 'get' with a default. If not, it computes the result, calls 'func', then stores it using 'lock.lock()' if provided. Then it returns the result.

Yes, that seems right. I should make sure that the code is properly indented and that all necessary imports are included.

Wait, in the code I wrote, I used 'from functools import wraps' to preserve the function's name in the logs. That's a good practice. So, I should include that import as well.

So, putting it all together, the code includes the necessary imports, defines the 'cached' function, and returns the decorator that handles caching.
