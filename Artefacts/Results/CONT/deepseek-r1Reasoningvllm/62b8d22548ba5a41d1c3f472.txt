Alright, I need to write a Python function called cachedmethod. The function should return a decorator that checks a cache and calls the result if it exists. Let me think about how to structure this.

First, the function signature is given: def cachedmethod(cache, key=hashkey, lock=None). So, it takes a cache, a key function with a default, and an optional lock.

The docstring says it returns a decorator function. So, cachedmethod is a higher-order function that takes these parameters and returns another function, which will be the decorator.

The decorator is used to wrap a method. So, when the decorator is applied, it should replace the method with a cached version.

Inside the decorator, when the method is called, it should check if the result is in the cache. If it is, return it. If not, compute the result, store it in the cache, and then return it.

I need to handle the key parameter. The default is hashkey, which I assume is a helper function to generate the cache key. The lock parameter is for thread safety, so it's optional.

So, the steps are:

1. The decorator function takes the method as an argument.
2. It checks if the method is already decorated; if so, return it.
3. When the method is called, generate the cache key using the key function and lock if necessary.
4. If the key exists in the cache, return the cached value.
5. If not, call the method, store the result in the cache, and return the result.

I should use weakref to handle the method closure correctly. Also, using a threading.Lock will ensure thread safety when accessing the cache.

Wait, but in Python, using a lock around the cache operations is necessary to prevent race conditions. So, I'll import weakref and threading, and lock the cache access with the provided lock.

Putting it all together, the decorator will look like this. It will wrap the method, and when called, it will check the cache, compute if necessary, and store the result.

I should also handle cases where the method doesn't exist or the cache isn't present, but I think the decorator will be used within a class, so the method exists.

Testing this, if I have a class with a method decorated with @cachedmethod, calling the method should return the cached value if available, else compute and store.

I think that's the plan. Now, I'll write the code accordingly.
