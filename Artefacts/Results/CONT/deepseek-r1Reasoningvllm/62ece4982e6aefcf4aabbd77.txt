Okay, I need to write a Python function called parse_frequency that takes a frequency string and returns a datetime.timedelta instance. Let me think about how to approach this.

First, the function should check if the frequency is None or "always". If so, it returns None. Otherwise, it should parse the string into a number and a unit, then create a timedelta with that.

I remember that the datetime module in Python has a strptime function, but maybe I should use the timedelta constructor instead. Wait, no, the timedelta constructor doesn't take a string format like strptime does. So perhaps I should parse the string using strftime or another method.

Wait, maybe using the strptime method with a custom format string would work. I'll need to split the input string into the number and the unit. So first, I'll check if the frequency is None or "always", and handle those cases.

For other cases, I'll split the string into parts. The first part is the number, which can be converted to an integer. The second part is the unit, which should be one of 'minute', 'hour', etc. I'll need to create a format string that matches these units.

For example, if the unit is 'minute', the format string would be '%M'. If it's 'hour', it's '%H', and so on. So I can create a dictionary mapping units to their respective format specifiers.

Once I have the number and the unit, I'll format the string using the appropriate specifier. Then, I'll try to create a timedelta from that formatted string. If it raises a ValueError, I'll raise my own ValueError with a message indicating the invalid unit.

Wait, but what if the unit is something else, like 'second'? I should handle all valid time units that strftime supports. So I'll include all possible units in the mapping.

Putting it all together, the function will:

1. Check if frequency is None or "always" and return None or raise an error? Wait, the docstring says to return None if the frequency is None or "always". So I should return None in those cases.

2. Split the frequency string into parts. If it can't be split into exactly two parts, raise ValueError.

3. Convert the first part to an integer. If it's not a valid integer, raise ValueError.

4. Map the second part to the corresponding format specifier.

5. Format the string using strftime with that specifier.

6. Attempt to create a timedelta from the formatted string. If it fails, raise ValueError.

Let me test this logic with an example. Suppose frequency is "3 minute". Split into '3' and 'minute'. The format string becomes '%M', so '3 minute' becomes '3' with the minute format. Wait, no, the formatted string would be '3', but using %M would require it to be a two-digit number. Oh, that's a problem. So if the number is a single digit, it might not format correctly.

Wait, actually, when using strptime, if the format is incorrect, it raises a ValueError. But in this case, I'm using strftime on the original string, which might not be correct. Maybe I should use strptime instead.

Hmm, perhaps I should use the strptime method with the correct format. So, for example, if the unit is 'minute', the format string is '%M'. So I can do something like datetime.datetime.strptime(freq_str, format_str).timedelta seconds.

Wait, no. strptime returns a datetime object, and then I can't directly get a timedelta. Maybe I should use the timedelta constructor with the parameters extracted.

Alternatively, perhaps I can split the string, get the number and unit, then create a datetime.timedelta with days, seconds, etc., based on the unit.

Wait, maybe I should use the parameters of timedelta to set the appropriate value. For example, if the unit is 'minute', set seconds to number * 60. But that might complicate things.

Alternatively, using the strptime method with the correct format and then extracting the seconds, minutes, etc., from the resulting datetime object. But then I have to calculate the total seconds or similar.

Wait, perhaps the simplest way is to use the strptime method with the correct format, then create a timedelta based on that datetime. But that might not be efficient, especially for multiple calls.

Wait, maybe I can use the fact that the timedelta can be created by providing the number of seconds, etc., based on the unit. So for example, if the unit is 'minute', I can convert the number to seconds by multiplying by 60.

Let me think about the steps again:

- If frequency is None or "always", return None.

- Else, split the string into parts. If it doesn't split into exactly two parts, raise ValueError.

- The first part is the count, which should be an integer. If it's not, raise ValueError.

- The second part is the unit. Map this to the corresponding number of seconds.

- Then, create a timedelta with the appropriate attribute (days, seconds, etc.) based on the unit.

So for example:

unit to seconds:
- 'minute' = 60
- 'hour' = 3600
- 'day' = 86400
- 'week' = 604800
- 'year' = 31536000

Wait, but 'year' is a larger unit and might not be commonly used. Also, 'week' is 7 days.

So, I'll create a dictionary mapping units to their respective seconds.

Then, based on the unit, set the timedelta's attribute accordingly.

But how to handle this in code? Maybe using getattr with default.

Wait, perhaps I can create a dictionary that maps units to the corresponding attribute of timedelta.

For example:

unit_map = {
    'minute': 'minutes',
    'hour': 'hours',
    'day': 'days',
    'week': 'weeks',
    'year': 'years'
}

But wait, 'minute' is 60 seconds, so the 'minutes' attribute is the count multiplied by 60. Similarly, 'hour' is 3600 seconds, so 'hours' attribute is count * 3600, etc.

So, in code:

if unit is in unit_map:
    attr = unit_map[unit]
    value = getattr(timedelta, attr)
    setattr(timedelta, attr, number * unit_to_seconds[unit])

Wait, perhaps a better approach is to calculate the total seconds and then set the timedelta's seconds attribute.

Alternatively, create a timedelta with days, seconds, etc., based on the unit.

Wait, perhaps I can do something like this:

if unit == 'minute':
    total_seconds = number * 60
    td = datetime.timedelta(seconds=total_seconds)
elif unit == 'hour':
    total_seconds = number * 3600
    td = datetime.timedelta(seconds=total_seconds)
else:
    # handle other units similarly

But that's a lot of if-elif statements. Maybe a better way is to use a dictionary to map units to their conversion function.

Alternatively, create a dictionary that maps each unit to the number of seconds, then calculate the total seconds and set the timedelta's seconds attribute.

So, let's create a dictionary:

unit_to_seconds = {
    'minute': 60,
    'hour': 3600,
    'day': 86400,
    'week': 604800,
    'year': 31536000
}

Then, total_seconds = number * unit_to_seconds[unit]

td = datetime.timedelta(seconds=total_seconds)

Yes, that seems manageable.

So putting it all together:

def parse_frequency(frequency):
    if frequency is None or frequency == "always":
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Invalid frequency format")
    try:
        number = int(parts[0])
    except ValueError:
        raise ValueError(f"Invalid number: {parts[0]}")
    unit = parts[1]
    if unit not in unit_to_seconds:
        raise ValueError(f"Invalid unit: {unit}")
    total_seconds = number * unit_to_seconds[unit]
    return datetime.timedelta(seconds=total_seconds)

Wait, but I need to define unit_to_seconds inside the function or as a local variable.

Alternatively, define it inside the function.

But wait, in the code, I can't have the unit_to_seconds defined outside the function. So I'll define it inside the function.

Wait, but in the initial code, the user didn't include any imports, but I know that the datetime module is imported.

So the code will be:

def parse_frequency(frequency):
    if frequency is None or frequency == "always":
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Frequency string must be 'number unit'")
    try:
        number = int(parts[0])
    except ValueError:
        raise ValueError(f"Invalid number: {parts[0]}")
    unit = parts[1]
    unit_to_seconds = {
        'minute': 60,
        'hour': 3600,
        'day': 86400,
        'week': 604800,
        'year': 31536000
    }
    if unit not in unit_to_seconds:
        raise ValueError(f"Invalid unit: {unit}")
    total_seconds = number * unit_to_seconds[unit]
    return datetime.timedelta(seconds=total_seconds)

Wait, but what if the unit is lowercase, like 'minute'? The split will get 'minute' correctly. But what if the user passes 'Minute' with a capital M? The function will treat it as invalid. So perhaps the function should be case-insensitive. But the problem statement doesn't specify that, so perhaps it's not required.

Alternatively, I can convert the unit to lowercase before checking. But the problem statement's examples use lowercase, like 'minute', so perhaps it's safe to assume the input is correctly formatted.

So the code should work as is.

Wait, but in the initial problem statement, the example is "3 timeunit", so the function should split into '3' and 'timeunit'. So the code correctly handles that.

Testing another example: frequency = "5 hour" should return a timedelta of 5 hours, which is 18000 seconds.

Yes, the code should handle that.

What about if the frequency is "0 minute"? It should return a timedelta of 0 seconds, which is allowed.

What if the frequency is "invalid"? Then, the number conversion will fail, raising ValueError.

What if the unit is 'second'? It's not in the unit_to_seconds, so it raises ValueError.

So the code should handle all these cases.

I think this should work.
