Okay, so I need to write a Python function called string_to_int. The function takes two parameters: a string and an alphabet, which is a list of strings. The goal is to convert the input string into an integer based on the given alphabet. 

Let me think about how this conversion works. Each character in the string corresponds to a position in the alphabet list. So, for example, if the alphabet is ['a', 'b', 'c'], then 'a' is 0, 'b' is 1, and 'c' is 2. The function should compute the integer value by treating the string as a number in a base equal to the length of the alphabet. 

Wait, but how is the base determined? The base should be the number of unique characters in the alphabet, right? So if the alphabet has n elements, each position in the string represents a digit in base n. 

Let me consider an example. Suppose the alphabet is ['a', 'b', 'c'] and the string is 'ab'. The length of the alphabet is 3. So 'a' is 0, 'b' is 1. The integer would be 0 * 3^1 + 1 * 3^0 = 0 + 1 = 1. Another example: 'ba' would be 1*3 + 0 = 3.

But wait, what if the string is empty? Should it return 0 or handle it somehow? The docstring doesn't mention this, so maybe we can assume the string is non-empty and consists only of characters from the alphabet.

Now, how to implement this. For each character in the string, find its index in the alphabet. Then, starting from the left, each character's index is multiplied by (base^position), where position is the index from the left, starting at 0. But wait, in typical numbering systems, the rightmost digit is the least significant. So maybe I should process the string from right to left, multiplying each time by the base.

Alternatively, I can process each character from left to right, accumulating the result. For example, result = result * base + current_value. That might be more efficient and easier to implement.

Let me outline the steps:

1. Determine the base as the length of the alphabet.
2. Initialize the result as 0.
3. For each character in the string:
   a. Find its index in the alphabet.
   b. Update the result as result * base + index.
4. Return the result.

Wait, but what if the alphabet has duplicate characters? The problem statement says the string consists of letters in the alphabet, implying that the alphabet has unique characters. So I can safely use index() without worrying about duplicates.

Now, coding this. The function will loop through each character in the string. For each char, get its index using alphabet.index(char). Then, update the result.

Let me test this logic with an example. Suppose alphabet is ['a', 'b', 'c'], string is 'abc'. The base is 3. 

- Start with result = 0.
- First char 'a' (index 0): result = 0 * 3 + 0 = 0.
- Second char 'b' (index 1): result = 0 * 3 + 1 = 1.
- Third char 'c' (index 2): result = 1 * 3 + 2 = 5.
So the result is 5. That seems correct.

Another test case: string is 'a', returns 0. String is 'b', returns 1. String is 'c', returns 2. String is 'aa', returns 0 *3 +0 =0.

What about an empty string? The function might throw an error, but according to the docstring, the string is valid, so perhaps it's assumed to be non-empty. So I don't need to handle that case.

Putting it all together, the code would look like this:

def string_to_int(string: str, alphabet: list[str]) -> int:
    base = len(alphabet)
    result = 0
    for char in string:
        result = result * base + alphabet.index(char)
    return result

I think that should work. Let me double-check. The function loops through each character, calculates the index, and accumulates the result correctly. Yes, this should handle all cases as per the problem description.
