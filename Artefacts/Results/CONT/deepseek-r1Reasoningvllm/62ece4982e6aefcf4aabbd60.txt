Okay, I need to write a Python function called size_to_bytes that converts a human-readable file size string into bytes. The function takes a string as input and returns an integer. The examples given are like '500K', '1.5MB', etc. 

First, I should think about the different units that could be present in the input. The common units are K, M, G, T, and sometimes they might use lowercase letters, but I think the examples provided use uppercase, so maybe the function expects uppercase. But to be safe, perhaps I should handle both cases. However, the examples show uppercase, so maybe the input will always be in uppercase. I'll proceed under that assumption unless I see otherwise.

The units correspond to kilobytes, megabytes, gigabytes, terabytes. Each unit is a power of 1024. So, K is 1024^1 bytes, M is 1024^2, G is 1024^3, T is 1024^4. Wait, no, actually, in computing, it's often 1024-based. So 1KB is 1024 bytes, 1MB is 1024KB, which is 1024^2 bytes, and so on.

So the plan is: parse the string to extract the numerical part and the unit, then convert the numerical part to a float, multiply by the appropriate power of 1024 based on the unit, and return the result as an integer.

Let's break it down step by step.

1. Split the input string into the numeric part and the unit. For example, in '500K', '500' is the number and 'K' is the unit.

2. Handle different units: K, M, G, T. Each corresponds to a different power. K is 1024^1, M is 1024^2, G is 1024^3, T is 1024^4.

3. Convert the string to a float. For example, '500' becomes 500.0.

4. Multiply the float by the corresponding power of 1024.

5. Return the result as an integer.

Now, how to split the string into the number and the unit. One approach is to loop through each character in the string until a non-digit is found. Alternatively, using regular expressions would be more efficient.

Regular expressions can capture the number and the unit. So a regex pattern like (\d+)([KMBGT]) could work. But wait, the number could have a decimal point, like '1.5MB'. So the regex should capture digits and dots. So maybe (\d+\.?\d*)([KMBGT]). Hmm, but sometimes the number could be something like '1000.5MB'.

Wait, but in the examples, it's '500K', '1.5MB', so the number can be a float. So the regex should capture the number part as a string that can include a dot.

So, perhaps the regex pattern would be r'^(\d+\.?\d*)([KMBGT])$'. That way, it captures the number and the unit.

Once I have the number as a string, I can convert it to a float. Then multiply by the appropriate factor.

So, putting it all together:

- Import re module for regular expressions.
- Use re.match to find the number and unit.
- If there's a match, extract them.
- Convert the number string to a float.
- Multiply by 1024 raised to the power based on the unit's position (K is 1, M is 2, etc.).
- Return the integer value.

Wait, but what if the input is something like '1000MB' or '1.5GB'? The regex should handle that since it's looking for any of the units.

Also, need to handle cases where the input might be in lowercase, but the examples show uppercase, so perhaps the function expects the input to be in uppercase. If the function is supposed to handle lowercase, I might need to modify the regex to match both cases, but since the examples don't show that, I'll proceed with uppercase.

Testing some examples:

For '500K', the function should return 500 * 1024 = 522,000 bytes.

For '1.5MB', it's 1.5 * 1024^2 = 1.5 * 1,048,576 = 1,572,864 bytes.

For '1000G', it's 1000 * 1024^3 = 1,073,741,824,000 bytes.

But wait, in Python, 1024**3 is 1073741824, so 1000 * that is 1073741824000.

Another test case: '2.5T' would be 2.5 * 1024^4 = 2.5 * 1099511627776 = 2748779069440 bytes.

Now, what about edge cases? Like an empty string, but the function expects a valid string as per the problem statement. Also, what if the number is zero? The function should handle that.

Potential issues: What if the input has no unit? The regex would not match, and re.match would return None, leading to an error. So the function should handle that, but according to the problem statement, the input is a valid human-readable size string, so perhaps that's not a concern.

Putting it all together, the code would look like:

Import re.

Define the function.

Use re.match to extract the number and unit.

If there's a match, convert to float, multiply by the appropriate factor, return as int.

So the code would be:

import re

def size_to_bytes(size: str) -> int:
    match = re.match(r'^(\d+\.?\d*)([KMBGT])$', size)
    if match:
        number = float(match.group(1))
        unit = match.group(2)
        if unit == 'K':
            factor = 1024
        elif unit == 'M':
            factor = 1024 ** 2
        elif unit == 'G':
            factor = 1024 ** 3
        elif unit == 'T':
            factor = 1024 ** 4
        else:
            # Handle other cases if needed, but according to examples, it's K, M, G, T
            factor = 1  # default, though shouldn't happen
        return int(number * factor)
    else:
        # Handle invalid input, but per problem statement, input is valid
        raise ValueError("Invalid size format")

Wait, but in the problem statement, the examples don't include decimal points, but the function should handle them. So the regex allows for that.

I think that's a solid approach. Now, I'll write the code accordingly.
