
Okay, I need to write a Python function called size_to_bytes that converts a human-readable file size string into bytes. The function takes a string like '500K' and returns the equivalent in bytes. Let me think about how to approach this.

First, I should check the possible suffixes. Common ones are K for kilobytes, M for megabytes, G for gigabytes, and maybe T for terabytes. Each of these represents a multiplier. For example, K is 1024, M is 1024^2, and so on. But wait, sometimes people use decimal units (like 1KB = 1000 bytes), but in computing, it's usually 1024. The problem might expect the binary-based multipliers.

So the plan is: parse the input string to extract the number and the suffix. Then apply the corresponding multiplier.

Let me think about the steps. The input string could be something like '500K', '2.5M', '1G', etc. So the first part is the numeric value, and the second part is the suffix. But what if there's no suffix? Like '1024' would just be 1024 bytes.

So, I need to split the string into the numeric part and the suffix. The suffix is optional. How to handle that?

Maybe using regular expressions. A regex pattern that captures the number and the suffix. For example, something like (\d+\.?\d*)\s*([KMGT]B)? But need to account for possible decimal points and different cases for the suffix (like lowercase or uppercase? The example uses 'K', but maybe the function should be case-insensitive? The docstring example uses '500K', so perhaps the suffix is uppercase. But maybe the function should handle both cases, like 'k' or 'K'.

But the problem statement says the input is a human-readable size, which might have varying cases. So the code should be case-insensitive for the suffix.

So, the regex could be something like ^(\d+\.?\d*)\s*([KMGT]B)?$i, but in Python, the regex would be case-insensitive with the re.IGNORECASE flag.

Wait, but the suffix could be 'KB', 'MB', etc. So the regex should capture the suffix as one of those. Let me think: the pattern would be something like (\d+\.?\d*)\s*([KMGT]B)?, but the suffix could be in lowercase or uppercase. So maybe using a case-insensitive match.

Alternatively, convert the suffix to uppercase for comparison.

So, the steps:

1. Use a regex to extract the numeric part and the suffix.
2. If there's no suffix, return the number as is (assuming bytes).
3. If there is a suffix, determine the multiplier based on the suffix.
4. Multiply the numeric value by the multiplier to get bytes.

Now, the multipliers:

- K (kilo) = 1024^1
- M (mega) = 1024^2
- G (giga) = 1024^3
- T (tera) = 1024^4

But what about other suffixes? Like 'B' for bytes? Well, if the suffix is 'B', then it's just the number of bytes. But the example given is '500K', which implies that the suffix is optional. So, for example, '500B' would be 500 bytes. However, the function's docstring says that the input is a human-readable size. So maybe 'B' is allowed, but perhaps the function should handle that.

But in the problem statement, the example is '500K', which returns 500 * 1024 bytes. So the function should handle 'K', 'M', 'G', 'T' as suffixes, and possibly 'B' as well.

So, the code needs to check the suffix and apply the multiplier accordingly.

So, the regex pattern could be: ^(\d+\.?\d*)\s*([KMGT]B?)?$, but need to make sure that the suffix is one of the allowed ones. Wait, 'B' is allowed as a suffix, but that would mean the value is in bytes. So, for example, '1024B' is 1024 bytes, '1K' is 1024 bytes, '1MB' is 1 * 1024^2 bytes.

So, the code can be structured as follows:

- Use re.match to find the pattern. The pattern would be something like r'^(\d+\.?\d*)\s*([KMGT]B?)?$' but with case-insensitive matching.

Wait, but the suffix could be lowercase. For example, 'k' or 'm'. So the regex should match regardless of case. So using re.IGNORECASE.

But the problem is that the suffix could be 'KB', 'Mb', etc. So perhaps the regex should capture the first letter (case-insensitive) and then check if it's followed by 'B' (case-insensitive as well). But maybe the suffix is case-insensitive, like 'k', 'K', 'm', 'M', etc. But the standard suffixes are KB, MB, GB, TB. However, sometimes people write 'k' or 'm' without the 'B'. For example, '500k' could be 500KB. But the problem says the input is a human-readable size. So perhaps the function should handle both cases where the suffix is in uppercase or lowercase, and possibly with or without the 'B'.

But this might complicate things. Let me think: the example given is '500K', which is 'K' as the suffix. So perhaps the function should accept suffixes like 'K', 'M', 'G', 'T', and 'B', and they can be in any case (uppercase or lowercase). For example, '500k', '500KB', '500mB', etc.

But how to handle that? Maybe the code should normalize the suffix to uppercase, then check which one it is.

So, the code can do:

- Split the input into the numeric part and the suffix part.
- Normalize the suffix to uppercase.
- Check if the suffix is 'B', 'KB', 'MB', 'GB', 'TB', etc. Wait, but the suffix could be 'K' or 'KB'? For example, '500K' is 500KB, which is 500 * 1024 bytes. Similarly, '500KB' is the same. But perhaps the function should treat 'K' and 'KB' as the same. However, that might not be standard. For example, 'KB' is kilobytes, but 'K' is also kilobytes. So maybe the code can treat 'K' as KB, 'M' as MB, etc.

But the problem is that the suffix could be 'K' or 'KB'. How to handle that?

Alternatively, the code can check for the presence of the suffix letters. For example, if the suffix is 'K', then it's 1024. If the suffix is 'KB', then it's also 1024. But that might be redundant, but perhaps the function should handle both.

But perhaps the problem expects that the suffix is a single letter (like 'K', 'M', etc.) without the 'B'. For example, the example given is '500K', which would be 500 * 1024 bytes.

So, maybe the code should check the suffix as a single character (case-insensitive), and ignore the 'B' part. But that might not be correct. Alternatively, the code can check for the presence of the suffix letters, regardless of case, and then determine the multiplier.

Alternatively, perhaps the code can use a regex that captures the suffix as one of the letters K, M, G, T, and ignores the 'B' part. But that's not standard. For example, the standard suffix is 'KB', 'MB', etc. However, in practice, people often write 'K' instead of 'KB'.

This is a bit ambiguous. But given the example in the docstring is '500K', perhaps the function is expected to accept suffixes like 'K', 'M', 'G', 'T', and treat them as kilobytes, megabytes, etc.

So, the code can proceed as follows:

- Use a regex to extract the numeric value and the suffix (case-insensitive).
- The suffix can be one of K, M, G, T, or empty (for bytes).
- For example, '500K' would be 500 * 1024, '1M' is 1 * 1024^2, etc.

So, the regex pattern could be r'^(\d+\.?\d*)\s*([KMGT])?$' but with case-insensitive matching. Wait, but then the 'B' part is not considered. Hmm, perhaps the code should allow for the suffix to be optional, and if present, it's one of K, M, G, T, case-insensitive.

Wait, but the example given is '500K', which would be 500KB. So the suffix is K, which represents kilobytes. So the code can assume that the suffix is K, M, G, T, and each represents 1024^1, 1024^2, etc.

So, the code can proceed as follows:

1. Use re.match to parse the input string. The pattern would be something like r'^\s*(\d+\.?\d*)\s*([KMGT])?\s*$', with case-insensitive flag.

Wait, but the 'B' is not part of the suffix. So perhaps the original example is written with 'K' as the suffix, but in reality, it's supposed to be KB. But the function's example is '500K', which would return 500 * 1024 bytes. So perhaps the code is supposed to treat the suffix as K, M, G, T, each representing 1024^1, 1024^2, etc.

So, the code can proceed as follows:

- Parse the input into a number and a suffix (case-insensitive).
- If the suffix is 'K', multiply by 1024^1.
- If 'M', multiply by 1024^2.
- 'G' → 1024^3.
- 'T' → 1024^4.
- If no suffix, return the number as bytes.

But what about if the suffix is 'B'? Like '500B' would be 500 bytes. But according to the problem statement, the function is supposed to convert human-readable sizes. So perhaps the function should handle 'B' as well, but in that case, the code would need to check for that.

But the problem's example is '500K', which suggests that the suffix is K, and not KB. So perhaps the code should treat the suffix as K, M, G, T, and not include the B. But that's a bit non-standard. However, given the example, perhaps that's the intended approach.

Alternatively, perhaps the code should consider that the suffix is optional, and if present, it's one of K, M, G, T, and the B is not part of it. So, for example, '500K' is 500 * 1024 bytes.

So, the code can proceed with that approach.

Now, implementing this in Python:

Import re.

Then, in the function:

def size_to_bytes(size: str) -> int:
    # Use regex to parse the input
    match = re.match(r'^\s*(\d+\.?\d*)\s*([KMGT])?\s*$', size, re.IGNORECASE)
    if not match:
        raise ValueError("Invalid size format")
    value_str, suffix = match.groups()
    value = float(value_str)
    if suffix is None:
        return int(value)
    suffix = suffix.upper()
    multipliers = {
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4
    }
    if suffix not in multipliers:
        raise ValueError(f"Invalid suffix: {suffix}")
    return int(value * multipliers[suffix])

Wait, but what if the suffix is 'B'? Like '500B'? Then, the regex would not match because the suffix is 'B', which is not in the allowed list. But according to the problem statement, the function is supposed to convert human-readable sizes. So perhaps the function should also accept 'B' as a suffix, which would mean bytes. So, in that case, the regex should allow for the suffix to be 'B' as well.

But the problem's example is '500K', which would be 500KB. So perhaps the code should also handle 'B' as a suffix. Let me adjust the regex to include 'B' as a possible suffix.

So, modifying the regex pattern to allow for suffixes of K, M, G, T, or B. But then, how to handle that. For example, '500B' would be 500 bytes. '500K' is 500 * 1024 bytes. So, the code can have:

multipliers = {
    'B': 1,
    'K': 1024,
    'M': 1024 ** 2,
    'G': 1024 ** 3,
    'T': 1024 ** 4
}

But then, the regex would need to capture the suffix as one of these letters. So, the regex pattern would be r'^\s*(\d+\.?\d*)\s*([KMGTB])?\s*$', with case-insensitive matching.

But in this case, the suffix can be B, K, M, G, T.

So, the code would be:

import re

def size_to_bytes(size: str) -> int:
    """
    Convert human readable file size to bytes

    Args:
        size: str, a string representing a human readable file size (eg: '500K')
    Returns:
        int: file size in bytes
    """
    match = re.match(r'^\s*(\d+\.?\d*)\s*([KMGTB])?\s*$', size, re.IGNORECASE)
    if not match:
        raise ValueError(f"Invalid size format: {size}")
    value_str, suffix = match.groups()
    value = float(value_str)
    if suffix is None:
        return int(value)
    suffix = suffix.upper()
    multipliers = {
        'B': 1,
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4
    }
    if suffix not in multipliers:
        raise ValueError(f"Invalid suffix: {suffix}")
    return int(value * multipliers[suffix])

But wait, what if the suffix is 'KB'? For example, '500KB' would not match the regex because the regex looks for a single character. So the code would not handle that. However, the example given in the docstring is '500K', which would be handled by this code. But if someone passes '500KB', the regex would not match, since the suffix is 'KB' (two characters), and the regex is looking for a single character.

This is a problem. How to handle cases where the suffix is 'KB', 'MB', etc.?

But perhaps the problem expects that the suffix is a single letter, like K, M, G, T, or B. So the function is designed to accept those. However, if the user passes 'KB', the code would not match. So perhaps the function should be adjusted to allow for the suffix to be 'KB', 'MB', etc.

But that complicates the regex. For example, the suffix could be 'KB', 'MB', 'GB', 'TB', or 'B'.

So, the regex pattern would need to capture the suffix as one of those. For example:

r'^\s*(\d+\.?\d*)\s*(KB|MB|GB|TB|B)?\s*$'

But then, the code would have to check which suffix is present. However, the problem's example is '500K', which would not match this pattern. So perhaps the original approach is better.

But this is getting complicated. Let me think again. The problem says the input is a human-readable file size. Common examples are '500K', '2.5M', '1G', etc. So the suffix is a single letter (K, M, G, T), and the code should handle that. However, some people might use 'KB', 'MB', etc. But perhaps the function should handle both cases.

Alternatively, the code can check for the presence of the suffix, regardless of case, and then determine the multiplier based on the first letter. For example, if the suffix is 'KB', then it's K, so multiplier is 1024. If the suffix is 'MB', it's M, multiplier 1024^2.

But how to capture that in the regex. For example, the regex could be:

r'^\s*(\d+\.?\d*)\s*([KMGT]B?)?\s*$'

But that would match 'K', 'KB', 'M', 'MB', etc. Then, the code can extract the suffix, and then check the first character (case-insensitive) to determine the multiplier.

So, for example, if the suffix is 'KB', then the first character is 'K', so multiplier is 1024. If the suffix is 'MB', then first character is 'M', multiplier is 1024^2. If the suffix is 'B', then it's 1.

So, modifying the code:

import re

def size_to_bytes(size: str) -> int:
    """
    Convert human readable file size to bytes

    Args:
        size: str, a string representing a human readable file size (eg: '500K')
    Returns:
        int: file size in bytes
    """
    match = re.match(r'^\s*(\d+\.?\d*)\s*([KMGT]B?)?\s*$', size, re.IGNORECASE)
    if not match:
        raise ValueError(f"Invalid size format: {size}")
    value_str, suffix = match.groups()
    value = float(value_str)
    if suffix is None:
        return int(value)
    # Determine the multiplier based on the first character of the suffix
    suffix = suffix.upper()
    first_char = suffix[0]
    multipliers = {
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4,
        'B': 1
    }
    if first_char not in multipliers:
        raise ValueError(f"Invalid suffix: {suffix}")
    return int(value * multipliers[first_char])

Wait, but the suffix could be 'KB', 'MB', etc. So, for example, if the suffix is 'KB', then first_char is 'K', and the multiplier is 1024. If the suffix is 'MB', first_char is 'M', multiplier is 1024^2. If the suffix is 'B', then first_char is 'B', multiplier is 1. So this would handle cases where the suffix is 'KB', 'MB', etc., as well as 'K', 'M', etc.

This seems more robust. So, the regex allows for the suffix to be one of K, M, G, T followed by optional B, or just B.

But what about cases where the suffix is 'KB' but the user intended it to be kilobytes. Well, this code would treat it as K, so multiplier is 1024, which is correct.

So, with this code, the example '500K' would be parsed as value_str '500', suffix 'K', first_char 'K', multiplier 1024 → 500 * 1024 = 512000 bytes.

Another example: '500KB' would be parsed as suffix 'KB', first_char 'K' → same result.

Similarly, '500MB' would be parsed as suffix 'MB', first_char 'M' → 500 * 1024^2.

This seems correct.

But what if the suffix is 'b' (lowercase)? The regex is case-insensitive, so it would be captured as 'B' in the suffix. Then, first_char is 'B', multiplier is 1. So '500b' would return 500 bytes.

This seems acceptable.

So, this approach should handle various cases.

Now, testing the code:

Test case 1: '500K' → 500 * 1024 = 512000 → correct.

Test case 2: '2.5M' → 2.5 * 1024^2 = 2.5 * 1048576 = 2621440.

Test case 3: '1G' → 1 * 1024^3 = 1073741824.

Test case 4: '1024B' → 1024 bytes.

Test case 5: '1TB' → 1 * 1024^4 = 1099511627776.

Test case 6: '500KB' → same as '500K' → 512000.

Test case 7: '500b' → 500 bytes.

Now, what about invalid inputs?

For example, '500X' → suffix is 'X', first_char 'X' not in multipliers → ValueError.

Another example, '500' → no suffix → returns 500.

What about '500.5KB' → parsed as value 500.5, suffix 'KB' → 500.5 * 1024 = 512512 bytes.

This seems to handle all cases.

Now, the code uses re.IGNORECASE to make the suffix case-insensitive. The regex pattern is r'^\s*(\d+\.?\d*)\s*([KMGT]B?)?\s*$', which matches:

- Leading whitespace (optional)
- A numeric value (can have decimal point)
- Optional suffix, which is one of K, M, G, T followed by optional B, or just B.
- Trailing whitespace (optional)

But the regex may not capture all possible valid inputs. For example, what if the suffix is 'KB' but there's a space between the number and the suffix? Like '500 KB' → the regex would capture that as value_str '500', suffix 'KB'.

Yes, because the regex allows for whitespace between the number and the suffix.

So, the code should handle that.

Another edge case: '0K' → 0 bytes.

Another case: '1.0MB' → 1.0 * 1024^2 = 1048576.

Now, the code uses float(value_str) which can handle decimal points.

So, this code should work.

Now, implement this in Python.

But the problem says that the user has imported packages, but within the file, there's nothing. So the code should include the necessary imports.

So, the code should start with importing re.

Thus, the final code would be:

import re

def size_to_bytes(size: str) -> int:
    """
    Convert human readable file size to bytes

    Args:
        size: str, a string representing a human readable file size (eg: '500K')
    Returns:
        int: file size in bytes
    """
    match = re.match(r'^\s*(\d+\.?\d*)\s*([KMGT]B?)?\s*$', size, re.IGNORECASE)
    if not match:
        raise ValueError(f"Invalid size format: {size}")
    value_str, suffix = match.groups()
    value = float(value_str)
    if suffix is None:
        return int(value)
    suffix = suffix.upper()
    first_char = suffix[0]
    multipliers = {
        'K': 1024,
        'M': 1024 ** 2,
        'G': 1024 ** 3,
        'T': 1024 ** 4,
        'B': 1
    }
    if first_char not in multipliers:
        raise ValueError(f"Invalid suffix: {suffix}")
    return int(value * multipliers[first_char])

Wait, but what if the suffix is 'B'? For example, '500B' → suffix is 'B', first_char is 'B', which is in the multipliers with value 1. So returns 500 * 1 = 500 bytes. Correct.

Another case: '500' → suffix is None → returns 500.

Another case: '500KB' → suffix is 'KB', first_char is 'K' → 500 * 1024 = 512000.

Another case: '500MB' → suffix 'MB' → first_char 'M' → 500 * 1024^2.

This seems correct.

Now, what about if the suffix is 'TB'? For example, '1TB' → first_char is 'T', multiplier is 1024^4.

Yes.

Now, what about if the suffix is 'b'? The regex is case-insensitive, so it would be matched as 'B', and first_char is 'B', which is handled.

So, this code should handle all cases as per the problem's requirements.
