
Okay, I need to write a Python function called round_half_to_even that rounds a floating-point number. The docstring says it's supposed to round, but the exact behavior isn't specified. Wait, the name suggests it's using "bankers rounding," where numbers exactly halfway between two integers are rounded to the nearest even number. Like, 0.5 would round to 0, 1.5 would round to 2, etc.

But wait, Python's built-in round function already does that. So maybe the user wants me to implement that behavior. However, maybe they want me to write it from scratch without using the built-in round? Or maybe just use the built-in function?

Looking at the problem again: the function signature is given, and the docstring is just "Round a floating-point number." The context says no imported packages, so I can't use anything else. But the built-in round is available by default.

Wait, but maybe the user wants to implement the rounding manually. But the question says to generate code based on the function signature and docstring. Since the docstring is minimal, perhaps the intended solution is to use the built-in round function. Because the name "round_half_to_even" matches the behavior of Python's round function.

So the function can simply return round(n). Let me test that. For example, round(0.5) is 0, round(1.5) is 2, which matches the half-to-even rule. So the code would be:

def round_half_to_even(n):
    """
    Round a floating-point number
    """
    return round(n)

But wait, what about numbers that are not exactly halfway? Like 2.3 would round to 2, 2.6 to 3. But the built-in round does that. So this should be correct.

But maybe the user expects a different approach, like checking the decimal part. But given that the problem says to generate code based on the signature and docstring, and the docstring is very brief, using the built-in round is the most straightforward solution. Also, the context mentions no imported packages, so using the built-in is allowed.

Therefore, the correct code is to return round(n).
