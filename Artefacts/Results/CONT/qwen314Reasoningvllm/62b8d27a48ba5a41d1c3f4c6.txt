
Okay, I need to generate the Python code for the cached function based on the given signature and docstring. Let me think about what this function does. The docstring says it returns a decorator that saves results in a cache. The parameters are cache, key which defaults to hashkey, and lock which is optional.

First, I remember that decorators in Python can be created using functions. The cached function here is supposed to return a decorator. So the structure would be a function that returns another function, which is the decorator.

The key parameter uses hashkey by default. I need to make sure that hashkey is available. Since the imported package is functools, maybe hashkey is from there. Oh right, functools has a function called hashkey, which is used to generate a hashable key from arguments. So I should import that.

Wait, the user mentioned that the imported packages include functools. So I need to import functools and use its hashkey. But in the code, the user might have already imported it, but maybe I should include the import statement? However, the user's context says "Imported Packages: functools" and "Within file:" is empty. So maybe the code should include the necessary imports.

Wait, the user's instruction says to generate code based on the function signature and docstring. The existing code might not have the import, but the context says that functools is imported. So perhaps I need to include the import statement in the code.

But looking at the function signature, the key parameter is set to hashkey. So hashkey must be a function from functools. Therefore, the code should import functools and use functools.hashkey.

So the code would start with importing functools. Then, the cached function is defined. The decorator returned by cached should take a function and return a wrapped function.

The decorator needs to check if the result is in the cache. If not, compute it and store it. Also, the lock parameter is optional, which might be used for thread safety. But the code might need to handle that. However, the user hasn't provided details on how the lock is used. Maybe the lock is used to synchronize access to the cache.

But the problem is to generate the code based on the given function signature. The existing code might be incomplete, so I need to fill in the implementation.

Let me outline the steps:

1. Import functools.
2. Define the cached function with parameters cache, key, and lock.
3. The cached function returns a decorator. The decorator takes a function (say, func) and returns a wrapped function.
4. The wrapped function checks if the key (generated by applying the key function to the arguments) is in the cache. If yes, return the cached value. If not, compute the result, store it in the cache, and return it.
5. The lock is used to ensure that only one thread can access the cache at a time. So, when accessing the cache, acquire the lock, check, and release it.

But how to handle the lock? If lock is provided, use it. Otherwise, maybe no locking. So in the code, when checking the cache, we might need to use the lock to prevent race conditions.

Wait, but the user hasn't provided the exact implementation details. So perhaps the code is a standard decorator that uses a cache, and the lock is optional for thread safety.

Putting it all together:

The cached function returns a decorator. The decorator uses the key function to generate a key from the arguments. The cache is a dictionary-like object that stores the results. The lock is used to synchronize access.

So here's a possible implementation:

import functools

def cached(cache, key=functools.hashkey, lock=None):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(args, kwargs)
            if lock is not None:
                lock.acquire()
                try:
                    if k in cache:
                        return cache[k]
                    result = func(*args, **kwargs)
                    cache[k] = result
                    return result
                finally:
                    lock.release()
            else:
                if k in cache:
                    return cache[k]
                result = func(*args, **kwargs)
                cache[k] = result
                return result
        return wrapper
    return decorator

Wait, but in the code above, when the lock is present, we acquire it, check the cache, and if not present, compute the result. However, between checking if k is in cache and computing the result, another thread might have added it. So using a lock is necessary to prevent that. But the code above checks if k is in cache under the lock, then computes the result under the lock. But the computation of func(*args, **kwargs) might not be under the lock. Wait, no, because the code inside the lock's try block is:

if k in cache: return cache[k]
result = func(...)
cache[k] = result
return result

But if the lock is acquired, then the check and the storage are under the lock. However, the computation of func is outside the lock. That's a problem because during the computation, another thread could modify the cache. Wait, no, because the lock is held during the check and the storage, but not during the computation. So if the function takes a long time to compute, other threads could be waiting on the lock, but during the computation, the lock is released. That's not thread-safe. So the correct approach is to acquire the lock, check the cache, if not present, compute the result (while holding the lock?), but that might not be necessary if the computation is not modifying the cache. However, the problem is that between checking the cache and computing the result, another thread could have computed the same result and stored it. But if the lock is held during the entire process, then that's prevented.

Wait, the code as written acquires the lock, checks if the key is in the cache. If not, it releases the lock (no, wait, the code is inside the try block. The lock is acquired before the try, and released in finally. So during the entire block, the lock is held. So the code:

lock.acquire()
try:
    if k in cache:
        return cache[k]
    result = func(...)
    cache[k] = result
    return result
finally:
    lock.release()

But this way, the entire process of checking and storing is under the lock. However, the computation of func(...) is done while holding the lock. That's not efficient, but it's thread-safe. However, if the function is long-running, it could hold the lock for a long time, which is not ideal. But perhaps that's the intended approach here.

Alternatively, the code could check the cache under the lock, then release the lock before computing the result, and then re-acquire the lock to store the result. But that would require checking again if the key is present after releasing the lock. Which could lead to redundant computation.

But given the problem statement, perhaps the code is supposed to be as simple as possible. The user's code might have a different approach, but given the information, this is a possible implementation.

Another thing: the key function is passed as a parameter. The default is functools.hashkey, which is a function that returns a hashable key from the arguments. So when the wrapper is called, it generates the key by calling key(args, kwargs).

So putting all that together, the code would be:

import functools

def cached(cache, key=functools.hashkey, lock=None):
    """
    Returns a decorator function that saves the results in the cache
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            k = key(args, kwargs)
            if lock is not None:
                lock.acquire()
                try:
                    if k in cache:
                        return cache[k]
                    result = func(*args, **kwargs)
                    cache[k] = result
                    return result
                finally:
                    lock.release()
            else:
                if k in cache:
                    return cache[k]
                result = func(*args, **kwargs)
                cache[k] = result
                return result
        return wrapper
    return decorator

But wait, in the code above, when the lock is present, the entire process (checking and storing) is done under the lock. However, the computation of func is done while holding the lock, which might not be efficient. But perhaps that's acceptable for the purposes of this problem.

Another thing: the cache is passed into the cached function. The cache is expected to be a mutable object, like a dictionary, that can be modified by the wrapper function.

This code should satisfy the given function signature and docstring. The decorator is returned by the cached function, and it uses the provided cache, key function, and lock.
