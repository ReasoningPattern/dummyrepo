
Okay, I need to write the Python function remove_ending_os_sep based on the given signature and docstring. Let me think about what the function is supposed to do.

The docstring says that if the input list is None, return an empty list. So first, I should check if input_list is None. If it is, return [].

Then, for each string in the input list, I need to check two things: the length of the string is greater than one, and the last character is the pathname separator. If both conditions are true, remove the trailing separator. Otherwise, leave the string as is.

Wait, the os module is imported, so I should use os.sep to get the correct separator for the operating system. That makes sense because the function is supposed to handle the OS-specific separator.

So, for each string in the input_list, I'll check if len(s) > 1 and s[-1] == os.sep. If so, I'll take the string up to the last character, i.e., s[:-1]. Otherwise, keep the original string.

But wait, what if the string is empty or has length 1? Then, we don't modify it. For example, if the string is just the separator, like '/', then len is 1, so we leave it. But if the string is '/a', then len is 2, and the last character is '/', so we remove it to get '/a' becomes 'a'? Wait, no. Wait, if the string is '/a', then the last character is 'a', not the separator. Wait, maybe I got the condition wrong. Let me think again.

Wait, the function is supposed to remove trailing os separators. So, for example, if the string is 'path/', then the last character is the separator. So we need to remove that. So the condition is: if the string's last character is os.sep, and the length is more than one. So, for 'path/', we take s[:-1], which is 'path'. For 'path', since the last character isn't the separator, we leave it as is. For a string like 'path/', we remove the trailing '/'.

So the code would process each string in the input list. For each string s in input_list:

if s is not None (but the input list is already checked for None, but individual elements could be None? The docstring says it's a string list, so maybe assuming all elements are strings. But maybe need to handle cases where elements are not strings? The docstring says "string list", so perhaps we can assume that each element is a string. So no need for error checking there.

So the steps:

- Check if input_list is None: return []
- Else, iterate over each string in input_list.
- For each string, check if len(s) > 1 and s ends with os.sep.
- If yes, then s[:-1], else s.

So the code would be:

import os

def remove_ending_os_sep(input_list):
    if input_list is None:
        return []
    result = []
    for s in input_list:
        if len(s) > 1 and s[-1] == os.sep:
            result.append(s[:-1])
        else:
            result.append(s)
    return result

Wait, but what about cases where the string is empty? Like, if s is an empty string, then len(s) is 0, so the condition is false, and it's added as is. That's correct.

Testing some examples:

input_list = ['path/', 'file', 'dir/']
After processing: ['path', 'file', 'dir']

Another example: ['a/', 'b/c/', 'd'] becomes ['a', 'b/c', 'd'].

Yes, that seems right.

So the code should be as above. Also, the function is supposed to return a list, which it does.

I think that's all. Now, write the code as per the instructions.
