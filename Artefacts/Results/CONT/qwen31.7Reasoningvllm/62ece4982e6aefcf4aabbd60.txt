
Okay, I need to write the Python function size_to_bytes that converts a human-readable file size string into bytes. The function is given a string like '500K' and returns the corresponding integer in bytes.

First, I remember that common units like K, M, G, etc., represent kilobytes, megabytes, gigabytes, etc. So the function needs to parse the string, extract the number and the unit, then convert it to bytes.

Let me think about the steps. The input is a string, so I can split it into the numeric part and the unit. For example, '500K' would split into '500' and 'K'. Then, I need to convert the number to bytes based on the unit.

The units are usually K, M, G, T, P, E, Z, Y. Each unit represents a power of 1024. So K is 1024, M is 1024^2, and so on. But sometimes people use 1000 for K, which is kilo bytes, but in computing, it's 2^10. However, the problem statement doesn't specify, so I should check the context.

Wait, the problem says "human readable file size" which typically uses 1024 for the units. For example, 1K is 1024 bytes, 1M is 1048576 bytes. But sometimes people might use 1000, like in some contexts. However, the function's docstring example uses '500K' which is 500 * 1024 = 512000 bytes. So the function should use 1024 for the conversion factors.

So the plan is:

1. Split the input string into the numeric part and the unit.
2. Convert the numeric part to an integer.
3. Determine the conversion factor based on the unit.
4. Multiply the numeric value by the conversion factor to get bytes.

But how to split the string? For example, '500K' can be split into '500' and 'K'. But what if the string is '1G' or '1T'? The unit can be 'K', 'M', 'G', 'T', etc.

So the first step is to extract the number and the unit. Let's think about possible units. The possible units are K, M, G, T, P, E, Z, Y. But the function might not need to handle all of them, but the problem says the input is a string like '500K', so perhaps the unit is one of these.

So, the code can check the unit and multiply by the appropriate factor.

Let me think about the code structure.

First, split the input string. For example, using split() with a regex to extract the number and the unit.

But maybe using string manipulation. For example, the unit is the last character, but that's not always the case. For example, '500K' has 'K' as the unit, but '500MB' has 'B' as the unit. Wait, the problem says the input is a string like '500K', so perhaps the unit is one of K, M, G, T, P, E, Z, Y. But the function's docstring example uses 'K', so maybe the unit is one of those.

But how to handle the unit? Let's think: the unit is the last character of the string, but only if it's one of K, M, G, T, P, E, Z, Y. But maybe the input is like '500B' which would be bytes, but the function is supposed to handle that. However, the problem says the input is a human readable size, so perhaps the unit is K, M, G, T, P, E, Z, Y. But the function's docstring example uses 'K', so maybe the unit is one of those.

But the function's parameters are a string, and the code needs to handle any possible unit. So perhaps the code can check the last character of the string, and if it's one of the valid units, then proceed. But what if the input is '500B'? Then the unit is 'B', which is not in the list. But the function's docstring says the input is a string representing a human readable file size, so perhaps the unit is K, M, G, T, P, E, Z, Y. However, the function may need to handle cases where the unit is not one of those, but the problem says the input is valid.

So, the code can check the last character of the input string. If it's 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', then use that unit. Otherwise, maybe it's a mistake, but the function may assume that the input is valid.

So, the steps:

1. Check if the input string is empty. If so, return 0.

2. Split the string into the number part and the unit. For example, '500K' → '500' and 'K'.

3. Convert the number part to an integer.

4. Determine the conversion factor based on the unit.

5. Multiply the number by the conversion factor to get bytes.

Now, the conversion factors:

K → 1024

M → 1024^2 = 1,048,576

G → 1024^3 = 1,073,741,824

T → 1024^4 = 1,099,511,627,776

P → 1024^5

E → 1024^6

Z → 1024^7

Y → 1024^8

So, the code can have a dictionary that maps the unit to the conversion factor. But perhaps it's easier to use a list of tuples, where each tuple is (unit, factor). For example, ['K', 1024], ['M', 1048576], etc.

But how to handle the units. Let's think: the unit can be 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'. So, the code can check the last character of the string. If it's one of these, then proceed.

But what if the input is '500B'? Then the unit is 'B', which is not in the list. But the function's docstring says the input is a human readable file size, so perhaps the unit is one of K, M, G, T, P, E, Z, Y. So the code can assume that the unit is one of these.

So, the code can do the following:

- Check if the input string is empty. If so, return 0.

- Split the string into the number part and the unit. For example, split on the last character. But how?

Wait, the unit is the last character. So, for example, '500K' → last character is 'K', so the unit is 'K'. So, the code can take the last character of the string, and check if it's one of the valid units.

But what if the input is '500B'? Then the unit is 'B', which is not in the list. But the function's docstring says the input is a valid human readable size, so perhaps the code can assume that the unit is one of the valid ones.

So, the code can proceed as follows:

First, check if the input string is empty. If so, return 0.

Then, check if the last character is one of the valid units. If not, maybe raise an error, but the problem says the input is valid.

So, the code can do:

unit = size[-1]

But wait, if the input is '500K', then the unit is 'K'. But if the input is '500', then the unit is not present. But the function's docstring says the input is a human readable size, so perhaps the input is always followed by a unit. So, the code can assume that the input is something like '500K', '500M', etc.

So, the code can split the string into the number part and the unit. For example, the number part is the part before the last character, and the unit is the last character.

But how to split the string. For example, '500K' → '500' and 'K'. So, the code can take the part before the last character, and the last character.

But what if the input is '500' (without a unit)? Then the code would have to return 500 as bytes, but the function's docstring says the input is a human readable size. So perhaps the code should assume that the input has a unit.

So, the code can proceed as follows:

number_part = size[:-1]

unit = size[-1]

Then, convert number_part to an integer.

Then, determine the conversion factor based on the unit.

So, the code can have a dictionary that maps the unit to the conversion factor. For example:

unit_map = {
    'K': 1024,
    'M': 1024**2,
    'G': 1024**3,
    'T': 1024**4,
    'P': 1024**5,
    'E': 1024**6,
    'Z': 1024**7,
    'Y': 1024**8
}

But then, the code can check if the unit is in the unit_map. If not, perhaps raise an error. But the problem says the input is valid.

So, the code can proceed:

number = int(number_part)

factor = unit_map[unit]

return number * factor

But how to handle the case where the unit is not in the unit_map? Well, the problem says the input is valid, so it's assumed that the unit is one of the valid ones.

So, putting it all together:

def size_to_bytes(size: str) -> int:
    if not size:
        return 0
    number_part = size[:-1]
    unit = size[-1]
    unit_map = {
        'K': 1024,
        'M': 1024**2,
        'G': 1024**3,
        'T': 1024**4,
        'P': 1024**5,
        'E': 1024**6,
        'Z': 1024**7,
        'Y': 1024**8
    }
    if unit in unit_map:
        return int(number_part) * unit_map[unit]
    else:
        # Handle invalid units, but problem says input is valid
        raise ValueError(f"Invalid unit: {unit}")

But wait, what if the input is '500B'? Then the unit is 'B', which is not in the unit_map. But the function's docstring says the input is a valid human readable size. So perhaps the code should handle that. However, the problem says to generate code based on the function signature and docstring, so perhaps the code is expected to handle the given examples.

But the problem says the input is a string representing a human readable file size. So, perhaps the code should assume that the unit is one of K, M, G, T, P, E, Z, Y. So the code can proceed as above.

But what about cases where the unit is not a single character? For example, '500Kb' (kilo bytes). But the function's docstring example uses 'K', so perhaps the code should assume that the unit is one of K, M, G, T, P, E, Z, Y.

So the code should handle that.

Another thing to consider: the number_part could be empty. For example, if the input is '0K', then number_part is '0', which is fine. If the input is '0', then number_part is '0', but the unit is not present. But the function's docstring says the input is a valid human readable size, so perhaps the code can assume that the input is always valid.

So, the code should handle cases where the input is '0', but in that case, the unit is not present. However, the function's docstring says the input is a string representing a human readable size, so perhaps the code can assume that the input is valid.

But in code, if the input is '0', then size[:-1] is '0', and unit is empty? Wait, no. If the input is '0', then size is '0', so size[:-1] is empty string, and unit is the last character, which is '0'? Wait, no. The code is:

unit = size[-1]

If the input is '0', then size[-1] is '0', which is not a valid unit. So the code would check if '0' is in the unit_map, which it's not. So the code would raise an error. But the function's docstring says the input is valid, so perhaps the code is supposed to handle that.

But the problem says to generate code based on the function signature and docstring. So the code should handle the cases as per the docstring.

So, the code as written would handle the example '500K' correctly.

Testing the code:

For '500K', number_part is '500', unit is 'K', so 500 * 1024 = 512000.

Another example: '1M' → 1 * 1048576 = 1048576.

Another example: '1G' → 1 * 1073741824 = 1073741824.

But what about '1T'? 1 * 1099511627776.

So the code seems to handle that.

But what about if the input is '500B'? Then the code would raise an error, but the function's docstring says the input is valid. So the code is correct as per the given docstring.

So the code should be as written above.

But wait, the code uses 'unit_map' which is a dictionary. But in Python, the code can have that.

So the final code is:

def size_to_bytes(size: str) -> int:
    """
    Convert human readable file size to bytes

    Args:
            size: str, a string representing a human readable file size (eg: '500K')
    Returns:
            int: file size in bytes
    """
    if not size:
        return 0
    number_part = size[:-1]
    unit = size[-1]
    unit_map = {
        'K': 1024,
        'M': 1024**2,
        'G': 1024**3,
        'T': 1024**4,
        'P': 1024**5,
        'E': 1024**6,
        'Z': 1024**7,
        'Y': 1024**8
    }
    if unit in unit_map:
        return int(number_part) * unit_map[unit]
    else:
        raise ValueError(f"Invalid unit: {unit}")

But wait, what if the input is '500' (without a unit)? Then size[:-1] is '500', unit is '0'? No, the code would take size[-1] as '0', which is not a valid unit. So the code would raise an error. But according to the docstring, the input is valid, so this case is not expected.

So the code is correct as per the given docstring.

Another thing to consider: the number_part could be '0', which is fine. For example, '0K' would be 0 * 1024 = 0.

So the code should handle that.

Thus, the code is as written above.
