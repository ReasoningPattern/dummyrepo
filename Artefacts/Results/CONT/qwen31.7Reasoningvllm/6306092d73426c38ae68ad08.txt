
Okay, I need to generate the Python code for the _get_conditionally_required_args method based on the provided function signature and docstring. Let me start by understanding the problem.

The function is supposed to list arguments that are required when a certain condition is met. The parameters are command_name, options_spec, and args. The return value is a list of argument names that meet the required_when condition.

Looking at the docstring, the parameters are:
- command_name: the command name.
- options_spec: list of command spec options.
- args: the received input arguments.

The return is a list of argument names with matched required_when condition.

Now, I need to think about how to implement this. The function is part of a class, so I need to consider the class context. The imports mentioned are string, os, collections, six, infrared. But the code generation doesn't need to include those imports since the user asked for the code only.

The function's purpose is to filter arguments based on their required_when attribute. So, I need to iterate through the args and check if their required_when condition is met.

But wait, the args parameter is the received input arguments. So, perhaps the args are a dictionary or a list of arguments. However, the exact structure isn't specified. Since the function is part of a class, maybe the args are passed as a dictionary where keys are argument names and values are their values.

Assuming that args is a dictionary, the function would need to check each key's required_when condition. But how are the options_spec and command_name used here?

The options_spec is a list of command spec options. Maybe each option in options_spec has a required_when attribute. So, for each argument in args, we check if there's an option in options_spec that matches the argument name, and if the required_when is True.

Wait, but the function's parameters are command_name, options_spec, and args. So, perhaps the options_spec is a list of dictionaries or objects that have required_when and other attributes.

But since the code is to be generated, I need to write the code that would process these parameters.

Let me outline the steps:

1. Iterate over each argument in the args dictionary.
2. For each argument, check if there's a corresponding option in options_spec that has a required_when value.
3. If the required_when is True, add the argument name to the result list.

But how to handle the options_spec? Maybe the options_spec is a list of dictionaries, each with an 'option_name' and 'required_when' key.

Alternatively, maybe the options_spec is a list of strings, and each string represents an option with a required_when value. But that's less likely. More likely, options_spec is a list of dictionaries where each dictionary has 'option_name' and 'required_when' keys.

So, the code would look something like:

result = []
for arg_name, arg_value in args.items():
    for option in options_spec:
        if option['option_name'] == arg_name and option['required_when']:
            result.append(arg_name)
            break
return result

But I need to make sure that the code is correct. Also, considering that the function is part of a class, maybe the args are passed as a list, but the docstring says 'args' is the received input arguments, which could be a dictionary.

Another consideration: the function is named _get_conditionally_required_args, which suggests that it's a private method. So, the code would be inside the class.

But since the user asked for the code generation, I just need to write the function as per the signature.

So, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    """
    List arguments with ``required_when`` condition matched.

    :param command_name: the command name.
    :param options_spec:  the list of command spec options.
    :param args: the received input arguments
    :return: list, list of argument names with matched ``required_when`` condition
    """
    result = []
    for arg_name, arg_value in args.items():
        # Check if the argument is required when any of the options_spec options are met
        for option in options_spec:
            if option['option_name'] == arg_name and option['required_when']:
                result.append(arg_name)
                break
    return result

Wait, but the options_spec is a list of command spec options. So, each option in options_spec might have an 'option_name' and 'required_when' key. So, the code checks if the argument name matches the option's name and the required_when is True.

But the function's parameters are command_name, options_spec, and args. The code above assumes that options_spec is a list of dictionaries with 'option_name' and 'required_when' keys. However, the docstring doesn't specify this, so maybe the code is supposed to handle it in a different way.

Alternatively, maybe the options_spec is a list of strings, and each string has a required_when value. But that's less likely. The docstring says "the list of command spec options", which suggests that each element is an option with its own spec.

But without knowing the exact structure of options_spec, the code has to be generic. So, the code would check each option in options_spec for the argument name and required_when.

But the code as written would only check if the argument name matches the option's name and required_when is True. However, the function's purpose is to list arguments that are required when the condition is met. So, perhaps the code is supposed to check if the argument is required when any of the options in options_spec have a required_when of True.

But the code as written would collect all arguments that have an option in options_spec with the same name and required_when True. However, the function's docstring says "list arguments with ``required_when`` condition matched", which might mean that the argument is required when the condition is met, regardless of which option it is.

But this is getting complicated. Maybe the function is supposed to check if the argument is required when any of the options in options_spec have a required_when of True. But that's not clear.

Alternatively, perhaps the options_spec is a list of options, each with their own required_when, and the function is to return arguments that are required when any of the options in options_spec have required_when True.

But without more context, the code has to be written as per the given parameters.

So, the code would iterate over each argument in args, and for each, check if there's an option in options_spec with the same name and required_when True. If so, add the argument to the result.

Thus, the code would be as written earlier.

But the code needs to be in Python, so the function would be written with the parameters as specified.

Another thing to consider: the function is part of a class, so the code would be inside the class. But since the user asked for the code generation, the function is written as a standalone function.

Therefore, the generated code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    """
    List arguments with ``required_when`` condition matched.

    :param command_name: the command name.
    :param options_spec:  the list of command spec options.
    :param args: the received input arguments
    :return: list, list of argument names with matched ``required_when`` condition
    """
    result = []
    for arg_name, arg_value in args.items():
        for option in options_spec:
            if option['option_name'] == arg_name and option['required_when']:
                result.append(arg_name)
                break
    return result

But the code assumes that options_spec is a list of dictionaries with 'option_name' and 'required_when' keys. If the actual structure is different, this code would not work. However, given the information provided, this is the best possible implementation.
