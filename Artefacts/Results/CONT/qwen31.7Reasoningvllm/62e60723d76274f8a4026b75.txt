
Okay, I need to write the Python function round_half_to_even. Let me think about how to implement this.

The function is supposed to round a floating-point number to the nearest even number. Oh right, the standard rounding method for even numbers. So for example, 2.5 should round to 2.0, and 3.5 should round to 4.0. Wait, no, wait. Wait, the standard rounding to even is called "bankers rounding". So for numbers like 2.5, which is exactly between 2 and 3, it rounds to the even number, which is 2 in this case. Wait, no, 2.5 is halfway between 2 and 3. The even number would be 2 or 4? Wait, the even number in the context of rounding is the one that's even when represented as a decimal. So for 2.5, the even numbers are 2 and 4. But how does the rounding work here?

Wait, the standard way to do this in Python is to use the built-in round function with a certain approach. But I remember that the round function in Python rounds to the nearest even number when the number is exactly halfway between two integers. For example, round(2.5) is 2, round(3.5) is 4. So that's exactly what we need here. So the function can simply be a wrapper around the built-in round function.

Wait, but wait. Let me check. Let me test some examples. For example, 2.5 rounds to 2, 3.5 rounds to 4, 1.5 rounds to 2, 2.6 rounds to 3, 2.4 rounds to 2. So yes, the round function does this. So the function can just be return round(n). But wait, is that correct?

Wait, but the problem says to generate the code based on the function signature and docstring. So the function is supposed to round to the nearest even number. But the built-in round function does that. So the code would be as simple as return round(n). But maybe there's a case where it's not sufficient? For example, if the number is something like 2.0, which is already even. Or 3.0, which is even. So the round function would handle that.

But wait, let me check. Let me think about the actual implementation. The round function in Python uses "bankers rounding" which rounds to the nearest even number when the number is exactly halfway between two integers. So for 2.5, it rounds to 2, for 3.5 rounds to 4. So that's exactly what the function needs to do.

Therefore, the code for the function is simply return round(n). But wait, the docstring says "Round a floating-point number". So the function is supposed to do that. So the code is straightforward.

But wait, maybe there's a case where the round function isn't sufficient? For example, if the number is something like 2.0, which is already even. But that's handled correctly. So the code is as simple as return round(n).

So the Python code would be:

def round_half_to_even(n):
    """
    Round a floating-point number
    """
    return round(n)

But wait, the problem says to generate the code based on the function signature and docstring. So the function is supposed to be implemented. But the docstring is as given. So the code is as above.

But maybe there's a catch. For example, in Python, the round function rounds to the nearest even number when the number is exactly halfway between two integers. So this function is correct.

Therefore, the code is as simple as returning round(n).
