

To solve this problem, we need to generate a function that transforms each given path into a glob pattern if it is not already one. The function should return a tuple of transformed paths.

### Approach
The approach involves iterating through each path in the input sequence and checking if it is a glob pattern. If it is, the path is added to the result as is. If it is not, the path is appended with a '*' to convert it into a glob pattern. The transformation ensures that each path is either left as is or converted into a glob pattern, ensuring consistency and correctness.

### Solution Code
```python
import re

def make_find_paths(find_paths):
    """
    Given a sequence of path, transform all path into glob patterns. Pass through existing patterns untouched.

    Args:
        find_paths: sequence of path
    Returns:
        tuple of transformed path
    """
    transformed = []
    for path in find_paths:
        if re.match(r'^\??.*[?/./*]+$', path):
            transformed.append(path)
        else:
            transformed.append(path + '*')
    return tuple(transformed)
```

### Explanation
1. **Iteration**: The function iterates through each path in the input sequence.
2. **Regex Check**: For each path, it uses a regular expression to check if the path matches a glob pattern. The regex pattern `r'^\??.*[?/./*]+$'` is designed to match paths that include common glob characters like '*', '?', '.', '/', or '\'.
3. **Transformation**: If the path is identified as a glob pattern, it is added to the result list unchanged. If not, the path is appended with a '*' to convert it into a glob pattern.
4. **Result**: The transformed paths are collected into a tuple and returned as the result.

This approach ensures that existing glob patterns are preserved while converting non-glob paths into valid glob patterns, facilitating consistent and reliable path handling.