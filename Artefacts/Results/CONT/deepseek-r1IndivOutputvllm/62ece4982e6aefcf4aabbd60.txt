

To solve this problem, we need to write a Python function that converts a human-readable file size string into bytes. The function should handle various units such as kilobytes (K), megabytes (M), gigabytes (G), and terabytes (T).

### Approach
1. **Problem Analysis**: The task is to convert a string representing a file size into its equivalent in bytes. The input string can have units like K, M, G, or T, and may include decimal values.
2. **Unit Mapping**: Each unit corresponds to a specific power of 1024:
   - K: 1024^1 bytes
   - M: 1024^2 bytes
   - G: 1024^3 bytes
   - T: 1024^4 bytes
3. **Regular Expression**: Use a regular expression to split the input string into the numeric part and the unit. This helps in accurately capturing both the number and the unit.
4. **Conversion Logic**: Convert the numeric part to a float, multiply it by the appropriate factor based on the unit, and return the result as an integer.

### Solution Code
```python
import re

def size_to_bytes(size: str) -> int:
    match = re.match(r'^(\d+\.?\d*)([KMBGT])$', size)
    if match:
        number = float(match.group(1))
        unit = match.group(2)
        if unit == 'K':
            factor = 1024
        elif unit == 'M':
            factor = 1024 ** 2
        elif unit == 'G':
            factor = 1024 ** 3
        elif unit == 'T':
            factor = 1024 ** 4
        else:
            factor = 1
        return int(number * factor)
    else:
        raise ValueError("Invalid size format")
```

### Explanation
1. **Regular Expression Matching**: The regular expression `r'^(\d+\.?\d*)([KMBGT])$'` is used to split the input string into a numeric part and a unit part. The numeric part can include decimal values, and the unit must be one of K, M, G, or T.
2. **Conversion Factors**: Depending on the unit, the appropriate power of 1024 is used as the conversion factor.
3. **Return Value**: The numeric part is converted to a float, multiplied by the conversion factor, and then cast to an integer before returning.

This approach ensures that the function accurately converts various human-readable file sizes into their equivalent in bytes, handling both integer and decimal values efficiently.