

To solve this problem, we need to create a function that parses a frequency string into a corresponding `datetime.timedelta` instance. The function should handle various units of time and raise appropriate errors for invalid inputs.

### Approach
1. **Handle Special Cases**: If the input frequency is `None` or the string "always", the function should return `None`.
2. **Validate Input Format**: The input string should be split into two parts: a number and a unit. If the split does not result in exactly two parts, the function raises a `ValueError`.
3. **Convert Number to Integer**: The first part of the split string is converted to an integer. If this conversion fails, a `ValueError` is raised.
4. **Map Units to Seconds**: A dictionary maps valid time units to their respective number of seconds. This allows us to convert the parsed number into the corresponding number of seconds.
5. **Calculate Total Seconds**: Multiply the parsed number by the number of seconds corresponding to the given unit.
6. **Create Timedelta**: Use the calculated total seconds to create a `timedelta` instance.

### Solution Code
```python
import datetime

def parse_frequency(frequency):
    """
    Given a frequency string with a number and a unit of time, return a corresponding
     datetime.timedelta instance.
     If the frequency is None or "always", return None.
     Raise ValueError if the given frequency cannot be parsed.
    """
    if frequency is None or frequency == "always":
        return None
    parts = frequency.split()
    if len(parts) != 2:
        raise ValueError("Frequency string must be 'number unit'")
    try:
        number = int(parts[0])
    except ValueError:
        raise ValueError(f"Invalid number: {parts[0]}")
    unit = parts[1]
    unit_to_seconds = {
        'minute': 60,
        'hour': 3600,
        'day': 86400,
        'week': 604800,
        'year': 31536000
    }
    if unit not in unit_to_seconds:
        raise ValueError(f"Invalid unit: {unit}")
    total_seconds = number * unit_to_seconds[unit]
    return datetime.timedelta(seconds=total_seconds)
```

### Explanation
- **Special Cases Handling**: The function immediately returns `None` for `None` or "always" inputs.
- **Input Validation**: The input string is split into two parts. If the split does not result in exactly two parts, a `ValueError` is raised.
- **Number Conversion**: The first part is converted to an integer. If this conversion fails, a `ValueError` is raised.
- **Unit Mapping**: A dictionary maps valid time units to their respective number of seconds, allowing easy conversion of the parsed number into total seconds.
- **Timedelta Creation**: The total number of seconds is used to create a `timedelta` instance, which is then returned.

This approach ensures that the function correctly handles valid inputs and raises appropriate errors for invalid cases, providing a robust solution to the problem.