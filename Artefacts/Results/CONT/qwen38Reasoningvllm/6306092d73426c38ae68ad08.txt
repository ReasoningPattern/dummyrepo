
Okay, I need to generate the Python code for the function _get_conditionally_required_args based on the given function signature and docstring. Let me start by understanding what this function is supposed to do. The docstring says it should list arguments with a required_when condition matched. The parameters are command_name, options_spec, and args. The return is a list of argument names that meet the condition.

First, I need to figure out how the required_when condition is checked. Since the options_spec is a list of command spec options, each option might have a required_when attribute. The function needs to check each option in options_spec to see if the required_when condition is met based on the provided args.

So the steps would be:

1. Iterate over each option in options_spec.
2. For each option, check if it has a 'required_when' key.
3. If it does, evaluate the condition using the provided args.
4. If the condition is met, add the argument name to the result list.

But how is the required_when condition structured? It might be a string that evaluates to a boolean. For example, something like "arg1 is not None" or "arg2 in ['value1', 'value2']". To evaluate these conditions, I can use Python's eval function, but I have to be cautious about security. However, given the context, it's probably safe here.

Wait, but the args are the input arguments. So for each condition in required_when, we need to check if it's true given the current args. So for each option, if required_when is present, we check if the condition is met using the args.

So the code would look something like:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            condition = option['required_when']
            # Evaluate the condition with the current args
            # Need to handle the condition string
            # Maybe using eval with the args as a dictionary?
            # But how to handle the args? Maybe convert args to a dictionary?
            # Assuming args is a dictionary or a namespace
            # For example, if args is a dictionary, then eval(condition, {}, args)
            # But need to be careful with variable names
            # Alternatively, use a context with the args
            # Let's assume that the condition is a string that can be evaluated with the args
            # So, evaluate the condition using the args as variables
            # So, using eval with the args as a dictionary
            # But need to handle possible exceptions, but maybe the function doesn't handle that
            if eval(condition, {}, args):
                required_args.append(option['name'])
    return required_args

Wait, but the args parameter is passed as the third parameter. The function's parameters are command_name, options_spec, and args. So in the code, args is the third parameter. So in the code, the args are the input arguments. But how are they structured? Are they a dictionary? For example, if the args are parsed from command line, they might be a Namespace object from argparse, or a dictionary.

But in the context, there are methods like self.parse_args, which suggests that args might be a dictionary or a similar structure. However, the exact structure isn't clear. But for the purpose of evaluating the required_when condition, perhaps the args are a dictionary where the keys are the argument names, and the values are their values.

But the eval function would need to have access to the variables in args. So, for example, if the condition is "arg1 is not None", then args should have an entry for 'arg1'.

So, in the code, when evaluating the condition, we can pass the args as a dictionary to eval. However, using eval can be dangerous, but given that this is internal code, perhaps it's acceptable.

But wait, the function is part of a class, and the args might be a dictionary. So, in the code, the args are passed as the third parameter. So, the code would be:

for option in options_spec:
    if 'required_when' in option:
        condition = option['required_when']
        if eval(condition, {}, args):
            required_args.append(option['name'])

But wait, the eval function's first argument is the expression, the second is the global namespace, and the third is the local namespace. So, if args is a dictionary, then passing it as the local namespace would allow the variables in the condition to be looked up in args.

But what if the condition uses variables that are not in args? That would raise an error. However, the function's responsibility is to check the condition, so perhaps it's assumed that the condition is valid.

Alternatively, maybe the condition is a string that can be evaluated in the context of the current args. So, the code would use eval with the args as the local variables.

But in Python, eval can be risky. However, given that this is internal code and the conditions are controlled, perhaps it's acceptable.

Another consideration: the options_spec is a list of command spec options. Each option might have a 'name' and 'required_when' key. So, the code loops through each option in options_spec, checks if 'required_when' is present, evaluates the condition, and if true, adds the option's name to the required_args list.

So, putting it all together, the code would be:

def _get_conditionally_required_args(self, command_name, options_spec, args):
    """
    List arguments with ``required_when`` condition matched.

    :param command_name: the command name.
    :param options_spec:  the list of command spec options.
    :param args: the received input arguments
    :return: list, list of argument names with matched ``required_when``
        condition
    """
    required_args = []
    for option in options_spec:
        if 'required_when' in option:
            condition = option['required_when']
            # Evaluate the condition using the args as variables
            # Using eval with args as the local namespace
            try:
                if eval(condition, {}, args):
                    required_args.append(option['name'])
            except Exception as e:
                # Handle any exceptions, maybe log or raise?
                # For now, assume conditions are valid
                pass
    return required_args

But wait, the function is part of a class, and the args might be a dictionary. However, the code uses eval, which could have security implications. But given the context, perhaps it's acceptable.

Another thing to note: the function is called with args as the third parameter. So, in the code, args is the input arguments. So, the code uses args as the local namespace for the eval.

But what if the condition uses variables that are not in args? For example, if the condition is "arg1 and arg2", but arg2 is not present in args. Then, eval would raise a NameError. However, the function may not handle that, but the docstring doesn't mention error handling, so perhaps it's beyond the scope.

So, the code above should work, assuming that the conditions are properly formed and that the args contain all necessary variables.

Another thing: the function is part of a class, so self is available. However, the code doesn't use self in the function, except for the method definition. So, the code is correct.

Therefore, the generated code would be as above.
