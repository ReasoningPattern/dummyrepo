
Okay, I need to create a Python function called parse_version that takes a string s and returns a tuple of integers. The docstring says it converts a string concatenated by dot into a tuple of integers. So, for example, if the input is "1.2.3", the output should be (1, 2, 3).

First, I should think about how to split the string. The string is separated by dots, so splitting on '.' makes sense. Then, each part needs to be converted to an integer. But wait, what if there are leading zeros? Like "01.02.03"? Oh, but the problem says it's a version string, and versions usually don't have leading zeros. However, the function's responsibility is to convert it, so maybe it's okay to just convert each part as is. But wait, if the input is "1.2.3", splitting gives ["1", "2", "3"], then converting each to int gives 1, 2, 3. That's straightforward.

So the steps are: split the string into parts using split('.'), then map each part to an integer. Then, return them as a tuple.

But wait, what if the input is invalid? Like "1.2.3.4.5" with more than three parts? The function's docstring doesn't mention error handling, so maybe we assume the input is valid. The problem says "string concatenated by dot", so perhaps it's safe to assume that the input is properly formatted.

So the code would be something like:

def parse_version(s: str) -> tuple[int, ...]:
    parts = s.split('.')
    return tuple(map(int, parts))

Wait, but the return type is a tuple of integers. The split method returns a list, and map converts each element to int. Then tuple() converts that to a tuple. That should work.

Testing with "1.2.3" would give (1, 2, 3). What about empty string? Well, the function's context might not handle that, but the problem says the input is a version string, so maybe it's not necessary. The function's docstring doesn't mention error handling, so perhaps it's not required.

So the code is straightforward. Let me write that.
