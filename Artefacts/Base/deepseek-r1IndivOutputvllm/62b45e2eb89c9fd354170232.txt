

To solve this problem, we need to generate the next version identifier from a given version string. The version identifier follows a pattern where each part (major, minor, patch) is a number, and we need to increment the version correctly, handling carry-over when a part exceeds 9.

### Approach
The approach involves the following steps:
1. **Split the Version String**: Break the version string into its major, minor, and patch components.
2. **Increment the Patch**: Start by incrementing the patch number. If the patch exceeds 9, it rolls over to 0, and we carry over 1 to the minor part.
3. **Carry Over Minor**: If the minor part exceeds 9 after the increment, it rolls over to 0, and we carry over 1 to the major part.
4. **Carry Over Major**: If the major part exceeds 9 after the increment, it rolls over to 0, and we carry over 1 to a new major part, effectively increasing the version to a higher major level.

This approach ensures that each part is handled correctly, and any overflow is carried over to the next higher part, maintaining the correct version hierarchy.

### Solution Code
```python
def next_version(version):
    parts = list(map(int, version.split('.')))
    if len(parts) < 3:
        parts = [0] * (3 - len(parts)) + parts
    parts[-1] += 1
    i = len(parts) - 1
    while i >= 0 and parts[i] >= 10:
        parts[i] -= 10
        if i == 0:
            parts.insert(0, 1)
            parts.pop()
        else:
            parts[i - 1] += 1
        i -= 1
    return '.'.join(map(str, parts))
```

### Explanation
- **Splitting the Version String**: The version string is split into a list of integers representing major, minor, and patch components.
- **Handling Shorter Versions**: If the version string has fewer than three parts, we pad it with zeros to ensure we always have three parts to work with.
- **Incrementing and Carrying Over**: We start by incrementing the patch. If it exceeds 9, we set it to 0 and increment the minor part. If the minor part then exceeds 9, we set it to 0 and increment the major part. If the major part exceeds 9, we handle it by inserting a new major part and resetting it to 0, effectively increasing the version to the next major level.

This method ensures that each part of the version is incremented correctly, handling all necessary carry-overs to produce the next valid version identifier.