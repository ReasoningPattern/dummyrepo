Okay, I need to write a Python function called round_half_to_even that rounds a floating-point number according to the round half to even rule. Hmm, what's the round half to even method? Oh right, it's also known as banker's rounding. The idea is that when a number is exactly halfway between two integers, it rounds to the nearest even integer. So for example, 2.5 would round to 2, and 3.5 would round to 4. Wait, right?

The standard Python round function uses this method by default, right? Let me confirm. Yes, Python's built-in round function uses the round half to even strategy when the number is equidistant between two integers. So maybe the function can just use the round function directly?

Wait, but the problem says "Generate Python code based on the following function signature and docstring." The function is supposed to round a floating-point number. The existing round function already does that, but maybe the user wants a version that specifically demonstrates this method, perhaps in cases where the default might not be sufficient?

Alternatively, perhaps the function is supposed to return the rounded integer, similar to how the standard round works. Let me think of some test cases. Let's see:

- round_half_to_even(2.5) should return 2.
- round_half_to_even(3.5) should return 4.
- round_half_to_even(1.5) would round to 2, since 2 is even?
Wait, no, 1.5 is halfway between 1 and 2. The even one is 2, so yes, rounds to 2. Wait, but 2.5 is between 2 and 3. 2 is even, so rounds to 2. So the standard round in Python does this?

Wait, let me check what Python's round does. Let me test in my head. Like, in Python:

round(2.5) is 2, and round(3.5) is 4? Let me see, yes. Because 2.5 rounds to 2 (even), and 3.5 rounds to 4 (even). So the built-in function already does this. So maybe the function is as simple as returning round(n)?

But wait, the function's docstring says "Round a floating-point number" which is exactly what the standard round does. So perhaps the function is just a wrapper around the built-in round function? But then why the specific name? Maybe the user wants to make it explicit that this function uses the half to even rule, but since that's the default, perhaps it's just the same as the round function.

Alternatively, maybe there's a scenario where someone might be using a different rounding method, like round half away from zero, and they want this function to use the banker's rounding instead. But in Python, the default is already banker's rounding, so this function would just be an alias.

Wait, the problem says "Generate Python code based on the following function signature..." So the function must have the name round_half_to_even and take a single argument n, and return the rounded number using that method.

Therefore, the code can be as simple as:

return round(n)

But maybe I should check if that's correct. Let's see some examples.

Test case 1: n = 2.5 → round(2.5) gives 2. Correct.

Test case 2: n = 3.5 → round(3.5) is 4. Correct.

Another case: 1.5 → round(1.5) is 2.

What about 4.5? That should round to 4 or 6? Wait, 4.5 is between 4 and 5. The even one is 4, so round(4.5) would be 4? Let me check in Python. Oh, yes, round(4.5) is 4. Okay, so the built-in function works correctly here.

What about numbers that are not halfway? Like 1.4 should round to 1, 2.6 to 3, etc. The function would handle those normally. So in this case, the function can indeed just return round(n). 

Wait, but the function's name is round_half_to_even, implying that it's specifically handling the half cases. But the standard round does that. So maybe the function is just a direct call to round. 

Therefore, the code would be straightforward. The function's docstring is brief, so perhaps that's all that's needed. 

Wait, but maybe the problem expects more? Like, perhaps when the number is exactly halfway between two integers, but for other cases, it uses standard rounding? Well, the standard round already does that. So I think using the built-in is correct here.

So the code would be:

def round_half_to_even(n):
    """
    Round a floating-point number
    """
    return round(n)

That's it. Let me think if there's any edge cases where this might not work. What about negative numbers? Let's see. For example, -2.5: round(-2.5) would be -2, which is even. That's correct. 

Another test: 2.3 → rounds to 2. 2.7 rounds to 3? Wait, no, 2.7 rounded to 0 decimal places would be 3. Wait, the function's name doesn't specify the number of decimal places. The function signature says it takes a single float n, so the function should round to the nearest integer. The standard round function, when given one argument, rounds to the nearest integer, using the half to even rule. 

So yes, the code is correct as simply returning round(n). I think that's the solution here. No need for any extra logic. Just use the built-in function.
