
Okay, let's see. I need to generate Python code for the function find_tags based on the given signature and docstring. The function is supposed to find tags in text, ignoring those inside code blocks. Also, there's an optional replacer function that can replace the tags.

First, I should figure out what constitutes a tag. The docstring mentions tags, but doesn't specify. Maybe tags are words enclosed in some delimiters? Like maybe they're words starting with a specific character, such as # or @? Or perhaps they're keywords in a certain format. Since the problem is about ignoring tags inside code blocks, maybe the tags are something like inline code markers, but that's unclear.

Wait, the function's purpose is to find tags in text, but ignore those inside code blocks. So perhaps the text has some code blocks, and within those, tags shouldn't be considered. For example, if the text has code blocks marked with triple backticks, then any tags inside those should be excluded.

But how to define a tag? Maybe the tags are words that start with a certain prefix, like #tag. Or maybe they're specific keywords. The problem is not very specific. However, the replacer function is called with the tag word, so the function needs to identify the tags first.

Alternatively, maybe the tags are enclosed in angle brackets, like <tag>, but that's just a guess. Or perhaps they're markdown-style tags, like [[tag]]? Without more info, it's hard to say. But given that the function is supposed to ignore tags inside code blocks, perhaps the code blocks are marked in a certain way, and the tags are something else.

Wait, maybe the tags are similar to markdown links or something else. Let me think. The function returns a set of tags and the modified text. So, the idea is to scan the text, find all tags (maybe words with certain patterns), but skip those that are inside code blocks. Then, if a replacer is provided, replace each tag with the result of applying that function to the tag.

So, the steps would be:

1. Split the text into parts, identifying code blocks.
2. Within non-code blocks, find all tags.
3. If a replacer is given, replace each tag with the replacer's output.
4. Return the set of tags and the modified text.

But how to split into code blocks? Let's assume that code blocks are enclosed in triple backticks, like:

```
This is a code block.
```

So, the text might have regions that are code blocks, and the function should not process tags inside those.

So, the approach could be to split the text into code blocks and regular text. Then, process the regular text parts for tags.

But how to do that in Python? Maybe using regular expressions to find code blocks and then process the rest.

Alternatively, perhaps the code blocks are marked with some specific syntax, like ```python or ```code. But again, without specifics, it's hard. Maybe the code blocks are any text enclosed in triple backticks, and the rest is normal text.

So, first, I need to split the text into code blocks and non-code blocks. Then, in the non-code parts, find tags.

But what defines a tag? Let's assume that tags are words that start with a certain pattern, like # or @, or maybe any word that matches a certain regex. However, since the function is called find_tags, perhaps the tags are specific to some format, like in markdown, but again, not sure.

Alternatively, maybe the tags are any occurrences of a certain pattern, like words in brackets or something. But the problem is not clear. Since the user hasn't provided specific examples, I need to make some assumptions.

Let me think of the simplest way. Let's say that tags are words that are enclosed in angle brackets, like <tag>, but that's just a guess. Or maybe they are words that start with a #, like #tag. But again, not sure.

Alternatively, perhaps the tags are any sequence of characters that match a certain pattern, and the code blocks are marked with triple backticks. So, the plan is:

- Split the text into code blocks and other parts.
- For each non-code part, find all tags (maybe using regex).
- Collect these tags into a set.
- If a replacer is provided, replace each tag in the original text with the replacer's result, but only in the non-code parts.
- Return the set and the modified text.

But how to split the text into code blocks? Let's use regular expressions to find all code blocks. For example, using a regex that matches triple backticks and the content in between.

So, the code could first split the text into code blocks and other text. Then, process the other text for tags.

Let me outline the steps:

1. Use regex to find all code blocks. For example, using re.findall with a pattern like ```(.*?)``` but need to handle possible newlines and multiple code blocks.

Wait, but code blocks can have multiple lines. So, perhaps the regex is something like:

code_block_pattern = r'```[\s\S]*?```'

But that might not capture all cases. Alternatively, using a regex that matches triple backticks and captures the content between them.

But then, the code blocks could be in the text, and the rest is normal text. So, the code would split the text into parts that are code blocks and parts that are not.

Once the code blocks are identified, the function can process the non-code parts for tags.

Now, for finding tags in the non-code parts. Let's assume that tags are words that start with a #, like #tag. But again, not sure. Alternatively, maybe they are enclosed in some delimiters.

Alternatively, perhaps the tags are any words that are in a specific format, like [[tag]] or something else. But without knowing, I need to make an assumption.

Alternatively, maybe the tags are any sequence of characters that are not inside code blocks, and the replacer is applied to them. But the function's name is find_tags, so it's supposed to find them and possibly replace.

Alternatively, maybe the tags are just any word, but that's not helpful. Since the problem is vague, perhaps I should look for a common scenario. For example, in markdown, tags might be like #tag, but code blocks are enclosed in triple backticks. So, the function would process the text, find all #tags outside of code blocks, and replace them if a replacer is provided.

But how to handle that? Let's proceed with this assumption.

So, the plan:

- Split the text into code blocks and other text.
- For each non-code block part, find all tags (e.g., words starting with #).
- Collect these tags into a set.
- If a replacer is provided, replace each tag in the original text with the replacer's output, but only in the non-code parts.
- Return the set and the modified text.

But how to split the text into code blocks and other parts? Let's use a regex to find all code blocks. For example, using re.split to split the text into code blocks and other parts. However, splitting might not be the best approach because we need to keep track of the code blocks and the other parts.

Alternatively, we can use a regex to find all code blocks and then process the remaining text.

Let me think of using re.finditer to find all code blocks. Then, iterate through the text, and for each part not in a code block, find tags.

But how to handle overlapping or nested code blocks? Probably, the code blocks are not nested, so the regex can be used.

So, first, split the text into code blocks and non-code blocks. For example, using a regex that matches code blocks, and then the rest is non-code.

Once we have the non-code parts, we can search for tags in them. Let's say tags are words starting with #, but maybe they are in a specific format. For example, using a regex like #\w+ to find tags.

But perhaps the tags are more complex. For example, maybe they are enclosed in angle brackets, like <tag>, or something else. However, since the problem is not specific, I'll proceed with the assumption that tags are words starting with #, and code blocks are enclosed in triple backticks.

So, the code steps:

- Use re.finditer to find all code blocks. The pattern would be ```(.*?)``` but need to handle possible newlines. So, using re.DOTALL flag.

Wait, but the code blocks could have multiple lines. So, the regex pattern would be r'```[\s\S]*?```' with re.DOTALL.

Once the code blocks are found, the rest of the text is processed for tags.

But how to split the text into code blocks and non-code parts? Let's use a list to collect all the code blocks and the non-code parts.

For example:

import re

def find_tags(text: str, replacer: callable = None) -> Tuple[Set[str], str]:
    code_blocks = re.finditer(r'```[\s\S]*?```', text, re.DOTALL)
    # Then, split the text into parts outside code blocks
    # Maybe using split with a regex that matches code blocks, but then we need to track the code blocks and the rest.

Alternatively, perhaps using a regex to split the text into code blocks and other parts, then process each part.

But perhaps a better approach is to iterate through the text, keeping track of whether we are inside a code block or not. For example:

Initialize a list to hold the parts. Then, iterate through the text, checking for code block start and end.

But that could be complicated. Alternatively, using re.split to split the text into code blocks and other parts. However, splitting would lose the code blocks' positions, so maybe not.

Alternatively, using a regex to find all code blocks and then process the text outside of them.

But perhaps the code blocks are to be excluded, so the function can process the text, but when it's inside a code block, it skips processing tags.

So, the approach could be:

- Split the text into code blocks and other parts. For example, using re.split to split on code blocks, but then we need to know where the code blocks are to exclude them.

Alternatively, using a regex to find all code blocks and then process the text outside of them.

But how to do that? Maybe using a regex that matches code blocks and then the rest is processed.

Alternatively, use a regex to find all code blocks, then for the remaining text, find tags.

But perhaps the code blocks are to be excluded from the tag search. So, the function would first find all code blocks, then process the rest of the text for tags.

But how to extract the non-code parts? Let's think of using re.split to split the text into parts that are code blocks and parts that are not. For example:

parts = re.split(r'```[\s\S]*?```', text)

But this would split the text into the parts outside code blocks. However, the code blocks themselves are not included in the parts. Wait, no. The split would split on the code blocks, so the parts would be the text before the first code block, between code blocks, and after the last code block. The code blocks themselves are not in the parts.

But then, how to process the code blocks? Well, maybe the code blocks are not processed for tags. So, the function can process the non-code parts for tags.

But then, the code blocks are not part of the text to process. So, the code would:

- Split the text into non-code parts and code blocks.
- For each non-code part, find tags.
- Collect all tags into a set.
- Then, replace the tags in the original text with the replacer's output, but only in the non-code parts.

But how to replace the tags in the original text? Because splitting and then processing may not preserve the original structure. So, perhaps we need to process the text in a way that allows us to replace the tags while keeping the code blocks intact.

So, maybe the code can be structured as follows:

1. Split the text into code blocks and non-code parts. For example, using a regex to find all code blocks and then the non-code parts are the text between them.

But how to split the text into code blocks and the rest? Let me think of using a regex that matches code blocks and captures them, then the rest is the non-code parts.

Alternatively, using a regex to find all code blocks, then for the text outside of them, find tags.

But then, how to reconstruct the text with replacements? Because the code blocks are not part of the text to process, but the non-code parts are.

So, perhaps the code can be:

- Find all code blocks in the text.
- Then, for the text outside code blocks, find all tags and collect them.
- Then, replace the tags in the original text with the replacer's output, but only in the non-code parts.

But how to do that? Let me think of using a regex to find all tags in the non-code parts, then replace them.

But perhaps the code blocks are to be excluded from the tag search, but the tags could be in other parts. So, the code could:

- Iterate through the text, and for each part that is not inside a code block, find tags.

But how to track whether we are inside a code block or not. Maybe using a state machine approach.

Alternatively, using a regex that matches code blocks and then uses a regex to find tags in the remaining text.

But perhaps the code can be written as:

Use re.sub to replace tags in the non-code parts. But how to do that.

Alternatively, here's a possible approach:

- Use a regex to find all code blocks. Then, split the text into code blocks and the rest. For example, using re.split with a regex that matches code blocks, but then we need to know where they are.

Wait, perhaps using re.split to split the text into code blocks and non-code parts. Let's say that the code blocks are split into parts, and the non-code parts are the other segments.

For example:

text_parts = re.split(r'```[\s\S]*?```', text)

But this would split the text into parts that are outside code blocks. However, the code blocks themselves are not in the parts. So, perhaps we can collect the code blocks and then process the non-code parts.

But then, how to reconstruct the text with replacements? Because the code blocks are not part of the non-code parts, and the replacements are only done in the non-code parts.

So, the steps would be:

1. Split the text into code blocks and non-code parts. For example, using re.split to get the non-code parts, and then collect the code blocks separately.

Wait, but splitting with re.split would split the text into parts that are not code blocks, and the code blocks are the separators. So, for example, if the text is:

"Normal text. ```code block``` More normal text. ```another code block```"

Then re.split(r'```[\s\S]*?```', text) would split into ["Normal text. ", " More normal text. ", ""].

But then, the code blocks are the separators. So, perhaps the code can process the non-code parts, find tags in them, and then replace them, then recombine the parts with the code blocks in between.

But how to do that? Let me think of using re.split to split the text into non-code parts and code blocks. Then, for each non-code part, process it for tags and replace them. Then, recombine the parts with the code blocks.

But the code blocks are the separators. So, the code can be:

non_code_parts = re.split(r'```[\s\S]*?```', text)

But then, the code blocks are the parts that were split. Wait, no. The split would split on the code blocks, so the code blocks are not included in the non_code_parts. So, to get the code blocks, we can use re.finditer.

Alternatively, perhaps using a regex to find all code blocks and then process the text between them.

But perhaps the code can be structured as follows:

- Find all code blocks using re.finditer.
- Then, iterate through the text, keeping track of whether we are inside a code block or not.
- For each segment of text that is not inside a code block, find tags and replace them if a replacer is provided.

But how to do that? Maybe using a list to collect the segments of text, and then process each segment.

Alternatively, using a regex that matches code blocks and then uses a callback to process the text outside of them.

This seems complicated. Let me think of an alternative approach.

Another idea: use a regex to find all tags, but also check if they are inside code blocks. But how to do that? Because code blocks can be anywhere, and tags can be inside them.

Alternatively, the code can process the entire text, but when inside a code block, ignore any tags. So, perhaps using a regex that matches code blocks and then uses a regex to find tags in the remaining text.

But how to do that in Python. Maybe using a regex that matches code blocks and then uses a substitution function that replaces tags only when not inside code blocks.

Alternatively, perhaps using a regex that matches code blocks and then uses a regex to find tags in the text outside of them.

But perhaps the code can be written using a regex to find all code blocks, then split the text into parts that are inside and outside code blocks. Then, process each non-code part for tags.

But how to split the text into code blocks and non-code parts. Let me think of using re.split with a regex that captures the code blocks. For example, using a regex with a capture group.

So:

pattern = r'(```[\s\S]*?```)'
code_blocks = re.finditer(pattern, text)

But then, the code can split the text into code blocks and the rest. However, perhaps using a regex that splits the text into code blocks and non-code parts, and then process the non-code parts.

Alternatively, perhaps using a regex to find all code blocks and then process the text between them.

But perhaps the code can be written as follows:

- Use a regex to find all code blocks. For example, using re.finditer to get all code blocks.
- Then, split the text into segments that are outside code blocks.
- For each segment, find all tags (e.g., words starting with #) and collect them.
- Then, replace the tags in the original text with the replacer's output, but only in the non-code segments.

But how to split the text into segments outside code blocks. Let me think of using the start and end indices of the code blocks.

For example, using re.finditer to get all code blocks, then iterate through the text, and for each part that is not inside a code block, process it for tags.

So, the code would:

import re
from typing import Tuple, Set

def find_tags(text: str, replacer: callable = None) -> Tuple[Set[str], str]:
    # Find all code blocks
    code_blocks = list(re.finditer(r'```[\s\S]*?```', text, re.DOTALL))
    # Split the text into non-code parts
    non_code_parts = []
    start = 0
    for match in code_blocks:
        end = match.start()
        non_code_part = text[start:end]
        non_code_parts.append(non_code_part)
        start = match.end()
    # Add the remaining text after the last code block
    non_code_parts.append(text[start:])
    
    # Now, process each non-code part for tags
    tags = set()
    modified_parts = []
    for part in non_code_parts:
        # Find all tags in this part
        # Assuming tags are words starting with #
        tag_matches = re.findall(r'#\w+', part)
        tags.update(tag_matches)
        # Replace tags with replacer if provided
        if replacer:
            # Replace each tag with replacer(tag)
            # But how to do that? Using re.sub with a function
            modified_part = re.sub(r'#\w+', lambda m: replacer(m.group(0)), part)
        else:
            modified_part = part
        modified_parts.append(modified_part)
    
    # Reconstruct the modified text by combining non-code parts and code blocks
    modified_text = ''
    for i, part in enumerate(non_code_parts):
        modified_text += modified_part
        if i < len(code_blocks):
            modified_text += code_blocks[i].group(0)
    
    return tags, modified_text

Wait, but the code_blocks list contains the matches, and the non_code_parts are the parts between them. So, when reconstructing, we need to interleave the modified non-code parts with the code blocks.

But in the code above, after processing each non_code_part, we add the modified_part, then add the code block if it's not the last one. But the code_blocks list is the same length as non_code_parts minus one? Or maybe not. Let me think: for example, if the text starts with a code block, then non_code_parts would be the first part (before the first code block), then the code block is in code_blocks[0], then the next non_code_part is between the first and second code block, etc. So, the number of code_blocks is equal to the number of non_code_parts minus one? Or maybe not. For example, if the text has three code blocks, then non_code_parts would be four parts: before first, between first and second, between second and third, after third.

So, when reconstructing, for each non_code_part, we add the modified part, then add the code block if there are more code blocks to come.

But in the code above, the loop is for i, part in enumerate(non_code_parts), and then if i < len(code_blocks), add code_blocks[i].group(0). That would be incorrect. Because len(non_code_parts) is len(code_blocks) + 1. So, for example, if there are 2 code blocks, non_code_parts has 3 elements. So, in the loop, for i from 0 to 2, and code_blocks has 2 elements. So, for i < 2, add code_blocks[i].group(0). But that would add the code blocks in between the non_code_parts. However, the code_blocks are in the original text, so when we split, the non_code_parts are the parts outside code blocks. So, the code_blocks are the separators. Therefore, when reconstructing, after each non_code_part (except the last one), we add the code block. So, the code should be:

modified_text = ''
for i, part in enumerate(non_code_parts):
    modified_text += modified_part
    if i < len(code_blocks):
        modified_text += code_blocks[i].group(0)

But this would add the code blocks after each non_code_part except the last one. However, the code_blocks list is the list of all code blocks found. So, the number of code_blocks is equal to the number of code blocks in the text. The non_code_parts is the list of text segments outside code blocks. So, if there are N code blocks, non_code_parts has N+1 elements.

So, the loop would be:

for i in range(len(non_code_parts)):
    modified_text += modified_parts[i]
    if i < len(code_blocks):
        modified_text += code_blocks[i].group(0)

Yes. Because for each non_code_part, after adding it, if there's a code block following it (i < len(code_blocks)), then add the code block.

But this approach may not work if the code blocks are overlapping or nested, but assuming that code blocks are properly formatted and not nested.

But how to handle the code blocks correctly. Let me think of an example.

Original text: "This is normal text. ```code block``` This is another part. ```another code block```"

non_code_parts would be ["This is normal text. ", " This is another part. ", ""].

code_blocks would be the two matches: the first code block and the second.

So, when reconstructing:

modified_text starts as empty.

i=0: add modified_part (the first non_code_part), then add code_blocks[0].

i=1: add modified_part (second non_code_part), then add code_blocks[1].

i=2: add modified_part (third non_code_part), no code block added.

So, the modified_text would be the first non_code_part processed, then the code block, then the second non_code_part processed, then the code block, then the third non_code_part processed.

Which would reconstruct the original text with the code blocks in place.

But in this case, the code_blocks are in the original text, so when we split, the code_blocks are the separators. So, the code_blocks list is the list of all code blocks found.

But how to split the text into non_code_parts and code_blocks. Maybe using re.split with a regex that captures the code blocks.

Alternatively, using re.split with a regex that matches code blocks, and then using the split parts and the code blocks.

But perhaps using re.split is not the best approach. Maybe using re.finditer to find all code blocks and then split the text accordingly.

So, the code would:

- Iterate through the text, find all code blocks, and split the text into non-code parts.

Once that's done, process each non-code part for tags.

But what if the code blocks are not properly closed? Well, the problem says to "try to ignore tags inside code blocks", so perhaps the code can assume that code blocks are properly formatted.

Now, the next part is finding tags in the non-code parts. Assuming that tags are words starting with #, like #tag.

So, in each non_code_part, find all occurrences of #\w+.

But what if the tags have other characters, like #tag123 or #tag_with_underscore? The regex r'#\w+' would miss those. So, perhaps a better regex is r'#\w+|\$[^$]+\$' or something else. But again, without specific info, it's hard.

But given the function's name is find_tags, and the replacer is called with the tag word, maybe the tags are simply words that start with #, and the replacer is applied to each such word.

So, the code for finding tags would be re.findall(r'#\w+', part).

But then, the replacer would be called with the tag word, which is the entire match, like '#tag'.

But the problem says that the replacer is called with the tag word. So, if the tag is '#tag', then the replacer is called with 'tag' as the argument? Or with the entire string?

The docstring says: "if passed a 'replacer', will also replace the tag word with the result of the replacer function called with the tag word."

So, the replacer is called with the tag word. So, if the tag is '#tag', then the replacer is called with 'tag' as the argument. Wait, but the function's parameter is called with the tag word. So, perhaps the tag is the entire string, like '#tag', and the replacer is called with that.

But the example is not given, so I need to make an assumption.

Alternatively, maybe the tag is the part after the #, like 'tag'.

But the docstring says "the tag word", which could mean the entire tag, including the #.

But the replacer function is called with the tag word. So, if the tag is '#tag', then the replacer is called with '#tag' as the argument.

But the user may want to replace the entire tag, so the code would use re.sub to replace each occurrence of the tag with the replacer's output.

So, in the code, for each non_code_part, we find all tags (like #\w+), and replace them with replacer(tag).

But then, how to handle overlapping or multiple tags in a single part.

So, the code would use re.sub with a function that replaces each tag with the replacer's output.

But what if the replacer is None? Then, the text is not modified.

So, the code for replacing would be:

modified_part = re.sub(r'#\w+', lambda m: replacer(m.group(0)) if replacer else m.group(0), part)

Wait, but if replacer is None, then we don't replace, so the original text is kept. So, the code would be:

if replacer:
    modified_part = re.sub(r'#\w+', lambda m: replacer(m.group(0)), part)
else:
    modified_part = part

But that would replace all #tags in the non_code_part with the replacer's output. However, the original text may have other tags, but the problem says to find tags, so perhaps the regex is correct.

But what about other tags? For example, if the text has @tags or something else. But the function is called find_tags, so maybe the tags are specific. But since the problem is not clear, I need to proceed with an assumption.

So, the code would:

- Find all code blocks.
- Split the text into non-code parts.
- For each non-code part, find all tags (e.g., #\w+).
- Collect all tags into a set.
- Replace each tag in the non-code parts with the replacer's output if provided.
- Reconstruct the text by combining the modified non-code parts and the code blocks.

But how to handle the code blocks. For example, if the code blocks are in the original text, they are not modified. So, when reconstructing, we just add them back in.

Now, the code for splitting the text into non-code parts and code blocks.

Let me think of using re.finditer to find all code blocks, then split the text into parts.

So, code_blocks = list(re.finditer(r'```[\s\S]*?```', text, re.DOTALL))

Then, start = 0.

non_code_parts = []
for match in code_blocks:
    end = match.start()
    non_code_part = text[start:end]
    non_code_parts.append(non_code_part)
    start = match.end()

non_code_parts.append(text[start:])

Then, for each non_code_part, process for tags.

But what if the code blocks are not properly closed? Well, the problem says to "try to ignore tags inside code blocks", so perhaps the code can assume that code blocks are properly formatted.

Once the non_code_parts are collected, then for each part, find all tags.

Now, the tags are collected as a set. So, for each non_code_part, we find all tags (using re.findall) and add them to the set.

Then, replace the tags in the non_code_part with the replacer's output.

But when replacing, we need to make sure that the tags are replaced in the original text. So, the code would process each non_code_part, replace the tags, and then combine them with the code blocks.

But how to handle the replacement correctly. For example, if the non_code_part is "This is #tag1 and #tag2", then after replacement, it becomes "This is replaced1 and replaced2".

So, the code for replacement would be using re.sub with a function that replaces each tag with the replacer's output.

Now, putting it all together.

But what about the case where the text has no code blocks? Then, non_code_parts would be [text], and code_blocks is empty. So, the loop would add the modified_part, and then no code blocks.

Now, the code for the function:

import re
from typing import Tuple, Set

def find_tags(text: str, replacer: callable = None) -> Tuple[Set[str], str]:
    code_blocks = list(re.finditer(r'```[\s\S]*?```', text, re.DOTALL))
    non_code_parts = []
    start = 0
    for match in code_blocks:
        end = match.start()
        non_code_parts.append(text[start:end])
        start = match.end()
    non_code_parts.append(text[start:])
    
    tags = set()
    modified_parts = []
    for part in non_code_parts:
        # Find all tags in this part
        tag_matches = re.findall(r'#\w+', part)
        tags.update(tag_matches)
        # Replace tags with replacer
        if replacer:
            modified_part = re.sub(r'#\w+', lambda m: replacer(m.group(0)), part)
        else:
            modified_part = part
        modified_parts.append(modified_part)
    
    # Reconstruct the modified text
    modified_text = ''
    for i, part in enumerate(non_code_parts):
        modified_text += modified_parts[i]
        if i < len(code_blocks):
            modified_text += code_blocks[i].group(0)
    
    return tags, modified_text

Wait, but in the code above, when reconstructing, the code_blocks are in the original text. So, the code_blocks list contains the actual code block strings. So, when we add them back, we are inserting them into the modified text.

But what if the code blocks are not properly closed? Well, the problem says to "try to ignore tags inside code blocks", so perhaps the code can assume that the code blocks are properly formatted.

But this code may have some issues. For example, if the text starts with a code block, then the first non_code_part is empty. Similarly for the end.

Testing this code with some examples.

Example 1: text with no code blocks.

text = "This is a #tag and another #tag2."

non_code_parts = [text], code_blocks is empty.

tags would be {'#tag', '#tag2'}, modified_parts would be the same as non_code_parts, since no code blocks. Then, modified_text is the same as the original text.

But if replacer is provided, then the tags are replaced.

Example 2: text with code blocks.

text = "Normal text. ```code block``` #tag inside normal text."

non_code_parts would be ["Normal text. ", " #tag inside normal text."]

Wait, no. Let me think again. The code_blocks are the matches of ```...```. So, in the example text, the first code block starts at index 10 (assuming "Normal text. " is before the code block). Then, the non_code_parts would be:

start = 0.

First match is from start to end of code block. So, for the first match, end is the start index of the code block. So, non_code_parts.append(text[0:end]) which is "Normal text. ".

Then, start is set to match.end() which is the end of the code block. Then, the next non_code_part is text[start:] which is "#tag inside normal text."

So, the code would process "Normal text. " for tags, which would find #tag? No, because the first non_code_part is "Normal text. " which doesn't have a #tag. Then, the second non_code_part is "#tag inside normal text." which would have the tag #tag.

So, tags would be {'#tag'}, and the modified text would be "Normal text. ```code block``` replaced inside normal text."

But the code would replace the #tag in the second non_code_part.

But the code_blocks are added back in the reconstruction.

So, the code seems to handle that.

But what about tags that are inside code blocks? Well, the code_blocks are split out, so the non_code_parts do not include them. So, tags inside code blocks are not processed.

Now, the problem is that the code_blocks may have newlines and other characters. But the regex for code blocks is ```[\s\S]*?``` which matches any characters (including newlines) between triple backticks.

But what about cases where the code blocks are not properly closed? Well, the function may not handle that, but the problem says to "try to ignore tags inside code blocks", so perhaps the code can assume that code blocks are properly formatted.

Now, the code for the function. But the code has to return a set of tags and the modified text.

But what about overlapping code blocks? Well, the regex would match them as separate.

Now, the code may have some issues. For example, if the code blocks are not properly closed, the regex may not match them correctly. But again, the problem says to try to ignore, so perhaps it's acceptable.

But what if the text has code blocks that are not enclosed in triple backticks? Well, the function's code is based on the assumption that code blocks are enclosed in triple backticks.

Another thing: the code uses re.DOTALL, which allows the . to match newlines. So, the regex for code blocks is correct.

Now, the code for finding tags is using r'#\w+', which matches # followed by word characters. But maybe the tags have more complex patterns. However, given the lack of specific info, this is a reasonable assumption.

But perhaps the tags are not just # followed by word characters. For example, maybe they are in brackets, like [tag], or something else. But without knowing, I have to proceed with this assumption.

So, the code would collect all #tags in the non-code parts, and replace them if a replacer is provided.

But the replacer function is called with the tag word. So, for example, if the tag is '#tag', then replacer is called with '#tag'.

But the user may want to replace the tag word (like the entire string), so the code is correct.

Now, what about the case where the text has multiple tags? The code uses re.findall to collect all tags in each non_code_part and adds them to the set.

Now, testing the code with some examples.

Another thing: the function returns a set of tags and the modified text. The modified text is the original text with tags replaced in non-code parts.

But the code is using the non_code_parts and then reconstructing the text by adding the code blocks. However, in the code above, the code_blocks are added back in the original form. So, the code blocks are not modified.

But what about the code blocks themselves? For example, if a code block contains a tag, but according to the problem, tags inside code blocks should be ignored. So, the code_blocks are not processed for tags.

Now, the code seems to handle that.

But there's a problem: the code uses re.finditer to get the code blocks, but when reconstructing, it's adding the code_blocks[i].group(0), which is the original code block. So, the code blocks are kept as-is.

But what if the code blocks have other tags? Well, the problem says to ignore tags inside code blocks, so they are not processed.

Now, the code seems to handle that.

But what about the replacer function? For example, if the replacer is a function that takes the tag word and returns a replacement. So, in the code, the lambda m: replacer(m.group(0)) would call the replacer with the entire tag string.

But the docstring says that the replacer is called with the tag word. So, perhaps the tag word is the part after the #. For example, if the tag is '#tag', then the tag word is 'tag'.

In that case, the code would need to extract the tag word from the match. But the current code is passing the entire tag (including the #) to the replacer. So, if the user wants to replace the tag word (without the #), then the code is incorrect.

But the docstring says "the tag word", which could be ambiguous. However, given that the replacer is called with the tag word, perhaps the tag is the entire string, including the #.

But to confirm, the docstring says: "if passed a 'replacer', will also replace the tag word with the result of the replacer function called with the tag word."

So, the replacer is called with the tag word. So, for example, if the tag is '#tag', then the replacer is called with '#tag'.

But perhaps the user wants to replace the tag without the #. For example, if the tag is '#tag', then the replacer is called with 'tag'.

But without more info, it's hard to say. However, the code as written would replace the entire tag, including the #. So, if the user wants to replace the tag word (without the #), then the code needs to adjust the regex.

But given that the problem is not specific, I'll proceed with the assumption that the tag is the entire string, including the #.

But perhaps the user considers the tag as the part after the #. So, the code would need to extract that.

In that case, the regex for finding tags would be r'#(\w+)', and then the tag word is the group 1. Then, the replacer is called with group 1.

But the code currently uses r'#\w+', which would match the entire tag. So, the code would need to adjust.

But the problem says that the replacer is called with the tag word. So, perhaps the tag word is the part after the #.

So, modifying the code:

In the regex for finding tags, use r'#(\w+)' and then extract group 1.

But then, the replacement would be to replace the entire tag (like #tag) with the replacer's output. So, the lambda would be lambda m: replacer(m.group(1)).

But this requires adjusting the regex.

So, the code would:

tag_matches = re.findall(r'#(\w+)', part)

tags.update(tag_matches)

Then, for replacement, use re.sub(r'#(\w+)', lambda m: replacer(m.group(1)), part)

But this would replace the tag with the replacer's output, passing the tag word (without the #) to the replacer.

But the docstring says that the replacer is called with the tag word. So, this seems more accurate.

So, modifying the code accordingly.

But the original code uses r'#\w+', which would match the entire tag. So, if the user wants to replace the tag word (without the #), then the code needs to adjust.

But the problem is that the user's docstring is ambiguous. However, given that the function is called find_tags, and the replacer is applied to the tag word, perhaps the tag is the entire string, including the #.

But I'm not sure. Let me think again.

The function's docstring says: "if passed a 'replacer', will also replace the tag word with the result of the replacer function called with the tag word."

So, the replacer is called with the tag word. For example, if the tag is '#tag', then the replacer is called with 'tag'.

So, the code should extract the tag word (without the #) and pass it to the replacer.

Therefore, the regex for finding tags should be r'#(\w+)', and then the tag word is group 1.

So, modifying the code:

In the find_tags function:

tag_matches = re.findall(r'#(\w+)', part)

tags.update(tag_matches)

Then, for replacement:

modified_part = re.sub(r'#(\w+)', lambda m: replacer(m.group(1)), part)

But then, the replacement would be to replace the entire tag (like #tag) with the replacer's output. So, the code would replace #tag with whatever the replacer returns for 'tag'.

This seems more correct.

So, adjusting the code accordingly.

But then, the code would have to find all occurrences of # followed by word characters, and extract the word part.

So, the code would be:

import re
from typing import Tuple, Set

def find_tags(text: str, replacer: callable = None) -> Tuple[Set[str], str]:
    code_blocks = list(re.finditer(r'```[\s\S]*?```', text, re.DOTALL))
    non_code_parts = []
    start = 0
    for match in code_blocks:
        end = match.start()
        non_code_parts.append(text[start:end])
        start = match.end()
    non_code_parts.append(text[start:])
    
    tags = set()
    modified_parts = []
    for part in non_code_parts:
        # Find all tags in this part
        tag_matches = re.findall(r'#(\w+)', part)
        tags.update(tag_matches)
        # Replace tags with replacer
        if replacer:
            modified_part = re.sub(r'#(\w+)', lambda m: replacer(m.group(1)), part)
        else:
            modified_part = part
        modified_parts.append(modified_part)
    
    # Reconstruct the modified text
    modified_text = ''
    for i, part in enumerate(non_code_parts):
        modified_text += modified_parts[i]
        if i < len(code_blocks):
            modified_text += code_blocks[i].group(0)
    
    return tags, modified_text

But this code would replace the #tag with the replacer's output for 'tag'.

But what if the tag has other characters, like #tag123 or #tag_with_underscore? The regex r'#(\w+)' would not match those, because \w+ does not include underscores. Wait, \w includes underscores, right? In Python regex, \w matches [a-zA-Z0-9_], so #tag_with_underscore would be matched as 'tag_with_underscore'.

But if the tags can have other characters, like hyphens or periods, then the regex is not sufficient. However, given the lack of specific info, this is a reasonable assumption.

Now, the code seems to handle that.

But what about cases where the text has multiple tags? For example, "This is #tag1 and #tag2." would collect 'tag1' and 'tag2' into the set.

Another thing to consider: the code may have overlapping code blocks or other edge cases, but the problem says to "try to ignore tags inside code blocks", so the code should handle that.

Now, the code is written. But the user's function signature returns a Tuple[Set, str], which is correct.

But what about the case where the text has no code blocks? Then, code_blocks is empty, and non_code_parts is [text]. The loop for reconstructing would add modified_parts[0], and since i < len(code_blocks) is 0 < 0, which is false, so no code blocks are added. So, modified_text is the modified_parts[0], which is correct.

Another example: text with code blocks and tags.

Original text: "This is a #tag. ```code block with #tag inside``` Another #tag."

The code_blocks would be the part "```code block with #tag inside```".

non_code_parts would be ["This is a #tag.", " Another #tag."].

Processing the first non_code_part: tag_matches is ['tag'], so tags = {'tag'}.

modified_part would be replaced with replacer('tag') if provided.

Then, the second non_code_part: tag_matches is ['tag'], so tags is {'tag'}.

modified_text would be the first modified_part + code_block + second modified_part.

So, the final modified_text would have the tags replaced in the non-code parts, and the code block remains as-is.

This seems to work.

Now, the code uses the re module, and the typing module.

But what about the case where the code block is not properly closed? For example, if the text has a code block that is not closed. The regex would match up to the first occurrence of ``` and then the rest would be considered as non-code part. But the problem says to try to ignore tags inside code blocks, so perhaps the code can assume that code blocks are properly closed.

Now, the code seems to handle the requirements.

But the code has to be written in Python, and the function returns a tuple of a set and a string.

So, the code is as above.

But the code uses re.finditer to find code blocks, then splits the text into non-code parts. Then, for each non-code part, finds the tags, collects them into a set, and replaces them if a replacer is provided.

But what about the replacer function? It's supposed to be a callable. So, the code passes the tag word (without the #) to the replacer.

But the user may have a different definition of tag. However, given the lack of specific info, this is a reasonable approach.

Another thing: the code may have to handle multiple tags in a single non-code part. The code uses re.findall to collect all tags, and adds them to the set.

So, the code seems to meet the requirements.

Now, the user wants the code to be generated based on the function signature and docstring. The code should not include any explanation, just the code.

So, the final code would be:

import re
from typing import Tuple, Set

def find_tags(text: str, replacer: callable = None) -> Tuple[Set[str], str]:
    code_blocks = list(re.finditer(r'```[\s\S]*?```', text, re.DOTALL))
    non_code_parts = []
    start = 0
    for match in code_blocks:
        end = match.start()
        non_code_parts.append(text[start:end])
        start = match.end()
    non_code_parts.append(text[start:])
    
    tags = set()
    modified_parts = []
    for part in non_code_parts:
        tag_matches = re.findall(r'#(\w+)', part)
        tags.update(tag_matches)
        if replacer:
            modified_part = re.sub(r'#(\w+)', lambda m: replacer(m.group(1)), part)
        else:
            modified_part = part
        modified_parts.append(modified_part)
    
    modified_text = ''
    for i, part in enumerate(non_code_parts):
        modified_text += modified_parts[i]
        if i < len(code_blocks):
            modified_text += code_blocks[i].group(0)
    
    return tags, modified_text

But I need to make sure that the code is correct. Also, the regex for code blocks may need to be adjusted. For example, the code block may have a language specifier, like ```python, but the regex r'```[\s\S]*?```' would match that.

Another thing: the code uses re.DOTALL, which allows the . to match newlines. So, the code blocks can span multiple lines.

Now, testing this code with some examples.

Example 1:

text = "This is a #tag and another #tag2."

code_blocks is empty. non_code_parts is [text].

tags would be {'tag', 'tag2'}.

modified_parts would be the same as text if no replacer, or replaced.

Example 2:

text = "Normal text. ```code block``` #tag inside normal text."

non_code_parts would be ["Normal text. ", " #tag inside normal text."]

tags would be {'tag'}.

modified_parts would be "Normal text. " and "replacer(tag) if replacer is provided."

Then, modified_text is "Normal text. ```code block``` replacer(tag)".

So, the code seems to work.

But what about if the code block is in the middle of the text?

Another example:

text = "Before code. ```code block``` After code."

non_code_parts would be ["Before code. ", " After code."].

code_blocks has one element.

modified_text would be modified_parts[0] + code_blocks[0].group(0) + modified_parts[1].

So, the code is correct.

But what if the code block is at the end?

text = "Some text. ```code block```"

non_code_parts would be ["Some text. ", ""].

So, the code would process "Some text. " for tags, and then add the code block.

Thus, the code seems to handle that.

Now, the code may have some issues. For example, if the text has multiple code blocks, the code would split them correctly.

But what about if the code blocks are not properly closed? For example, if the text is "```code block", then the regex would not match it, so it would be considered as part of the non_code_parts. But the problem says to try to ignore tags inside code blocks, so perhaps it's acceptable.

Another possible issue is that the code uses re.findall(r'#(\w+)', part) which may not capture all possible tag formats. But again, without specific info, this is an assumption.

Thus, the code should be as above.
