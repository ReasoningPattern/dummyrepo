
Okay, I need to create a Python function called unit_of_work that returns a decorator with metadata and timeout attributes. Let me think about how to approach this.

First, the function unit_of_work takes two optional parameters: metadata and timeout. The goal is to return a decorator that can be applied to other functions, and this decorator should have attributes for metadata and timeout. 

Wait, decorators in Python are functions that wrap another function. So, the unit_of_work function itself is a decorator factory. When someone uses @unit_of_work() as a decorator, they might pass metadata and timeout arguments. So the decorator needs to accept those parameters and then apply them to the wrapped function.

But how do I make the decorator have those attributes? Oh right, the decorator function should have the metadata and timeout as attributes. So maybe the decorator is a function that takes the original function and returns a new function, which then has the metadata and timeout set as attributes.

Let me outline the steps. The unit_of_work function will return a decorator. The decorator should take a function and return a wrapped function. The wrapped function should have metadata and timeout attributes set from the parameters passed to unit_of_work.

Wait, but when you use a decorator with arguments, like @decorator(arg1, arg2), the decorator function is called with those arguments. So the unit_of_work function is the outer function that takes metadata and timeout, and returns the actual decorator function.

So the structure would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # maybe some logic here
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

But the user's docstring says the decorator has metadata and timeout attributes. So when someone applies the decorator to a function, that function's wrapper will have those attributes.

Wait, but the decorator is supposed to return a decorator that has those attributes. Wait, no. The decorator function (the one returned by unit_of_work) is the one that should have the metadata and timeout attributes. Or is it the wrapped function?

Wait, the docstring says "Returns a decorator with metadata and timeout attributes." So the decorator itself (the function returned by unit_of_work) should have those attributes. But that doesn't make sense because the decorator is a function. Unless the decorator is a class, but the user didn't mention that.

Alternatively, maybe the decorator is a function that, when applied, sets those attributes on the wrapped function. Wait, the wording is a bit ambiguous. Let me re-read the docstring.

The docstring says: "Returns a decorator with metadata and timeout attributes." So the decorator (the function returned by unit_of_work) should have those attributes. But that's not typical. Usually, the decorated function has attributes. So perhaps the user wants the decorator to have those attributes, but that's not standard. Maybe they meant the decorated function.

Alternatively, maybe the decorator is a class. But the function signature suggests it's a function. Hmm.

Wait, perhaps the user wants the decorator to have metadata and timeout as attributes, so that when you apply the decorator, those attributes are stored on the decorator function. But that's not very common. Let me think of an example.

Suppose someone does:

@unit_of_work(metadata="some data", timeout=30)
def my_function():
    pass

In this case, the decorator is called with metadata and timeout, and then the decorator function (which wraps my_function) should have those attributes. So the decorator function (the one returned by unit_of_work) would have metadata and timeout attributes.

Wait, but the unit_of_work function is called with metadata and timeout, and returns the decorator. So the decorator is a function that takes the original function and returns a wrapped function. But how to attach metadata and timeout to the decorator itself?

Wait, maybe the user is thinking of the decorator as a function that, when applied, sets those attributes on the wrapped function. For example, the wrapped function would have metadata and timeout attributes. That would make more sense. Let me check the original question again.

The user says: "Generate Python code based on the following function signature and docstring. Do NOT include any explanation, reasoning, or markdown formatting. Output ONLY the code generated, in python markdown format."

The function signature is def unit_of_work(metadata=None, timeout=None):, and the docstring says it returns a decorator with metadata and timeout attributes. So the decorator (the function returned by unit_of_work) should have those attributes. But that's not standard. Usually, the decorated function has those attributes. Maybe the user wants the decorator to have them, but that's unclear.

Alternatively, maybe the decorator is a class, and the function returns an instance of that class. But the function signature is for a function, not a class.

Alternatively, perhaps the decorator is a function that, when applied, adds metadata and timeout to the wrapped function. So the unit_of_work function returns a decorator that, when used, sets those attributes on the function it decorates.

So, for example, when you use @unit_of_work(metadata=..., timeout=...), the decorator function (which is the one inside unit_of_work) would take the function and return a wrapper that has those attributes. Wait, but the decorator function itself would have metadata and timeout as parameters. So maybe the decorator function is supposed to have those attributes. But that's not typical. Let me think.

Let me consider the standard way. If you have a decorator that takes arguments, like:

def my_decorator(arg1, arg2):
    def decorator(func):
        def wrapper(*args, **kwargs):
            # do something
        wrapper.arg1 = arg1
        wrapper.arg2 = arg2
        return wrapper
    return decorator

Then when you use @my_decorator(a, b), the decorator function (decorator) is called with a and b, and those are stored as attributes on the wrapper function.

But the user's docstring says that the decorator has metadata and timeout attributes. So perhaps the decorator function (the one returned by unit_of_work) is supposed to have those attributes. But that's not the usual case. Maybe the user made a mistake in the docstring, but I have to follow it.

Wait, the function unit_of_work is supposed to return a decorator. So the decorator is a function that takes a function and returns a wrapped function. The decorator itself (the function returned by unit_of_work) should have metadata and timeout attributes. But how?

Wait, maybe the unit_of_work function is the decorator, and it's supposed to have those attributes. But that's not possible because when you apply the decorator, you pass metadata and timeout to unit_of_work, which then becomes the attributes of the decorator function.

Wait, perhaps the user wants the decorator to have those attributes, so that when you apply it, you can access them. For example:

@unit_of_work(metadata="...", timeout=...)
def my_func():
    pass

Then, the unit_of_work function is called with metadata and timeout, and returns a decorator function. The decorator function would have those attributes. But that's not standard. Normally, the wrapped function would have them.

Alternatively, maybe the user wants the decorator to be a class, and the function returns an instance of that class. But the function signature is for a function.

This is a bit confusing. Let me think again. The function unit_of_work is supposed to return a decorator. The decorator is a function that takes a function and returns a wrapped function. The decorator itself (the function returned by unit_of_work) should have metadata and timeout attributes. So when you call unit_of_work with metadata and timeout, those are set as attributes on the decorator function.

Wait, but the decorator function is the one that's called when you apply the decorator. So for example:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        # ...
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

But then, when you use @unit_of_work(...), the decorator function (decorator) is called with the function, and the decorator has metadata and timeout as attributes. But that's not the usual way. Normally, the attributes would be on the wrapped function.

But according to the docstring, the decorator should have those attributes. So perhaps the user wants that. Let me proceed with that approach.

So the code would be:

def unit_of_work(metadata=None, timeout=None):
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

But then, when you apply the decorator, the decorator function (decorator) has metadata and timeout attributes. However, the wrapper function doesn't have them. But the docstring says the decorator has them. So this code would satisfy that.

But maybe the user intended that the wrapped function has those attributes. Let me check the original question again. The docstring says "Returns a decorator with metadata and timeout attributes." So the decorator (the function returned by unit_of_work) has those attributes. So the code above is correct.

Alternatively, perhaps the user wants the wrapper function to have those attributes. But the wording is ambiguous. However, given the docstring, I think the first approach is correct.

So the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

But maybe the user wants the decorator to be a class. For example, a class-based decorator. But the function signature is for a function.

Alternatively, perhaps the user wants the decorator to have those attributes, and the wrapper function to have them as well. But the docstring isn't clear.

Alternatively, maybe the decorator is a function that, when applied, adds those attributes to the function it decorates. So the decorator function (the one inside unit_of_work) would set the attributes on the func.

Wait, that would make more sense. Let me think. For example, when you apply the decorator, the function being decorated would have metadata and timeout attributes. So the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

But then, the decorator function itself (the one returned by unit_of_work) doesn't have those attributes. The wrapper function does. But the docstring says the decorator has them. So perhaps the user intended that the decorator function (the one returned by unit_of_work) has those attributes. But that's not the usual case.

Alternatively, maybe the user is mistaken and the docstring should refer to the wrapped function. But since I have to follow the docstring, I need to make sure that the decorator (the function returned by unit_of_work) has those attributes.

So the code I wrote earlier where decorator.metadata and decorator.timeout are set would be correct. But perhaps the user expects that when you apply the decorator, the decorated function has those attributes. Let me think about the example.

If someone uses:

@unit_of_work(metadata="test", timeout=10)
def my_func():
    pass

Then, the decorator is called with metadata and timeout, and the decorator function (decorator) is returned. The decorator function has metadata and timeout as attributes. But the my_func would be replaced by the wrapper function, which doesn't have those attributes. Unless the wrapper function is assigned those attributes.

So maybe the user wants the wrapper function to have those attributes. In that case, the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

But the docstring says the decorator has those attributes, not the wrapper. However, this is the standard approach. Maybe the user made a mistake in the docstring, but I have to follow it.

Alternatively, perhaps the decorator is a class. Let me think. Maybe the function unit_of_work returns a class instance that acts as a decorator. For example:

class UnitOfWork:
    def __init__(self, metadata=None, timeout=None):
        self.metadata = metadata
        self.timeout = timeout
    def __call__(self, func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

Then, the function unit_of_work would return an instance of UnitOfWork. But the function signature is def unit_of_work(...):, which returns a decorator. So perhaps the user wants a function-based decorator.

But the user's example shows a function signature, not a class. So perhaps the correct approach is to have the decorator function (the one inside unit_of_work) have those attributes. But that's not standard. Let me think again.

The user's docstring says the decorator has metadata and timeout attributes. So the decorator (the function returned by unit_of_work) should have those attributes. So when you call unit_of_work with metadata and timeout, those are set as attributes on the decorator function.

So the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

But then, when you apply the decorator, the decorator function (decorator) has those attributes. However, the wrapped function (wrapper) doesn't. But maybe that's what the user wants.

Alternatively, maybe the user wants the wrapper to have those attributes. But the docstring is unclear. Since the user provided the docstring, I should follow it.

So the code above would set the attributes on the decorator function. But perhaps the user intended that the decorated function has those attributes. In that case, the code should set them on the wrapper.

But the docstring says the decorator has them. So I think the first approach is correct.

But let me think of another possibility. Maybe the decorator is a function that, when called, returns a function with those attributes. But that's the same as the second approach.

Alternatively, maybe the user wants the decorator to be a function that, when applied, adds those attributes to the function it decorates. So the wrapper function has metadata and timeout attributes.

In that case, the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

This way, when you apply the decorator, the wrapper function (the one that replaces the original function) has metadata and timeout attributes. That seems more likely, but the docstring says the decorator has them, not the wrapper.

But perhaps the user made a mistake in the docstring. Since the function is called unit_of_work, which is a decorator, it's more common that the decorated function has those attributes. So I think the second approach is correct.

But since the user's docstring says the decorator has them, I need to make sure that the decorator function (the one returned by unit_of_work) has those attributes. So the first code.

But in that case, when you apply the decorator, the decorator function (decorator) has metadata and timeout. But the original function is replaced by the wrapper, which doesn't have those attributes. So maybe the user wants the decorator to have those attributes, but that's not very useful.

Alternatively, perhaps the user wants the decorator to be a function that, when called, returns a function with those attributes. But that's the same as the second approach.

Hmm. This is a bit ambiguous, but given the docstring, I'll proceed with the first approach where the decorator function (the one returned by unit_of_work) has metadata and timeout attributes. However, I'm not entirely sure. Let me think of another way.

Wait, maybe the user wants the decorator to be a function that, when applied, the decorated function has those attributes. So the decorator function (decorator) is the one that sets them on the func. But that's not standard. Normally, you set them on the wrapper.

Alternatively, perhaps the user wants the decorator to have those attributes, and the wrapper function to have them as well. But how?

Alternatively, perhaps the user is thinking of a decorator that is a class, and the function returns an instance of that class. For example:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    class Decorator:
        def __init__(self, func):
            self.func = func
            self.metadata = metadata
            self.timeout = timeout
        def __call__(self, *args, **kwargs):
            return self.func(*args, **kwargs)
    return Decorator

But then, the Decorator class is the decorator. So when you apply @unit_of_work(...), you're creating an instance of Decorator, which has metadata and timeout attributes. But the original function is replaced by the instance, which has those attributes. However, the user's function signature is for a function, not a class. So this approach would require the unit_of_work to return a class, but the function signature is def unit_of_work(...):, which returns a decorator. So perhaps the user expects a function-based decorator.

But given the ambiguity, I think the most likely correct approach is that the decorator function (the one inside unit_of_work) sets the metadata and timeout attributes on the wrapped function. So the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        wrapper.metadata = metadata
        wrapper.timeout = timeout
        return wrapper
    return decorator

This way, when you apply the decorator, the wrapped function (wrapper) has metadata and timeout attributes. That seems more useful. But the docstring says the decorator has them, not the wrapped function. However, given that the decorator is a function that wraps another function, it's possible that the user intended the wrapper to have those attributes.

Alternatively, maybe the user wants the decorator function (the one returned by unit_of_work) to have those attributes. Let me think of an example. Suppose someone does:

@unit_of_work(metadata="test", timeout=10)
def my_func():
    pass

Then, the decorator function (decorator) would have metadata and timeout attributes. But the my_func is replaced by the wrapper function, which doesn't have them. However, the decorator function itself (decorator) is the one that has those attributes. But that's not very useful. 

But given the docstring, perhaps that's what is required. However, I think the more common usage is that the decorated function has those attributes. So maybe the user made a mistake in the docstring. But since I have to follow the docstring, I need to make sure that the decorator (the function returned by unit_of_work) has those attributes.

Wait, the function unit_of_work is the decorator factory. When you call unit_of_work with metadata and timeout, it returns the decorator function. So the decorator function (decorator) is the one that has those attributes. So in that case, the code would be:

def unit_of_work(metadata=None, timeout=None):
    """
    Returns a decorator with metadata and timeout attributes.
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper
    decorator.metadata = metadata
    decorator.timeout = timeout
    return decorator

Yes, this way, the decorator function (decorator) has metadata and timeout as attributes. But when you apply the decorator, the wrapper function is created, which doesn't have those attributes. However, the docstring says the decorator has them, so this code would satisfy that.

But maybe the user wants the wrapper to have those attributes. It's a bit unclear. However, given the information, I'll proceed with the code that sets the attributes on the decorator function itself. That's what the docstring says.

So the code would be as above. Let me check again. The unit_of_work function returns the decorator function, which has metadata and timeout attributes. So when you use @unit_of_work(...), the decorator function is created with those attributes. 

But in practice, this might not be very useful. However, the user's instruction is to generate code based on the given function signature and docstring. So I'll proceed with that.
