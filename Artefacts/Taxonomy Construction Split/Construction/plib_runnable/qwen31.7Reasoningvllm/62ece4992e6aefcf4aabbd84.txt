
Okay, I need to write a Python function called is_ipv4 that checks if a given target is an IPv4 address. Let's think about how to approach this.

First, what's an IPv4 address? It's a 32-bit number divided into four octets, each ranging from 0 to 255. So the format is something like 192.168.1.1.

But how do I check this in Python? Well, I can use the ipaddress module, which has a validate function. But wait, the problem says not to use any external libraries. Oh, right, the user didn't mention anything about using external libraries, so I should implement it manually.

Alternatively, I can split the string into parts and check each part. Let's outline the steps:

1. Check if the input is a string. If it's not, return False.
2. Split the string by dots. If there are not exactly four parts, return False.
3. For each part, check if it's a valid integer between 0 and 255.
4. Also, ensure that each part is a non-negative integer.

Wait, but what about leading zeros? Like 0123.0123? Those would be invalid because they're not integers. So each part must be a valid integer, and when converted to an integer, it should be between 0 and 255.

So the steps would be:

- Check if the input is a string.
- Split into parts. If length is not 4, return False.
- For each part in the parts list:
   - Check if it's a string. If not, return False.
   - Convert to integer. If conversion fails, return False.
   - Check if the integer is between 0 and 255 inclusive.

But also, the parts must be numeric. So for example, "192.168.0.1" is valid, but "192.168.0.1a" is invalid.

So the code would look something like this:

def is_ipv4(target):
    if not isinstance(target, str):
        return False
    parts = target.split('.')
    if len(parts) != 4:
        return False
    for part in parts:
        if not part.isdigit():
            return False
        num = int(part)
        if num < 0 or num > 255:
            return False
    return True

Wait, but what about leading zeros? Like "0123.0123"? The code would convert them to 123 and 123, which are valid. But the problem might consider that as invalid. However, the ipaddress module's validate function allows leading zeros, so maybe that's acceptable. But according to the problem's requirements, maybe leading zeros are allowed. But the problem says "IPv4 address or not", so perhaps the code should accept leading zeros. But the code as written would allow that.

But maybe the problem expects that each part is a valid integer, which would include leading zeros. For example, "0001.0002.0003.0004" would be considered valid. But in reality, IPv4 addresses can have leading zeros, so the code is correct.

But wait, the code checks if each part is a digit. So "0123" is a digit string, and converting to int would be 123, which is valid. So that's okay.

But what about empty strings or strings with whitespace? The code splits on dots, so if the target is "192.168.0.1 ", the split would result in ["192.168.0.1", ""], which would have length 1, so returns False. So that's handled.

Another edge case: "255.255.255.255" is valid. "256.0.0.0" would be invalid because 256 > 255.

So the code seems to handle these cases.

But wait, what about "192.168.0.1" vs "192.168.0.1."? The split would have 5 parts, so returns False.

So the code seems to handle those cases.

Therefore, the code should be as written above. But I need to make sure that the function returns True only if all parts are valid.

Yes. So the code is as follows.
